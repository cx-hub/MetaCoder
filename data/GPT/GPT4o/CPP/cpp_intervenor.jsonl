{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n#include <cmath> // for std::abs\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector\n    sort(numbers.begin(), numbers.end());\n    \n    // Check adjacent elements for closeness\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (fabs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true; // Found two elements closer than the threshold\n        }\n    }\n    \n    return false; // No elements found that are closer than the threshold\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype> // for isspace\n\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (isspace(ch)) {\n            continue; // Ignore spaces\n        }\n        \n        // Add the character to the current group\n        current_group += ch;\n\n        // Update balance\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n        }\n\n        // If balance is zero, we have a complete group\n        if (balance == 0 && !current_group.empty()) {\n            result.push_back(current_group);\n            current_group.clear(); // Reset for the next group\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    // Get the integer part of the number\n    float integer_part = floor(number);\n    // Calculate the decimal part\n    float decimal_part = number - integer_part;\n    return decimal_part;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a balance of zero\n\n    // Iterate through each operation in the vector\n    for (int operation : operations) {\n        balance += operation; // Update the balance\n\n        // Check if the balance falls below zero\n        if (balance < 0) {\n            return true; // Return true if balance is below zero\n        }\n    }\n\n    return false; // Return false if balance never goes below zero\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Step 1: Calculate the mean\n    float sum = 0.0;\n    int n = numbers.size();\n    \n    for (float num : numbers) {\n        sum += num;\n    }\n    \n    float mean = sum / n;\n\n    // Step 2: Calculate the absolute differences and their sum\n    float mad_sum = 0.0;\n    \n    for (float num : numbers) {\n        mad_sum += fabs(num - mean);\n    }\n\n    // Step 3: Calculate the Mean Absolute Deviation\n    float mad = mad_sum / n;\n\n    return mad;\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimiter) {\n    // If the input vector is empty, return an empty vector\n    if (numbers.empty()) {\n        return {};\n    }\n\n    // Create a new vector to hold the result\n    vector<int> result;\n\n    // Loop through the input vector\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        // Add the current element to the result\n        result.push_back(numbers[i]);\n        \n        // If this is not the last element, add the delimiter\n        if (i < numbers.size() - 1) {\n            result.push_back(delimiter);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths; // To store the maximum depth for each group\n    stringstream ss(paren_string); // Use stringstream to split the string\n    string group;\n\n    // Process each group separated by spaces\n    while (ss >> group) {\n        int current_depth = 0; // Current depth of nesting\n        int max_depth = 0; // Maximum depth for the current group\n\n        // Iterate through each character in the group\n        for (char ch : group) {\n            if (ch == '(') {\n                current_depth++; // Increase depth for '('\n                if (current_depth > max_depth) {\n                    max_depth = current_depth; // Update max depth\n                }\n            } else if (ch == ')') {\n                current_depth--; // Decrease depth for ')'\n            }\n        }\n\n        depths.push_back(max_depth); // Store the maximum depth for the group\n    }\n\n    return depths; // Return the vector of maximum depths\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_substring(const vector<string>& strings, const string& substring) {\n    vector<string> filtered_strings;\n\n    for (const string& str : strings) {\n        // Check if the substring is found in the current string\n        if (str.find(substring) != string::npos) {\n            filtered_strings.push_back(str);\n        }\n    }\n\n    return filtered_strings;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\npair<int, int> sum_product(const vector<int>& numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Check if the vector is empty\n    if (numbers.empty()) {\n        return make_pair(sum, product);\n    }\n\n    // Calculate sum and product\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return make_pair(sum, product);\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> result; // Vector to store the rolling maximums\n    int current_max = INT_MIN; // Initialize current_max to the smallest integer\n\n    for (int num : numbers) {\n        // Update current_max if the current number is greater\n        if (num > current_max) {\n            current_max = num;\n        }\n        // Add the current_max to the result vector\n        result.push_back(current_max);\n    }\n\n    return result; // Return the vector of rolling maximums\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(const string& str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    int n = str.length();\n    for (int i = n; i >= 0; --i) {\n        // Check if the substring str[0:i] is a palindrome\n        if (is_palindrome(str.substr(0, i))) {\n            // If it is, append the reverse of the remaining suffix to the original string\n            return str + string(str.rbegin() + (n - i), str.rend());\n        }\n    }\n    return str; // In case the input string is empty or no palindrome found\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of the same length\n    if (a.length() != b.length()) {\n        throw invalid_argument(\"Strings must be of the same length\");\n    }\n\n    string result = \"\";\n    for (size_t i = 0; i < a.length(); ++i) {\n        // Perform XOR operation\n        if (a[i] == b[i]) {\n            result += '0'; // Same bits result in '0'\n        } else {\n            result += '1'; // Different bits result in '1'\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <optional>\n\nusing namespace std;\n\n// Function prototype declaration\noptional<string> longest(const vector<string>& strings);\n\noptional<string> longest(const vector<string>& strings) {\n    // Check if the input vector is empty\n    if (strings.empty()) {\n        return nullopt; // Return None (nullopt in C++)\n    }\n\n    string longestString = strings[0]; // Start with the first string\n\n    // Iterate through the vector to find the longest string\n    for (const auto& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str; // Update longest string\n        }\n    }\n\n    return longestString; // Return the longest string\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure a and b are non-negative\n    a = abs(a);\n    b = abs(b);\n\n    // Use the Euclidean algorithm\n    while (b != 0) {\n        int temp = b;\n        b = a % b; // Remainder of a divided by b\n        a = temp;  // Update a to the previous value of b\n    }\n    return a; // When b is 0, a is the GCD\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    // Iterate through the string and create prefixes\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i)); // Add prefix from index 0 to i\n    }\n    return prefixes;\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss; // Create a stringstream to build the string\n    for (int i = 0; i <= n; ++i) {\n        ss << i; // Add the current number to the stringstream\n        if (i < n) {\n            ss << \" \"; // Add a space if it's not the last number\n        }\n    }\n    return ss.str(); // Convert the stringstream to a string and return it\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <set>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    set<char> distinct_chars; // Set to store distinct characters\n\n    // Iterate through each character in the string\n    for (char c : str) {\n        // Convert character to lowercase and insert into the set\n        distinct_chars.insert(tolower(c));\n    }\n\n    // The size of the set is the number of distinct characters\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    stringstream ss(music_string);\n    string note;\n\n    while (ss >> note) {\n        if (note == \"o\") {\n            beats.push_back(4);\n        } else if (note == \"o|\") {\n            beats.push_back(2);\n        } else if (note == \".|\") {\n            beats.push_back(1);\n        }\n    }\n\n    return beats;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (substring.empty()) {\n        return 0; // If the substring is empty, return 0\n    }\n\n    int count = 0;\n    size_t pos = 0;\n\n    // Loop until we find the substring or reach the end of the string\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++; // Increment the count for each found occurrence\n        pos++;   // Move to the next position to allow for overlapping matches\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Mapping from string to integer\n    map<string, int> num_map = {\n        {\"zero\", 0},\n        {\"one\", 1},\n        {\"two\", 2},\n        {\"three\", 3},\n        {\"four\", 4},\n        {\"five\", 5},\n        {\"six\", 6},\n        {\"seven\", 7},\n        {\"eight\", 8},\n        {\"nine\", 9}\n    };\n\n    // Vector to hold the integer values\n    vector<int> num_values;\n    stringstream ss(numbers);\n    string word;\n\n    // Split the input string and convert to integers\n    while (ss >> word) {\n        if (num_map.find(word) != num_map.end()) {\n            num_values.push_back(num_map[word]);\n        }\n    }\n\n    // Sort the integer values\n    sort(num_values.begin(), num_values.end());\n\n    // Convert sorted integers back to strings\n    vector<string> sorted_words;\n    for (int num : num_values) {\n        for (const auto& pair : num_map) {\n            if (pair.second == num) {\n                sorted_words.push_back(pair.first);\n                break;\n            }\n        }\n    }\n\n    // Join the sorted strings into a single output string\n    string result;\n    for (size_t i = 0; i < sorted_words.size(); ++i) {\n        result += sorted_words[i];\n        if (i < sorted_words.size() - 1) {\n            result += \" \"; // Add space between words\n        }\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\npair<float, float> find_closest_elements(vector<float> numbers) {\n    // Step 1: Sort the vector\n    sort(numbers.begin(), numbers.end());\n\n    // Step 2: Initialize variables to track the closest pair\n    float min_diff = numeric_limits<float>::max();\n    pair<float, float> closest_pair;\n\n    // Step 3: Iterate through the sorted vector to find the closest pair\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = make_pair(numbers[i], numbers[i + 1]);\n        }\n    }\n\n    return closest_pair;\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    // Check if the vector has at least two elements\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"The vector must contain at least two elements.\");\n    }\n\n    // Find the minimum and maximum values in the vector\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n\n    // Create a new vector to store the rescaled values\n    vector<float> rescaled;\n\n    // Rescale each number\n    for (float num : numbers) {\n        float rescaled_value = (num - min_val) / (max_val - min_val);\n        rescaled.push_back(rescaled_value);\n    }\n\n    return rescaled;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> integers;\n\n    for (const auto& value : values) {\n        try {\n            // Attempt to cast the value to an int\n            int intValue = boost::any_cast<int>(value);\n            integers.push_back(intValue); // If successful, add to the result vector\n        } catch (const boost::bad_any_cast&) {\n            // If the cast fails, we simply ignore this value\n        }\n    }\n\n    return integers;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to return the length of the given string\nint strlen(string str) {\n    return str.size(); // or str.length();\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    // Start from n-1 and go down to 1\n    for (int i = n - 1; i > 0; i--) {\n        if (n % i == 0) { // Check if i is a divisor of n\n            return i; // Return the first divisor found\n        }\n    }\n    return 1; // If no divisor is found, return 1 (since 1 divides all integers)\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i * i <= n; i += 2) {\n        // While i divides n, add i and divide n\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(const vector<int>& numbers) {\n    unordered_map<int, int> frequency_map;\n    \n    // Count the frequency of each number\n    for (int num : numbers) {\n        frequency_map[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Add elements that occur only once to the result\n    for (int num : numbers) {\n        if (frequency_map[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // For islower and isupper\n\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) { // Iterate through each character in the string\n        if (islower(c)) {\n            c = toupper(c); // Convert to uppercase if it's lowercase\n        } else if (isupper(c)) {\n            c = tolower(c); // Convert to lowercase if it's uppercase\n        }\n    }\n    return str; // Return the modified string\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring concatenate(const vector<string>& strings) {\n    string result;\n    for (const string& str : strings) {\n        result += str; // Append each string to the result\n    }\n    return result; // Return the concatenated string\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_prefix(const vector<string>& strings, const string& prefix) {\n    vector<string> filtered;\n\n    for (const string& str : strings) {\n        // Check if the string starts with the given prefix\n        if (str.find(prefix) == 0) {\n            filtered.push_back(str);\n        }\n    }\n\n    return filtered;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positive_numbers; // Vector to store positive numbers\n    for (float num : l) { // Iterate through each number in the input vector\n        if (num > 0) { // Check if the number is positive\n            positive_numbers.push_back(num); // Add positive number to the new vector\n        }\n    }\n    return positive_numbers; // Return the vector of positive numbers\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Check if n is less than 2\n    if (n <= 1) {\n        return false;\n    }\n    // Check for factors from 2 to the square root of n\n    for (long long i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n            return false; // n is divisible by i, hence not prime\n        }\n    }\n    return true; // n is prime\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <stdexcept>\n\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble poly_derivative(vector<double> xs, double x) {\n    double sum = 0;\n    for (int i = 1; i < xs.size(); i++) {\n        sum += i * xs[i] * pow(x, i - 1);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    // Initial guess for the root\n    double x0 = 0.0; // You can choose a better initial guess based on the polynomial\n    double tolerance = 1e-7; // Tolerance for convergence\n    int max_iterations = 1000; // Maximum iterations to prevent infinite loops\n\n    for (int i = 0; i < max_iterations; i++) {\n        double fx = poly(xs, x0);\n        double dfx = poly_derivative(xs, x0);\n\n        if (fabs(fx) < tolerance) {\n            return x0; // Found a root\n        }\n\n        if (fabs(dfx) < tolerance) {\n            throw runtime_error(\"Derivative is too small; no convergence.\");\n        }\n\n        // Newton-Raphson update\n        x0 = x0 - fx / dfx;\n    }\n\n    throw runtime_error(\"Maximum iterations reached; no convergence.\");\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Create a vector to hold the values at indices divisible by 3\n    vector<int> third_indices_values;\n\n    // Collect values at indices divisible by 3\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            third_indices_values.push_back(l[i]);\n        }\n    }\n\n    // Sort the collected values\n    sort(third_indices_values.begin(), third_indices_values.end());\n\n    // Replace the original values at indices divisible by 3 with sorted values\n    size_t sorted_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            l[i] = third_indices_values[sorted_index++];\n        }\n    }\n\n    return l;\n}\n\n// Example usage\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Use a set to store unique elements\n    set<int> uniqueSet(l.begin(), l.end());\n    \n    // Copy the unique elements back to a vector\n    vector<int> uniqueVector(uniqueSet.begin(), uniqueSet.end());\n    \n    return uniqueVector; // Return the sorted unique elements\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n#include <limits> // For std::numeric_limits\n\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    // Check if the vector is empty\n    if (l.empty()) {\n        // Handle the case of an empty vector (optional)\n        // You could throw an exception or return a special value\n        return std::numeric_limits<float>::quiet_NaN(); // Return NaN for empty vector\n    }\n\n    float max_val = l[0]; // Initialize max_val with the first element\n\n    // Iterate through the vector to find the maximum element\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i]; // Update max_val if a larger element is found\n        }\n    }\n\n    return max_val; // Return the maximum value found\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint count_digit_seven(int number) {\n    int count = 0;\n    while (number > 0) {\n        if (number % 10 == 7) {\n            count++;\n        }\n        number /= 10;\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int total_count = 0;\n\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            total_count += count_digit_seven(i);\n        }\n    }\n\n    return total_count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Create a vector to hold the even indexed values\n    vector<float> even_values;\n\n    // Extract even indexed values\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n\n    // Sort the even indexed values\n    sort(even_values.begin(), even_values.end());\n\n    // Create a result vector\n    vector<float> result(l.size());\n\n    // Fill the result vector\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            // Place sorted even values in even indices\n            result[i] = even_values[i / 2];\n        } else {\n            // Keep odd indices unchanged\n            result[i] = l[i];\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++) {\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output = output + x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string. \n    */\n    int l = s.length();\n    string output;\n    int i;\n    for (i = 0; i * 3 < l; i++) {\n        // reverse the cycling of elements in each group.\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[x.length() - 1] + x.substr(0, 2);\n        output = output + x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to return the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    int a = 0, b = 1; // Starting Fibonacci numbers\n    int count = 0; // Count of prime Fibonacci numbers\n    int prime_fib_num = 0; // The n-th prime Fibonacci number\n\n    while (count < n) {\n        int next_fib = a + b; // Generate next Fibonacci number\n        a = b; // Move to the next Fibonacci number\n        b = next_fib;\n\n        // Check if the Fibonacci number is prime\n        if (is_prime(next_fib)) {\n            count++; // Increment count of prime Fibonacci numbers\n            prime_fib_num = next_fib; // Update the last found prime Fibonacci number\n        }\n    }\n\n    return prime_fib_num; // Return the n-th prime Fibonacci number\n}\n\n// Main function to test the prime_fib function\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    // Iterate through the vector\n    for (int i = 0; i < n - 2; i++) {\n        // Skip duplicate elements to ensure distinct elements\n        if (i > 0 && l[i] == l[i - 1]) continue;\n\n        // Use two pointers to find the other two elements\n        int left = i + 1;\n        int right = n - 1;\n\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true; // Found a triplet\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    \n    return false; // No triplet found\n}\n\n// Test cases\n"}
{"task_id": "CPP/41", "generation": "#include <stdio.h>\n\nint car_race_collision(int n) {\n    // Each car from the left will collide with each car from the right\n    return n * n; // Total collisions = n (left cars) * n (right cars)\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    // Create a new vector to store the incremented values\n    vector<int> incremented_list;\n    \n    // Iterate through each element in the input vector\n    for (int i = 0; i < l.size(); i++) {\n        // Increment the current element by 1 and add it to the new vector\n        incremented_list.push_back(l[i] + 1);\n    }\n    \n    // Return the new vector with incremented values\n    return incremented_list;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen; // Set to store the numbers we have seen\n\n    for (int num : l) {\n        // Check if the negation of the current number is in the set\n        if (seen.find(-num) != seen.end()) {\n            return true; // Found a pair that sums to zero\n        }\n        seen.insert(num); // Add the current number to the set\n    }\n    \n    return false; // No pairs found that sum to zero\n}\n\n// Example usage\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (base < 2 || base >= 10) {\n        return \"\"; // Base must be between 2 and 9\n    }\n    \n    if (x == 0) {\n        return \"0\"; // Special case for zero\n    }\n\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base; // Get the remainder\n        result = to_string(remainder) + result; // Prepend the remainder to the result\n        x /= base; // Reduce x by dividing it by the base\n    }\n\n    return result; // Return the final result\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h; // Calculate the area using the formula\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    // Handle base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    // Array to store the last four values of the sequence\n    int fib[4] = {0, 0, 2, 0};\n\n    // Compute the sequence iteratively\n    for (int i = 4; i <= n; ++i) {\n        int nextFib = fib[0] + fib[1] + fib[2] + fib[3];\n        // Shift the values in the array\n        fib[0] = fib[1];\n        fib[1] = fib[2];\n        fib[2] = fib[3];\n        fib[3] = nextFib;\n    }\n\n    // The last computed value is in fib[3]\n    return fib[3];\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Get the size of the vector\n    size_t size = l.size();\n    \n    // Check if the size is odd or even\n    if (size % 2 == 1) {\n        // If odd, return the middle element\n        return l[size / 2];\n    } else {\n        // If even, return the average of the two middle elements\n        return (l[(size / 2) - 1] + l[size / 2]) / 2.0;\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Not a palindrome\n        }\n        left++;\n        right--;\n    }\n    return true; // Is a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\n\nint modp(int n, int p) {\n    if (p == 1) return 0; // Since any number mod 1 is 0\n    long long result = 1; // Use long long to handle large results\n    long long base = 2;   // Base is 2\n\n    // Exponentiation by squaring\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd\n            result = (result * base) % p; // Multiply the result by the base\n        }\n        base = (base * base) % p; // Square the base\n        n /= 2; // Divide n by 2\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // Returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (char c : s) {\n        if (isalpha(c)) { // Check if the character is an alphabet\n            char base = islower(c) ? 'a' : 'A'; // Determine the base for lowercase or uppercase\n            char shifted = (c - base + 5) % 26 + base; // Shift and wrap around\n            out += shifted; // Append the shifted character to the output\n        } else {\n            out += c; // Non-alphabet characters are added unchanged\n        }\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // Takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (char c : s) {\n        if (isalpha(c)) { // Check if the character is an alphabet\n            char base = islower(c) ? 'a' : 'A'; // Determine the base for lowercase or uppercase\n            char shifted = (c - base - 5 + 26) % 26 + base; // Shift back and wrap around\n            out += shifted; // Append the shifted character to the output\n        } else {\n            out += c; // Non-alphabet characters are added unchanged\n        }\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        // Check if the character is a vowel (both lowercase and uppercase)\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n            c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            result += c; // Append non-vowel characters to the result\n        }\n    }\n    return result; // Return the string without vowels\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false; // Found a number that is not below the threshold\n        }\n    }\n    return true; // All numbers are below the threshold\n}\n\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to add two numbers\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <set>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create sets to hold unique characters from both strings\n    set<char> chars0(s0.begin(), s0.end());\n    set<char> chars1(s1.begin(), s1.end());\n    \n    // Compare the two sets\n    return chars0 == chars1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) return 0; // Fibonacci of 0 is 0\n    if (n == 1) return 1; // Fibonacci of 1 is 1\n\n    int a = 0; // F(0)\n    int b = 1; // F(1)\n    int c; // To store the next Fibonacci number\n\n    for (int i = 2; i <= n; i++) {\n        c = a + b; // F(n) = F(n-1) + F(n-2)\n        a = b;     // Update F(n-2)\n        b = c;     // Update F(n-1)\n    }\n\n    return b; // F(n) is now in b\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // This will keep track of the balance of brackets\n\n    for (char ch : brackets) {\n        if (ch == '<') {\n            balance++; // Increment for an opening bracket\n        } else if (ch == '>') {\n            balance--; // Decrement for a closing bracket\n        }\n\n        // If balance goes negative, it means there's a closing bracket without a matching opening bracket\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // At the end, balance should be zero if all brackets are matched\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() < 2) {\n        return true; // A vector with less than 2 elements is considered monotonic\n    }\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false; // Found an increasing pair\n        } else if (l[i] < l[i - 1]) {\n            increasing = false; // Found a decreasing pair\n        }\n    }\n\n    return increasing || decreasing; // Return true if either increasing or decreasing\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Use a set to store unique elements from the first vector\n    set<int> set1(l1.begin(), l1.end());\n    // Use a set to store unique elements from the second vector\n    set<int> set2(l2.begin(), l2.end());\n    \n    // Set to store common elements\n    set<int> commonSet;\n    \n    // Find common elements\n    for (int num : set1) {\n        if (set2.find(num) != set2.end()) {\n            commonSet.insert(num);\n        }\n    }\n    \n    // Convert the set of common elements to a vector\n    vector<int> result(commonSet.begin(), commonSet.end());\n    \n    // Sort the result (although sets are already sorted)\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int largest_factor = -1;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        largest_factor = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest_factor = i;\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        largest_factor = n;\n    }\n\n    return largest_factor;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    int sum = 0; // Initialize sum to 0\n    for (int i = 1; i <= n; i++) { // Loop from 1 to n\n        sum += i; // Add each number to sum\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // This will keep track of the balance of brackets\n\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++; // Increment for an opening bracket\n        } else if (ch == ')') {\n            balance--; // Decrement for a closing bracket\n        }\n\n        // If balance goes negative, we have more closing brackets than opening ones\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // If balance is zero, all brackets are matched; otherwise, they are not\n    return balance == 0;\n}\n\n// Test cases\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<float> derivative(const vector<float>& xs) {\n    vector<float> result;\n    int degree = xs.size() - 1; // The degree of the polynomial\n\n    // Iterate through the coefficients, starting from the first term (x^1)\n    for (int i = 1; i <= degree; ++i) {\n        // Calculate the derivative coefficient\n        result.push_back(xs[i] * i);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    // Handle base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Initialize an array to store the computed values\n    int fibfibArray[n + 1];\n    fibfibArray[0] = 0;\n    fibfibArray[1] = 0;\n    fibfibArray[2] = 1;\n\n    // Compute the values iteratively\n    for (int i = 3; i <= n; i++) {\n        fibfibArray[i] = fibfibArray[i - 1] + fibfibArray[i - 2] + fibfibArray[i - 3];\n    }\n\n    // Return the n-th FibFib number\n    return fibfibArray[n];\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    int length = s.length();\n\n    for (int i = 0; i < length; i++) {\n        char c = tolower(s[i]); // Convert to lowercase for case-insensitivity\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n\n    // Check if the last character is 'y'\n    if (length > 0 && tolower(s[length - 1]) == 'y') {\n        count++;\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string\n    string str = to_string(x);\n    int len = str.length();\n    \n    // Calculate effective shift\n    int effective_shift = shift % len;\n\n    // If effective shift is 0, return the original string\n    if (effective_shift == 0) {\n        return str;\n    }\n\n    // If effective shift is greater than 0, perform the circular shift\n    string shifted = str.substr(len - effective_shift) + str.substr(0, len - effective_shift);\n    \n    return shifted;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0; // Initialize sum to 0\n    for (char c : s) { // Iterate through each character in the string\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add the ASCII value of the uppercase character to sum\n        }\n    }\n    return sum; // Return the final sum\n}\n\n// Example usage\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0, oranges = 0;\n\n    // Use a string stream to parse the input string\n    stringstream ss(s);\n    string word;\n\n    // Read through the string to find the numbers of apples and oranges\n    while (ss >> word) {\n        if (word == \"apples\") {\n            ss >> apples; // Get the number before \"apples\"\n        } else if (word == \"oranges\") {\n            ss >> oranges; // Get the number before \"oranges\"\n        }\n    }\n\n    // Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n    return mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int smallestEvenValue = -1; // Initialize to -1 to indicate no even value found\n    int smallestIndex = -1; // Initialize index to -1\n\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            // If it's the first even number found or smaller than the current smallest\n            if (smallestEvenValue == -1 || arr[i] < smallestEvenValue) {\n                smallestEvenValue = arr[i];\n                smallestIndex = i;\n            }\n        }\n    }\n\n    // If no even number was found, return an empty vector\n    if (smallestEvenValue == -1) {\n        return {};\n    }\n\n    // Return the smallest even value and its index\n    return {smallestEvenValue, smallestIndex};\n}\n\n// Example usage\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequencyMap;\n\n    // Count the frequency of each integer in the vector\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    int result = -1;\n\n    // Check for the greatest integer that meets the condition\n    for (const auto& pair : frequencyMap) {\n        int value = pair.first;\n        int frequency = pair.second;\n\n        // Check if the frequency is greater than or equal to the value\n        if (frequency >= value) {\n            result = max(result, value);\n        }\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/70", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the input list\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int left = 0;            // Pointer for the minimum values\n    int right = lst.size() - 1; // Pointer for the maximum values\n\n    // Alternate between the minimum and maximum values\n    while (left <= right) {\n        if (left == right) {\n            result.push_back(lst[left]); // If both pointers meet, add the last element\n        } else {\n            result.push_back(lst[left]); // Add the minimum\n            result.push_back(lst[right]); // Add the maximum\n        }\n        left++;\n        right--;\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check for valid triangle using the triangle inequality theorem\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1; // Not a valid triangle\n    }\n\n    // Calculate the semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate the area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Return the area rounded to 2 decimal points\n    return round(area * 100) / 100; // Rounding to 2 decimal points\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool is_palindrome(const vector<int>& q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false; // Not a palindrome\n        }\n    }\n    return true; // Is a palindrome\n}\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is a palindrome\n    if (!is_palindrome(q)) {\n        return false; // Not balanced\n    }\n    \n    // Calculate the sum of the elements\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    \n    // Check if the sum is less than or equal to the maximum weight\n    return sum <= w;\n}\n\n// Example usage\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int changes = 0;\n    int left = 0;\n    int right = arr.size() - 1;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++; // We need to change one of these elements\n        }\n        left++;\n        right--;\n    }\n\n    return changes;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Function to calculate total number of characters in a vector of strings\n    auto total_chars = [](const vector<string>& lst) {\n        int total = 0;\n        for (const string& str : lst) {\n            total += str.size();\n        }\n        return total;\n    };\n\n    // Calculate total characters for both vectors\n    int total1 = total_chars(lst1);\n    int total2 = total_chars(lst2);\n\n    // Compare totals and return the appropriate vector\n    if (total1 < total2) {\n        return lst1;\n    } else {\n        return lst2; // This includes the case where totals are equal\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate all prime numbers less than 100\nvector<int> generate_primes() {\n    vector<int> primes;\n    for (int i = 2; i < 100; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to check if a number is the product of three prime numbers\nbool is_multiply_prime(int a) {\n    vector<int> primes = generate_primes();\n    \n    // Check all combinations of three primes\n    for (size_t i = 0; i < primes.size(); i++) {\n        for (size_t j = 0; j < primes.size(); j++) {\n            for (size_t k = 0; k < primes.size(); k++) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    // Handle special cases\n    if (n <= 1) {\n        return (n == 1 && x == 1); // 1^k = 1 for any k, and 0^k is not defined for k > 0\n    }\n    if (x < 1) {\n        return false; // x must be a positive integer\n    }\n\n    int power = 1; // Start with n^0\n    while (power < x) {\n        power *= n; // Calculate n^k\n    }\n    \n    return power == x; // Check if we found n^k == x\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool iscube(int a) {\n    // Calculate the cube root of the absolute value of a\n    int cubeRoot = round(pow(abs(a), 1.0 / 3.0));\n    \n    // Check if the cube of the rounded cube root equals a\n    return (cubeRoot * cubeRoot * cubeRoot == a) || \n           (-cubeRoot * -cubeRoot * -cubeRoot == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint hex_key(string num) {\n    // Define the set of prime hexadecimal digits\n    const string primeHexDigits = \"2357BD\"; // B and D are included as prime digits\n\n    int count = 0; // Initialize count of prime digits\n\n    // Iterate through each character in the input string\n    for (char c : num) {\n        // Check if the character is in the set of prime hexadecimal digits\n        if (primeHexDigits.find(c) != string::npos) {\n            count++; // Increment count if it's a prime digit\n        }\n    }\n\n    return count; // Return the total count of prime hexadecimal digits\n}\n\n// Example usage\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Handle the case for 0 explicitly\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    string binary = \"\";\n    \n    // Convert decimal to binary\n    while (decimal > 0) {\n        // Prepend the remainder (0 or 1) to the binary string\n        binary = to_string(decimal % 2) + binary;\n        decimal /= 2; // Divide by 2 to shift right\n    }\n    \n    // Add the \"db\" prefix and suffix\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is at least 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string and check every 3 consecutive characters\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        // Check if the three characters are distinct\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    // If all checks passed, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letterGrades;\n\n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letterGrades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letterGrades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letterGrades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letterGrades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letterGrades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letterGrades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letterGrades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letterGrades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letterGrades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letterGrades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letterGrades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letterGrades.push_back(\"D-\");\n        } else if (gpa == 0.0) {\n            letterGrades.push_back(\"E\");\n        }\n    }\n\n    return letterGrades;\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) { // Check for factors up to the square root of n\n        if (n % i == 0) return false; // If n is divisible by i, it's not prime\n    }\n    return true; // n is prime\n}\n\n// Function to check if the length of the string is prime\nbool prime_length(string str) {\n    int length = str.length(); // Get the length of the string\n    return is_prime(length); // Check if the length is prime\n}\n\n// Example usage\n"}
{"task_id": "CPP/83", "generation": "#include <stdio.h>\n#include <cmath>\n\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n < 1) return 0; // Invalid case for n\n\n    // Count of n-digit numbers starting with '1'\n    long long start_with_1 = pow(10, n - 1);\n\n    // Count of n-digit numbers ending with '1'\n    long long end_with_1 = 9 * pow(10, n - 2);\n\n    // Count of n-digit numbers starting and ending with '1'\n    long long start_and_end_with_1 = pow(10, n - 2);\n\n    // Total count using inclusion-exclusion principle\n    long long total_count = start_with_1 + end_with_1 - start_and_end_with_1;\n\n    return total_count;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    // Step 1: Calculate the sum of the digits\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to sum\n        N /= 10;       // Remove the last digit\n    }\n\n    // Step 2: Convert the sum to binary\n    string binary = \"\";\n    if (sum == 0) {\n        return \"0\"; // Handle the case where the sum is 0\n    }\n    \n    while (sum > 0) {\n        binary = to_string(sum % 2) + binary; // Prepend the binary digit\n        sum /= 2; // Divide the sum by 2\n    }\n\n    return binary; // Step 3: Return the binary representation\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (size_t i = 0; i < lst.size(); ++i) { // Loop through the vector\n        if (i % 2 != 0 && lst[i] % 2 == 0) { // Check if index is odd and element is even\n            sum += lst[i]; // Add to sum\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result;\n    stringstream ss(s);\n    string word;\n\n    // Iterate through each word in the string\n    while (ss >> word) {\n        // Sort the characters of the word\n        sort(word.begin(), word.end());\n        // Append the sorted word to the result\n        result += word + \" \";\n    }\n\n    // Now we need to handle the spaces that were originally in the string\n    // We will go through the original string and add spaces accordingly\n    size_t pos = 0;\n    for (char c : s) {\n        if (c == ' ') {\n            result.insert(pos, \" \"); // Insert space at the original position\n            pos++; // Move to the next position\n        } else {\n            pos += result.find_first_not_of(' ', pos); // Move to the next non-space character\n        }\n    }\n\n    // Remove the trailing space if it exists\n    if (!result.empty() && result.back() == ' ') {\n        result.pop_back();\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n\n    // Iterate through each row\n    for (int i = 0; i < lst.size(); ++i) {\n        // Iterate through each column in the current row\n        for (int j = 0; j < lst[i].size(); ++j) {\n            // Check if the current element matches x\n            if (lst[i][j] == x) {\n                // Store the coordinates {row, column}\n                result.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort the result by row index (ascending) and column index (descending)\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort by column index in descending order\n        }\n        return a[0] < b[0]; // Sort by row index in ascending order\n    });\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/88", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(const vector<int>& array) {\n    // Step 1: Handle empty or single-element vector\n    if (array.empty()) {\n        return {};\n    }\n    if (array.size() == 1) {\n        return array;\n    }\n\n    // Step 2: Calculate the sum of the first and last elements\n    int sum = array.front() + array.back();\n\n    // Step 3: Create a copy of the original array to sort\n    vector<int> sorted_array = array;\n\n    // Step 4: Sort based on the sum\n    if (sum % 2 == 0) {\n        // Even sum: sort in descending order\n        sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n    } else {\n        // Odd sum: sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    // Step 5: Return the sorted array\n    return sorted_array;\n}\n\n// Example usage\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string encrypted = \"\";\n    \n    for (char c : s) {\n        // Check if the character is a lowercase letter\n        if (c >= 'a' && c <= 'z') {\n            // Shift the character by 4 positions\n            char newChar = c + 4;\n            // Wrap around if it goes past 'z'\n            if (newChar > 'z') {\n                newChar -= 26; // Wrap around to the start of the alphabet\n            }\n            encrypted += newChar;\n        }\n        // Check if the character is an uppercase letter\n        else if (c >= 'A' && c <= 'Z') {\n            // Shift the character by 4 positions\n            char newChar = c + 4;\n            // Wrap around if it goes past 'Z'\n            if (newChar > 'Z') {\n                newChar -= 26; // Wrap around to the start of the alphabet\n            }\n            encrypted += newChar;\n        }\n        // If it's not a letter, we can choose to ignore it or handle it differently\n        else {\n            encrypted += c; // Just append the character as is\n        }\n    }\n    \n    return encrypted;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    // Use a set to store unique elements\n    set<int> unique_elements(lst.begin(), lst.end());\n    \n    // If there are fewer than 2 unique elements, return -1 (or any other indicator for None)\n    if (unique_elements.size() < 2) {\n        return -1; // or you can use another indicator for None\n    }\n    \n    // Convert the set back to a vector to access the second smallest element\n    vector<int> sorted_unique(unique_elements.begin(), unique_elements.end());\n    \n    // Return the second smallest element\n    return sorted_unique[1];\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <cctype>\n\nusing namespace std;\n\nint is_bored(string S) {\n    // Define the delimiters\n    char delimiters[] = {'.', '?', '!'};\n    \n    // Vector to hold sentences\n    vector<string> sentences;\n    \n    // Use stringstream to split the string\n    stringstream ss(S);\n    string sentence;\n    \n    // Read the string until we find a delimiter\n    while (getline(ss, sentence, '.')) {\n        sentences.push_back(sentence);\n    }\n    ss.clear();\n    ss.str(S);\n    while (getline(ss, sentence, '?')) {\n        sentences.push_back(sentence);\n    }\n    ss.clear();\n    ss.str(S);\n    while (getline(ss, sentence, '!')) {\n        sentences.push_back(sentence);\n    }\n    \n    int boredom_count = 0;\n    \n    // Check each sentence\n    for (const auto& s : sentences) {\n        // Trim leading whitespace\n        size_t start = s.find_first_not_of(\" \\t\\n\");\n        if (start != string::npos) {\n            // Check if the trimmed sentence starts with 'I'\n            if (s[start] == 'I' && (start + 1 == s.length() || isspace(s[start + 1]))) {\n                boredom_count++;\n            }\n        }\n    }\n    \n    return boredom_count;\n}\n\n// Test the function\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n\n    // Check if any number is equal to the sum of the other two\n    return (a == b + c) || (b == a + c) || (c == a + b);\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring encode(string message) {\n    string encodedMessage = \"\";\n\n    for (char c : message) {\n        // Swap case\n        if (isupper(c)) {\n            c = tolower(c);\n        } else if (islower(c)) {\n            c = toupper(c);\n        }\n\n        // Replace vowels\n        switch (c) {\n            case 'a': c = 'c'; break;\n            case 'e': c = 'g'; break;\n            case 'i': c = 'k'; break;\n            case 'o': c = 'q'; break;\n            case 'u': c = 's'; break;\n            case 'A': c = 'C'; break;\n            case 'E': c = 'G'; break;\n            case 'I': c = 'K'; break;\n            case 'O': c = 'Q'; break;\n            case 'U': c = 'S'; break;\n            default: break; // Do nothing for non-vowel characters\n        }\n\n        encodedMessage += c; // Append the modified character to the result\n    }\n\n    return encodedMessage;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to calculate the sum of the digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10; // Add the last digit\n        num /= 10; // Remove the last digit\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and return the sum of its digits\nint largestPrimeDigitSum(const vector<int>& lst) {\n    int largestPrime = -1; // Initialize to -1 to indicate no prime found\n\n    // Iterate through the list to find the largest prime\n    for (int num : lst) {\n        if (isPrime(num) && num > largestPrime) {\n            largestPrime = num; // Update largest prime\n        }\n    }\n\n    // If no prime was found, return 0 or handle as needed\n    if (largestPrime == -1) return 0;\n\n    // Calculate and return the sum of the digits of the largest prime\n    return sumOfDigits(largestPrime);\n}\n\n// Main function\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <cctype> // for islower and isupper\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    // Iterate through the keys in the map\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        // Check if the key is a string (it is, since we are using map<string, string>)\n        // Check if the key is not empty\n        if (key.empty()) {\n            return false;\n        }\n\n        // Check if the key is all lower case or all upper case\n        if (islower(key[0])) {\n            all_upper = false; // If we find a lower case letter, set all_upper to false\n        } else if (isupper(key[0])) {\n            all_lower = false; // If we find an upper case letter, set all_lower to false\n        } else {\n            return false; // If the key contains non-alphabetic characters, return false\n        }\n\n        // Check the rest of the characters in the key\n        for (size_t i = 1; i < key.size(); ++i) {\n            if (islower(key[i])) {\n                all_upper = false; // If we find a lower case letter, set all_upper to false\n            } else if (isupper(key[i])) {\n                all_lower = false; // If we find an upper case letter, set all_lower to false\n            } else {\n                return false; // If the key contains non-alphabetic characters, return false\n            }\n        }\n    }\n\n    // Return true if all keys are either all lower case or all upper case\n    return all_lower || all_upper;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Main function to count primes up to n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i); // Add prime number to the vector\n        }\n    }\n    return primes; // Return the vector of prime numbers\n}\n\n// Example usage\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the unit digits\n    int unit_digit_a = abs(a) % 10; // Use abs to handle negative numbers\n    int unit_digit_b = abs(b) % 10; // Use abs to handle negative numbers\n    \n    // Calculate the product of the unit digits\n    return unit_digit_a * unit_digit_b;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0; // Initialize counter for uppercase vowels\n    // Loop through the string, checking only even indices\n    for (int i = 0; i < s.length(); i += 2) {\n        char c = s[i]; // Get the character at the even index\n        // Check if the character is an uppercase vowel\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++; // Increment the counter\n        }\n    }\n    return count; // Return the total count\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert the string to a double\n    double num = stod(value);\n    \n    // Get the floor and ceil values\n    int lower = static_cast<int>(floor(num));\n    int upper = static_cast<int>(ceil(num));\n    \n    // Calculate the distances to the two integers\n    double distanceToLower = abs(num - lower);\n    double distanceToUpper = abs(num - upper);\n    \n    // Determine which integer to return\n    if (distanceToLower < distanceToUpper) {\n        return lower; // Closer to lower\n    } else if (distanceToUpper < distanceToLower) {\n        return upper; // Closer to upper\n    } else {\n        // Equidistant case\n        if (lower < 0) {\n            return lower; // Round away from zero (towards lower)\n        } else {\n            return upper; // Round away from zero (towards upper)\n        }\n    }\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    int current_stones = n; // Start with n stones for the first level\n\n    for (int i = 0; i < n; i++) {\n        stones.push_back(current_stones); // Add the current level's stones to the vector\n        // Determine the next number of stones based on whether n is odd or even\n        if (n % 2 == 0) {\n            current_stones += 2; // Next even number\n        } else {\n            current_stones += 2; // Next odd number\n        }\n    }\n\n    return stones;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    string word;\n    // Replace commas with spaces to simplify splitting\n    for (char& c : s) {\n        if (c == ',') {\n            c = ' ';\n        }\n    }\n    \n    // Use a stringstream to split the string by spaces\n    stringstream ss(s);\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    \n    return words;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <stdio.h>\n\nint choose_num(int x, int y) {\n    // Check if the range is valid\n    if (x > y) {\n        return -1; // Invalid range\n    }\n\n    // Find the largest even number in the range\n    if (y % 2 == 0) {\n        // y is even\n        return y >= x ? y : -1; // Return y if it's within the range\n    } else {\n        // y is odd, check y - 1\n        int largest_even = y - 1;\n        return largest_even >= x ? largest_even : -1; // Return largest_even if it's within the range\n    }\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    int sum = 0;\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n\n    // Calculate the number of integers from n to m\n    int count = m - n + 1;\n\n    // Calculate the average\n    double average = static_cast<double>(sum) / count;\n\n    // Round down to the nearest integer\n    int rounded_average = static_cast<int>(floor(average));\n\n    // Convert the rounded average to binary\n    string binary = \"\";\n    if (rounded_average == 0) {\n        binary = \"0\";\n    } else {\n        while (rounded_average > 0) {\n            binary = to_string(rounded_average % 2) + binary;\n            rounded_average /= 2;\n        }\n    }\n\n    return binary;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool has_even_digit(int num) {\n    while (num > 0) {\n        int digit = num % 10; // Get the last digit\n        if (digit % 2 == 0) { // Check if the digit is even\n            return true; // Found an even digit\n        }\n        num /= 10; // Remove the last digit\n    }\n    return false; // No even digits found\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        if (!has_even_digit(num)) { // Check if the number has no even digits\n            result.push_back(num); // Add to result if it has only odd digits\n        }\n    }\n\n    sort(result.begin(), result.end()); // Sort the result vector\n    return result; // Return the sorted result\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Step 1: Filter the input vector to keep only numbers between 1 and 9\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Step 2: Sort the filtered vector\n    sort(filtered.begin(), filtered.end());\n\n    // Step 3: Reverse the sorted vector\n    reverse(filtered.begin(), filtered.end());\n\n    // Step 4: Map each number to its corresponding string representation\n    vector<string> result;\n    vector<string> names = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n\n    for (int num : filtered) {\n        result.push_back(names[num - 1]); // num - 1 to get the correct index\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            // Calculate factorial of i\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial; // Store in the vector (0-based index)\n        } else {\n            // Calculate sum of numbers from 1 to i\n            int sum = (i * (i + 1)) / 2; // Using the formula for the sum of first i natural numbers\n            result[i - 1] = sum; // Store in the vector (0-based index)\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is a palindrome\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    int left = 0;\n    int right = str.size() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n\n    for (int i = 1; i <= n; i++) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n\n    return {evenCount, oddCount};\n}\n\n// Example usage\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n// Function to calculate the sum of digits of a number\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = abs(num); // Work with the absolute value for digit extraction\n\n    // Extract digits and calculate the sum\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n\n    // If the number was negative, subtract twice the first digit\n    if (is_negative) {\n        // Get the first digit\n        int first_digit = abs(num);\n        while (first_digit >= 10) {\n            first_digit /= 10;\n        }\n        sum -= 2 * first_digit; // Adjust for the signed first digit\n    }\n\n    return sum;\n}\n\n// Function to count numbers with a sum of digits > 0\nint count_nums(vector<int> n) {\n    int count = 0;\n\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n// Example usage\n"}
{"task_id": "CPP/109", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true; // An empty vector is considered sorted.\n\n    int dropCount = 0;\n    int n = arr.size();\n\n    // Loop through the array to count the number of drops\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            dropCount++;\n            // If we find more than one drop, return false\n            if (dropCount > 1) {\n                return false;\n            }\n        }\n    }\n\n    return true; // If we have 0 or 1 drop, it's possible to sort by right shifts\n}\n\n// Example usage\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount = 0;\n    int evenCountInLst2 = 0;\n\n    // Count odd numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount++;\n        }\n    }\n\n    // Count even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCountInLst2++;\n        }\n    }\n\n    // Check if we can replace all odd numbers in lst1 with even numbers from lst2\n    if (evenCountInLst2 >= oddCount) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nmap<string, int> histogram(string test) {\n    map<char, int> countMap;\n    map<string, int> result;\n\n    // Use a stringstream to split the input string by spaces\n    stringstream ss(test);\n    string word;\n\n    // Count occurrences of each character\n    while (ss >> word) {\n        for (char c : word) {\n            countMap[c]++;\n        }\n    }\n\n    // Find the maximum count\n    int maxCount = 0;\n    for (const auto& pair : countMap) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Collect all characters with the maximum count\n    for (const auto& pair : countMap) {\n        if (pair.second == maxCount) {\n            result[string(1, pair.first)] = pair.second;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_set>\n\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Use a set for faster lookup of characters to delete\n    unordered_set<char> charsToDelete(c.begin(), c.end());\n    string result;\n\n    // Build the result string by skipping characters in charsToDelete\n    for (char ch : s) {\n        if (charsToDelete.find(ch) == charsToDelete.end()) {\n            result += ch;\n        }\n    }\n\n    // Check if the result string is a palindrome\n    string reversedResult = result;\n    reverse(reversedResult.begin(), reversedResult.end());\n    bool isPalindrome = (result == reversedResult);\n\n    // Prepare the output\n    vector<string> output;\n    output.push_back(result);\n    output.push_back(isPalindrome ? \"True\" : \"False\");\n\n    return output;\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        string str = lst[i];\n        int odd_count = 0;\n\n        // Count the number of odd digits in the string\n        for (char ch : str) {\n            if ((ch - '0') % 2 != 0) { // Check if the digit is odd\n                odd_count++;\n            }\n        }\n\n        // Create the output string with the counted odd digits\n        string output = \"the number of odd elements \" + to_string(odd_count) +\n                        \"n the str\" + to_string(odd_count) +\n                        \"ng \" + to_string(i + 1) + \" of the \" +\n                        to_string(odd_count) + \"nput.\";\n        \n        result.push_back(output);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\n#include <limits.h> // For INT_MAX\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long currentSum = 0;\n    long long minSum = LLONG_MAX; // Initialize to the maximum possible value\n\n    for (long long num : nums) {\n        currentSum += num; // Add the current number to the current sum\n        if (currentSum < minSum) {\n            minSum = currentSum; // Update minSum if currentSum is smaller\n        }\n        if (currentSum > 0) {\n            currentSum = 0; // Reset currentSum if it becomes positive\n        }\n    }\n\n    return minSum; // Return the minimum sum found\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_times = 0;\n\n    // Iterate through each well (row in the grid)\n    for (const auto& well : grid) {\n        int units_of_water = 0;\n\n        // Count the number of water units (1s) in the current well\n        for (int water : well) {\n            if (water == 1) {\n                units_of_water++;\n            }\n        }\n\n        // Calculate the number of times we need to lower the bucket for this well\n        if (units_of_water > 0) {\n            total_times += (units_of_water + capacity - 1) / capacity; // This is equivalent to ceil(units_of_water / capacity)\n        }\n    }\n\n    return total_times;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count the number of 1s in the binary representation of an integer\nint countOnes(int n) {\n    int count = 0;\n    while (n) {\n        count += n & 1; // Increment count if the last bit is 1\n        n >>= 1;        // Right shift to check the next bit\n    }\n    return count;\n}\n\n// Comparator function for sorting\nbool customComparator(int a, int b) {\n    int onesA = countOnes(a);\n    int onesB = countOnes(b);\n    \n    // First compare by number of ones\n    if (onesA != onesB) {\n        return onesA < onesB; // Sort by number of ones\n    }\n    // If the number of ones is the same, sort by the value itself\n    return a < b; // Sort by value\n}\n\n// Main sorting function\nvector<int> sort_array(vector<int> arr) {\n    sort(arr.begin(), arr.end(), customComparator);\n    return arr;\n}\n\n// Example usage\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nbool is_consonant(char c) {\n    c = tolower(c); // Convert to lowercase for uniformity\n    return isalpha(c) && !strchr(\"aeiou\", c); // Check if it's a letter and not a vowel\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    // Split the string into words\n    while (ss >> word) {\n        int consonant_count = 0;\n\n        // Count consonants in the word\n        for (char c : word) {\n            if (is_consonant(c)) {\n                consonant_count++;\n            }\n        }\n\n        // If the number of consonants matches n, add the word to the result\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    // Define the vowels\n    string vowels = \"aeiouAEIOU\";\n    int n = word.length();\n    \n    // We need to find a vowel between two consonants\n    char lastConsonant = '\\0';\n    char foundVowel = '\\0';\n    \n    // Iterate from the end of the string\n    for (int i = n - 1; i >= 0; --i) {\n        char currentChar = word[i];\n        \n        // Check if the current character is a consonant\n        if (isalpha(currentChar) && vowels.find(currentChar) == string::npos) {\n            // If we have found a consonant after a vowel\n            if (lastConsonant != '\\0' && foundVowel != '\\0') {\n                return string(1, foundVowel); // Return the found vowel\n            }\n            // Update the last consonant\n            lastConsonant = currentChar;\n        } \n        // Check if the current character is a vowel\n        else if (vowels.find(currentChar) != string::npos) {\n            // If we have found a vowel, store it\n            foundVowel = currentChar;\n        }\n    }\n    \n    // If no valid vowel was found between consonants, return empty string\n    return \"\";\n}\n\n// Example usage\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0];\n    string s2 = lst[1];\n\n    // Count parentheses for s1\n    int open1 = 0, close1 = 0;\n    for (char c : s1) {\n        if (c == '(') open1++;\n        else close1++;\n    }\n\n    // Count parentheses for s2\n    int open2 = 0, close2 = 0;\n    for (char c : s2) {\n        if (c == '(') open2++;\n        else close2++;\n    }\n\n    // Check if s1 + s2 can be balanced\n    if (open1 >= close2 && open2 >= close1) {\n        return \"Yes\";\n    }\n\n    return \"No\";\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Step 2: Select the first k elements\n    vector<int> max_k_elements(arr.begin(), arr.begin() + k);\n    \n    // Step 3: Sort the selected k elements in ascending order\n    sort(max_k_elements.begin(), max_k_elements.end());\n    \n    return max_k_elements;\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (size_t i = 0; i < lst.size(); i++) {\n        // Check if the index is even and the element is odd\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i]; // Add the element to sum\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0; // Initialize sum to 0\n    // Iterate through the first k elements\n    for (int i = 0; i < k; i++) {\n        // Check if the element has at most two digits\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i]; // Add to sum if condition is met\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers; // Vector to store odd numbers in the Collatz sequence\n\n    // Generate the Collatz sequence\n    while (n != 1) {\n        // If the number is odd, add it to the vector\n        if (n % 2 != 0) {\n            odd_numbers.push_back(n);\n        }\n        // Apply the Collatz rules\n        if (n % 2 == 0) {\n            n = n / 2; // If even, divide by 2\n        } else {\n            n = 3 * n + 1; // If odd, multiply by 3 and add 1\n        }\n    }\n    \n    // Add 1 to the list since the sequence always ends with 1\n    odd_numbers.push_back(1);\n\n    // Sort the vector in increasing order\n    sort(odd_numbers.begin(), odd_numbers.end());\n\n    return odd_numbers; // Return the sorted vector of odd numbers\n}\n\n// Example usage\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) {\n        return false;\n    }\n\n    // Check if the date format is correct (mm-dd-yyyy)\n    if (date.size() != 10 || date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n\n    // Extract month, day, and year from the date string\n    int month, day, year;\n    stringstream ss(date);\n    string monthStr, dayStr, yearStr;\n\n    getline(ss, monthStr, '-');\n    getline(ss, dayStr, '-');\n    getline(ss, yearStr);\n\n    // Convert strings to integers\n    month = stoi(monthStr);\n    day = stoi(dayStr);\n    year = stoi(yearStr);\n\n    // Check if month is valid\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    // Check if day is valid based on the month\n    if (day < 1) {\n        return false;\n    }\n\n    if (month == 2) {\n        // February: check for leap year\n        if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n            // Leap year\n            if (day > 29) {\n                return false;\n            }\n        } else {\n            // Not a leap year\n            if (day > 28) {\n                return false;\n            }\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        // Months with 30 days\n        if (day > 30) {\n            return false;\n        }\n    } else {\n        // Months with 31 days\n        if (day > 31) {\n            return false;\n        }\n    }\n\n    // If all checks passed, the date is valid\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    // Check for whitespace\n    if (txt.find(' ') != string::npos) {\n        // Split by whitespace\n        stringstream ss(txt);\n        string word;\n        while (ss >> word) {\n            result.push_back(word);\n        }\n    } \n    // Check for commas\n    else if (txt.find(',') != string::npos) {\n        // Split by commas\n        stringstream ss(txt);\n        string word;\n        while (getline(ss, word, ',')) {\n            result.push_back(word);\n        }\n    } \n    // If neither whitespace nor commas exist\n    else {\n        int count = 0;\n        for (char c : txt) {\n            if (islower(c)) {\n                int position = c - 'a'; // Get the position of the letter in the alphabet\n                if (position % 2 == 1) { // Check if the position is odd\n                    count++;\n                }\n            }\n        }\n        result.push_back(to_string(count)); // Convert count to string and add to result\n    }\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    if (lst.empty() || lst.size() == 1) {\n        return true; // An empty vector or a single element vector is sorted\n    }\n\n    unordered_map<int, int> count_map; // To count occurrences of each number\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check for sorted order\n        if (i > 0 && lst[i] < lst[i - 1]) {\n            return false; // Not sorted\n        }\n\n        // Count occurrences\n        count_map[lst[i]]++;\n        if (count_map[lst[i]] > 2) {\n            return false; // More than two occurrences\n        }\n    }\n\n    return true; // If we pass both checks, the vector is sorted and valid\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to find the intersection of two intervals and check if its length is prime\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n\n    // Calculate the intersection\n    int start_of_intersection = max(start1, start2);\n    int end_of_intersection = min(end1, end2);\n\n    // Calculate the length of the intersection\n    int length = end_of_intersection - start_of_intersection;\n\n    // If there is no intersection\n    if (length <= 0) {\n        return \"NO\";\n    }\n\n    // Check if the length is a prime number\n    if (isPrime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/128", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768; // Return -32768 for empty array\n    }\n\n    int sum_of_magnitudes = 0;\n    int product_of_signs = 1; // Start with 1 for multiplication\n\n    for (int num : arr) {\n        if (num > 0) {\n            sum_of_magnitudes += num; // Add positive number to sum\n        } else if (num < 0) {\n            sum_of_magnitudes += -num; // Add magnitude of negative number to sum\n            product_of_signs *= -1; // Flip the sign\n        } else {\n            product_of_signs = 0; // If we encounter zero, product becomes zero\n            break; // No need to continue\n        }\n    }\n\n    return sum_of_magnitudes * product_of_signs; // Return the final result\n}\n\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nvector<int> bestPath;\nvector<int> currentPath;\nint N;\n\nvoid dfs(vector<vector<int>>& grid, int x, int y, int k) {\n    // If the current path length is equal to k, check if it's the best path\n    if (currentPath.size() == k) {\n        if (bestPath.empty() || currentPath < bestPath) {\n            bestPath = currentPath; // Update the best path\n        }\n        return;\n    }\n\n    // Directions for moving up, down, left, right\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    // Explore all possible directions\n    for (auto& dir : directions) {\n        int newX = x + dir.first;\n        int newY = y + dir.second;\n\n        // Check if the new position is within bounds\n        if (newX >= 0 && newX < N && newY >= 0 && newY < N) {\n            currentPath.push_back(grid[newX][newY]); // Add the new cell to the path\n            dfs(grid, newX, newY, k); // Recur for the new cell\n            currentPath.pop_back(); // Backtrack\n        }\n    }\n}\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    N = grid.size();\n    bestPath.clear();\n    currentPath.clear();\n\n    // Start DFS from every cell in the grid\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            currentPath.push_back(grid[i][j]); // Start path with the current cell\n            dfs(grid, i, j, k); // Start DFS\n            currentPath.pop_back(); // Backtrack\n        }\n    }\n\n    return bestPath; // Return the best path found\n}\n\n// Example usage\n"}
{"task_id": "CPP/130", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> result(n + 1); // Create a vector to hold the results\n\n    // Base case\n    if (n >= 0) result[0] = 3; // tri(1) = 3\n    if (n >= 1) result[1] = 1 + 1 / 2; // tri(2) = 1 + (2 / 2) = 2\n    if (n >= 2) result[2] = 2; // tri(2) = 2\n\n    // Calculate the rest of the sequence\n    for (int i = 3; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result[i] = 1 + i / 2; // If n is even\n        } else {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1]; // If n is odd\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <stdio.h>\n\nint digits(int n) {\n    int product = 1;\n    bool foundOdd = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply to the product\n            foundOdd = true; // Mark that we found an odd digit\n        }\n        n /= 10; // Remove the last digit\n    }\n\n    return foundOdd ? product : 0; // Return product if odd digits found, otherwise return 0\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\nbool is_nested(string str) {\n    stack<char> s;\n    bool hasNested = false;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            s.push(ch);\n        } else if (ch == ']') {\n            if (s.empty()) {\n                // Unmatched closing bracket\n                return false;\n            }\n            s.pop();\n            // Check if we just closed a nested bracket\n            if (!s.empty()) {\n                hasNested = true; // We have at least one nested bracket\n            }\n        }\n    }\n\n    // We need to have at least one nested bracket and all brackets must be matched\n    return hasNested && s.empty();\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int rounded = ceil(num); // Round up to the nearest integer\n        sum += rounded * rounded; // Add the square of the rounded number to the sum\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha\n\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Trim trailing spaces\n    size_t end = txt.find_last_not_of(' ');\n    if (end == string::npos) {\n        return false; // The string is empty or contains only spaces\n    }\n\n    // Get the last character\n    char lastChar = txt[end];\n\n    // Check if the last character is an alphabetical character\n    if (isalpha(lastChar)) {\n        // Check if it is not part of a word\n        if (end == 0 || txt[end - 1] == ' ') {\n            return true; // Last character is a letter and not part of a word\n        }\n    }\n\n    return false; // Last character is not a letter or is part of a word\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int n = arr.size();\n    \n    // Iterate from the second last element to the first element\n    for (int i = n - 2; i >= 0; --i) {\n        // Check if the current element is less than the next element\n        if (arr[i] < arr[i + 1]) {\n            return i + 1; // Return the index of the next element\n        }\n    }\n    \n    // If no such element exists, return -1\n    return -1;\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = numeric_limits<int>::min(); // Initialize to the smallest possible integer\n    int smallest_positive = numeric_limits<int>::max(); // Initialize to the largest possible integer\n\n    bool found_negative = false;\n    bool found_positive = false;\n\n    for (int num : lst) {\n        if (num < 0) {\n            found_negative = true;\n            if (num > largest_negative) {\n                largest_negative = num; // Update largest negative\n            }\n        } else if (num > 0) {\n            found_positive = true;\n            if (num < smallest_positive) {\n                smallest_positive = num; // Update smallest positive\n            }\n        }\n    }\n\n    // If no negative was found, set to 0\n    if (!found_negative) {\n        largest_negative = 0;\n    }\n    \n    // If no positive was found, set to 0\n    if (!found_positive) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n\n// Example usage\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n#include <sstream>\n#include <locale>\n\nusing namespace std;\n\ndouble convert_to_double(const string& str) {\n    // Replace ',' with '.' for proper conversion\n    string modified_str = str;\n    replace(modified_str.begin(), modified_str.end(), ',', '.');\n    return stod(modified_str);\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Check if both are of the same type\n    if (a.type() == b.type()) {\n        if (a.type() == typeid(int)) {\n            int int_a = boost::any_cast<int>(a);\n            int int_b = boost::any_cast<int>(b);\n            if (int_a == int_b) return \"None\";\n            return (int_a > int_b) ? a : b;\n        } else if (a.type() == typeid(double)) {\n            double double_a = boost::any_cast<double>(a);\n            double double_b = boost::any_cast<double>(b);\n            if (double_a == double_b) return \"None\";\n            return (double_a > double_b) ? a : b;\n        } else if (a.type() == typeid(string)) {\n            string str_a = boost::any_cast<string>(a);\n            string str_b = boost::any_cast<string>(b);\n            double double_a = convert_to_double(str_a);\n            double double_b = convert_to_double(str_b);\n            if (double_a == double_b) return \"None\";\n            return (double_a > double_b) ? a : b;\n        }\n    } else {\n        // Handle cases where types are different\n        double double_a, double_b;\n\n        if (a.type() == typeid(int)) {\n            double_a = boost::any_cast<int>(a);\n            if (b.type() == typeid(double)) {\n                double_b = boost::any_cast<double>(b);\n            } else if (b.type() == typeid(string)) {\n                double_b = convert_to_double(boost::any_cast<string>(b));\n            }\n        } else if (a.type() == typeid(double)) {\n            double_a = boost::any_cast<double>(a);\n            if (b.type() == typeid(int)) {\n                double_b = boost::any_cast<int>(b);\n            } else if (b.type() == typeid(string)) {\n                double_b = convert_to_double(boost::any_cast<string>(b));\n            }\n        } else if (a.type() == typeid(string)) {\n            double_a = convert_to_double(boost::any_cast<string>(a));\n            if (b.type() == typeid(int)) {\n                double_b = boost::any_cast<int>(b);\n            } else if (b.type() == typeid(double)) {\n                double_b = boost::any_cast<double>(b);\n            }\n        }\n\n        if (double_a == double_b) return \"None\";\n        return (double_a > double_b) ? a : b;\n    }\n\n    return \"None\"; // Fallback in case of unexpected types\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is less than 8\n    if (n < 8) {\n        return false;\n    }\n    // Check if n is even\n    if (n % 2 == 0) {\n        return true;\n    }\n    // If n is odd\n    return false;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate factorial of a number\nlong long factorial(int num) {\n    long long result = 1;\n    for (int i = 1; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to calculate the Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1; // Initialize result to 1\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i); // Multiply by the factorial of i\n    }\n    return result; // Return the final result\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int space_count = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n        } else {\n            if (space_count > 2) {\n                result += '-'; // Replace consecutive spaces with a single '-'\n            } else if (space_count > 0) {\n                result += string(space_count, '_'); // Replace spaces with '_'\n            }\n            result += c; // Add the current character\n            space_count = 0; // Reset space count\n        }\n    }\n\n    // Handle trailing spaces\n    if (space_count > 2) {\n        result += '-';\n    } else if (space_count > 0) {\n        result += string(space_count, '_');\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check for exactly one dot\n    size_t dot_pos = file_name.find('.');\n    if (dot_pos == string::npos || file_name.find('.', dot_pos + 1) != string::npos) {\n        return \"No\";\n    }\n\n    // Split the file name into name and extension\n    string name_part = file_name.substr(0, dot_pos);\n    string ext_part = file_name.substr(dot_pos + 1);\n\n    // Check if the name part is empty and starts with a letter\n    if (name_part.empty() || !isalpha(name_part[0])) {\n        return \"No\";\n    }\n\n    // Check for the valid extensions\n    if (ext_part != \"txt\" && ext_part != \"exe\" && ext_part != \"dll\") {\n        return \"No\";\n    }\n\n    // Count the number of digits in the file name\n    int digit_count = 0;\n    for (char c : file_name) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n    }\n\n    // Check if there are more than three digits\n    if (digit_count > 3) {\n        return \"No\";\n    }\n\n    // If all checks passed, return \"Yes\"\n    return \"Yes\";\n}\n\n// Example usage\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int total_sum = 0; // Initialize the sum to 0\n\n    // Iterate through the vector\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if the index is a multiple of 3\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i]; // Square the element\n        }\n        // Check if the index is a multiple of 4 and not a multiple of 3\n        else if (i % 4 == 0) {\n            lst[i] = lst[i] * lst[i] * lst[i]; // Cube the element\n        }\n        // Add the modified element to the total sum\n        total_sum += lst[i];\n    }\n\n    return total_sum; // Return the total sum\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it is prime\n}\n\n// Function to extract words with prime lengths from a sentence\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    vector<string> prime_length_words;\n\n    // Split the sentence into words\n    while (ss >> word) {\n        // Check if the length of the word is prime\n        if (is_prime(word.length())) {\n            prime_length_words.push_back(word);\n        }\n    }\n\n    // Join the words with prime lengths into a single string\n    string result;\n    for (const string& w : prime_length_words) {\n        if (!result.empty()) {\n            result += \" \"; // Add space before the next word\n        }\n        result += w;\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Split the first fraction\n    size_t pos = x.find('/');\n    int numerator_x = stoi(x.substr(0, pos));\n    int denominator_x = stoi(x.substr(pos + 1));\n\n    // Split the second fraction\n    pos = n.find('/');\n    int numerator_n = stoi(n.substr(0, pos));\n    int denominator_n = stoi(n.substr(pos + 1));\n\n    // Calculate the product of the fractions\n    int product_numerator = numerator_x * numerator_n;\n    int product_denominator = denominator_x * denominator_n;\n\n    // Check if the product is a whole number\n    return (product_numerator % product_denominator == 0);\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n// Helper function to calculate the sum of digits\nint digit_sum(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = abs(num); // Work with the absolute value\n\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n\n    // If the number was negative, we treat the first digit as negative\n    if (is_negative) {\n        sum = -sum; // This is a bit unconventional, but we follow the problem statement\n    }\n\n    return sum;\n}\n\n// Main function to order by points\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of pairs to hold the original index and the number\n    vector<pair<int, int>> indexed_nums;\n    for (int i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({i, nums[i]});\n    }\n\n    // Sort the vector based on the sum of digits and original index\n    sort(indexed_nums.begin(), indexed_nums.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        int sum_a = digit_sum(a.second);\n        int sum_b = digit_sum(b.second);\n        if (sum_a == sum_b) {\n            return a.first < b.first; // Maintain original order if sums are equal\n        }\n        return sum_a < sum_b; // Sort by digit sum\n    });\n\n    // Extract the sorted numbers into a result vector\n    vector<int> result;\n    for (const auto& p : indexed_nums) {\n        result.push_back(p.second);\n    }\n\n    return result;\n}\n\n// Test the function\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n\n    for (int num : nums) {\n        // Check if the number is greater than 10\n        if (num > 10) {\n            // Get the absolute value of the number to handle negative numbers\n            int absNum = abs(num);\n            int firstDigit, lastDigit;\n\n            // Get the last digit\n            lastDigit = absNum % 10;\n\n            // Get the first digit\n            while (absNum >= 10) {\n                absNum /= 10;\n            }\n            firstDigit = absNum;\n\n            // Check if both first and last digits are odd\n            if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1; // a[i] = i^2 - i + 1\n    }\n\n    // Count occurrences of each remainder when divided by 3\n    int count[3] = {0, 0, 0};\n    for (int i = 0; i < n; ++i) {\n        count[a[i] % 3]++;\n    }\n\n    // Calculate the number of valid triples\n    int total_triples = 0;\n\n    // Count triples of the same category\n    for (int i = 0; i < 3; ++i) {\n        if (count[i] >= 3) {\n            total_triples += (count[i] * (count[i] - 1) * (count[i] - 2)) / 6; // nC3\n        }\n    }\n\n    // Count triples with one from each category\n    total_triples += count[0] * count[1] * count[2];\n\n    return total_triples;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // List of planets in order from the Sun\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Find the indices of planet1 and planet2\n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n    \n    // Check if both planets are valid\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {}; // Return empty vector if either planet is invalid\n    }\n    \n    // Get the indices of the planets\n    int index1 = distance(planets.begin(), it1);\n    int index2 = distance(planets.begin(), it2);\n    \n    // Ensure index1 is less than index2\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Create a vector to hold the planets between planet1 and planet2\n    vector<string> result;\n    \n    // Collect planets between the two indices\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> vector_sort(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0; // Keep only even length strings\n    }), lst.end());\n\n    // Sort the remaining strings by length and then alphabetically\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Sort alphabetically if lengths are equal\n        }\n        return a.length() < b.length(); // Sort by length\n    });\n\n    return lst;\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it is prime\n}\n\n// Function to return x if n is prime, otherwise return y\nint x_or_y(int n, int x, int y) {\n    if (isPrime(n)) {\n        return x; // n is prime\n    } else {\n        return y; // n is not prime\n    }\n}\n\n// Main function to test the implementation\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0; // Initialize sum to 0\n\n    for (float num : lst) {\n        // Check if the number is a non-negative integer\n        if (num >= 0 && floor(num) == num) {\n            int intNum = static_cast<int>(num); // Convert to integer\n            // Check if the number is odd\n            if (intNum % 2 != 0) {\n                sum += intNum * intNum; // Add the square of the odd number to the sum\n            }\n        }\n    }\n\n    return sum; // Return the total sum\n}\n\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // For std::abs\n\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result; // Vector to store the result\n    int n = game.size(); // Get the size of the vectors\n\n    // Iterate through each match\n    for (int i = 0; i < n; i++) {\n        // Calculate the absolute difference and push to result\n        result.push_back(abs(game[i] - guess[i]));\n    }\n\n    return result; // Return the result vector\n}\n\n// Example usage\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN; // Initialize to the smallest possible integer\n    string strongest_extension = \"\";\n\n    for (const string& ext : extensions) {\n        int CAP = 0;\n        int SM = 0;\n\n        // Calculate CAP and SM\n        for (char c : ext) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n\n        // Calculate strength\n        int strength = CAP - SM;\n\n        // Update strongest extension if this one is stronger\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    // Return the result in the required format\n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Check if b is empty or longer than a\n    if (b.empty() || b.length() > a.length()) {\n        return false;\n    }\n\n    // Concatenate b with itself to get all rotations\n    string b_rotated = b + b;\n\n    // Check if a contains any substring of b_rotated of length equal to b\n    return b_rotated.find(a) != string::npos;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for abs function\n\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Initialize counts for even and odd digits\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Work with the absolute value of the number\n    num = abs(num);\n\n    // Check if the number is zero\n    if (num == 0) {\n        even_count = 1; // 0 is considered an even digit\n    } else {\n        // Loop through each digit\n        while (num > 0) {\n            int digit = num % 10; // Get the last digit\n            if (digit % 2 == 0) {\n                even_count++; // Increment even count\n            } else {\n                odd_count++; // Increment odd count\n            }\n            num /= 10; // Remove the last digit\n        }\n    }\n\n    // Return the counts as a vector\n    return {even_count, odd_count};\n}\n\n// Example usage\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the values and their corresponding Roman numeral symbols\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string result = \"\";\n    \n    // Iterate over the defined Roman numeral values\n    for (const auto& pair : roman_numerals) {\n        while (number >= pair.first) {\n            result += pair.second; // Append the Roman numeral symbol\n            number -= pair.first;  // Decrease the number\n        }\n    }\n    \n    return result; // Return the final Roman numeral string\n}\n\n// Example usage\n"}
{"task_id": "CPP/157", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to identify the longest side\n    float x = max(a, max(b, c)); // longest side\n    float y, z;\n\n    // Assign the other two sides\n    if (x == a) {\n        y = b;\n        z = c;\n    } else if (x == b) {\n        y = a;\n        z = c;\n    } else {\n        y = a;\n        z = b;\n    }\n\n    // Check if it satisfies the Pythagorean theorem\n    return (fabs(y * y + z * z - x * x) < 1e-6); // Using a small epsilon for floating-point comparison\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string max_word;\n    int max_unique_count = 0;\n\n    for (const string& word : words) {\n        // Use a set to count unique characters\n        unordered_set<char> unique_chars(word.begin(), word.end());\n        int unique_count = unique_chars.size();\n\n        // Check if we found a new maximum or if we need to update lexicographically\n        if (unique_count > max_unique_count || \n            (unique_count == max_unique_count && (max_word.empty() || word < max_word))) {\n            max_unique_count = unique_count;\n            max_word = word;\n        }\n    }\n\n    return max_word;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate total carrots needed to eat\n    int totalEaten = number + need;\n    \n    // Check if there are enough remaining carrots\n    if (remaining >= need) {\n        // If enough, eat the needed amount\n        remaining -= need;\n    } else {\n        // If not enough, eat all remaining carrots\n        totalEaten += remaining; // Add remaining to total eaten\n        remaining = 0; // All remaining carrots are eaten\n    }\n    \n    // Return the result as a vector\n    return {totalEaten, remaining};\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stdexcept>\n\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    if (operato.size() != operand.size() - 1) {\n        throw invalid_argument(\"The length of operator vector must be one less than the operand vector.\");\n    }\n\n    // Start with the first operand\n    int result = operand[0];\n\n    // Iterate through the operators and operands\n    for (size_t i = 0; i < operato.size(); ++i) {\n        string op = operato[i];\n        int next_operand = operand[i + 1];\n\n        if (op == \"+\") {\n            result += next_operand;\n        } else if (op == \"-\") {\n            result -= next_operand;\n        } else if (op == \"*\") {\n            result *= next_operand;\n        } else if (op == \"//\") {\n            if (next_operand == 0) {\n                throw invalid_argument(\"Division by zero is not allowed.\");\n            }\n            result /= next_operand; // Floor division in C++ is done using /\n        } else if (op == \"**\") {\n            result = static_cast<int>(pow(result, next_operand)); // Exponentiation\n        } else {\n            throw invalid_argument(\"Invalid operator: \" + op);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha, tolower, toupper\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetter = false;\n\n    // First, check if there are any letters in the string\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    if (hasLetter) {\n        // If there are letters, reverse their case\n        for (char &c : s) {\n            if (isalpha(c)) {\n                if (islower(c)) {\n                    c = toupper(c);\n                } else {\n                    c = tolower(c);\n                }\n            }\n        }\n    } else {\n        // If there are no letters, reverse the entire string\n        reverse(s.begin(), s.end());\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n#include <iomanip>\n#include <sstream>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\"; // Return an empty string for the empty input\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    // Convert the unsigned char array to a hex string\n    stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        ss << hex << setw(2) << setfill('0') << (int)digest[i];\n    }\n\n    return ss.str();\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    set<int> even_digits; // Using a set to avoid duplicates and maintain order\n    // Determine the start and end of the range\n    int start = min(a, b);\n    int end = max(a, b);\n    \n    // Loop through the range\n    for (int i = start; i <= end; ++i) {\n        // Check if the number is a single digit and even\n        if (i >= 2 && i <= 8 && i % 2 == 0) {\n            even_digits.insert(i); // Insert into the set\n        }\n    }\n    \n    // Convert the set to a vector for the return type\n    vector<int> result(even_digits.begin(), even_digits.end());\n    return result;\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector\n    sort(numbers.begin(), numbers.end());\n    \n    // Check adjacent elements for closeness\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (fabs(numbers[i + 1] - numbers[i]) < threshold) {\n            return true; // Found two elements that are too close\n        }\n    }\n    \n    return false; // No elements found that are too close\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype> // for isspace\n\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        // Ignore spaces\n        if (isspace(ch)) {\n            continue;\n        }\n\n        // Add the character to the current group\n        current_group += ch;\n\n        // Update balance\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n        }\n\n        // If balance is zero, we have a complete group\n        if (balance == 0 && !current_group.empty()) {\n            result.push_back(current_group);\n            current_group.clear(); // Reset for the next group\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    // Get the integer part of the number\n    float integer_part = floor(number);\n    // Calculate the decimal part\n    float decimal_part = number - integer_part;\n    return decimal_part;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a balance of zero\n\n    for (int operation : operations) {\n        balance += operation; // Update the balance with the current operation\n        if (balance < 0) { // Check if the balance goes below zero\n            return true; // Return true if it does\n        }\n    }\n    \n    return false; // Return false if balance never goes below zero\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for fabs\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Step 1: Calculate the mean\n    float sum = 0.0;\n    int n = numbers.size();\n    \n    for (float num : numbers) {\n        sum += num;\n    }\n    \n    float mean = sum / n;\n\n    // Step 2: Calculate the absolute differences and their sum\n    float mad_sum = 0.0;\n    \n    for (float num : numbers) {\n        mad_sum += fabs(num - mean); // fabs for absolute value\n    }\n\n    // Step 3: Calculate the Mean Absolute Deviation\n    float mad = mad_sum / n;\n    \n    return mad;\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimiter) {\n    vector<int> result;\n\n    // Check if the input vector is empty\n    if (numbers.empty()) {\n        return result; // Return an empty vector\n    }\n\n    // Iterate through the input vector\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]); // Add the current element to the result\n\n        // If it's not the last element, add the delimiter\n        if (i < numbers.size() - 1) {\n            result.push_back(delimiter);\n        }\n    }\n\n    return result; // Return the new vector with delimiters\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths; // Vector to store the maximum depths for each group\n    stringstream ss(paren_string); // Use stringstream to split the string\n    string group;\n\n    // Iterate through each group separated by spaces\n    while (ss >> group) {\n        int current_depth = 0; // Current depth of nesting\n        int max_depth = 0; // Maximum depth for the current group\n\n        // Iterate through each character in the group\n        for (char ch : group) {\n            if (ch == '(') {\n                current_depth++; // Increase depth for opening parenthesis\n                if (current_depth > max_depth) {\n                    max_depth = current_depth; // Update max depth if current is greater\n                }\n            } else if (ch == ')') {\n                current_depth--; // Decrease depth for closing parenthesis\n            }\n        }\n\n        depths.push_back(max_depth); // Store the maximum depth for the current group\n    }\n\n    return depths; // Return the vector of maximum depths\n}\n\n// Example usage\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_substring(const vector<string>& strings, const string& substring) {\n    vector<string> filtered_strings;\n\n    for (const auto& str : strings) {\n        if (str.find(substring) != string::npos) { // Check if substring is found in str\n            filtered_strings.push_back(str); // Add to the result if found\n        }\n    }\n\n    return filtered_strings; // Return the filtered vector\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Check if the vector is empty\n    if (numbers.empty()) {\n        return {sum, product}; // Return (0, 1)\n    }\n\n    // Calculate sum and product\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return {sum, product}; // Return the result as a vector\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(const vector<int>& numbers) {\n    vector<int> result; // Vector to store the rolling maximums\n    int current_max = INT_MIN; // Initialize current_max to the smallest integer\n\n    for (int num : numbers) {\n        // Update current_max if the current number is greater\n        if (num > current_max) {\n            current_max = num;\n        }\n        // Add the current maximum to the result vector\n        result.push_back(current_max);\n    }\n\n    return result; // Return the result vector\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(const string& str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    int n = str.length();\n    \n    // Find the longest palindromic suffix\n    for (int i = n; i >= 0; --i) {\n        if (is_palindrome(str.substr(i))) {\n            // If str[i:] is a palindrome, we need to append the reverse of str[0:i] to str\n            string prefix = str.substr(0, i);\n            string reverse_prefix(prefix.rbegin(), prefix.rend());\n            return str + reverse_prefix;\n        }\n    }\n    \n    // If no palindromic suffix is found, return the original string + its reverse\n    return str + string(str.rbegin(), str.rend());\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of the same length\n    if (a.length() != b.length()) {\n        throw invalid_argument(\"Strings must be of the same length\");\n    }\n\n    string result = \"\";\n    for (size_t i = 0; i < a.length(); ++i) {\n        // Perform XOR operation\n        if (a[i] == b[i]) {\n            result += '0'; // Both bits are the same\n        } else {\n            result += '1'; // Bits are different\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <optional>\n\nusing namespace std;\n\n// Function declaration (forward declaration)\noptional<string> longest(const vector<string>& strings);\n\n// Function definition\noptional<string> longest(const vector<string>& strings) {\n    if (strings.empty()) {\n        return nullopt; // Return an empty optional if the input vector is empty\n    }\n\n    string longestString = strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str;\n        }\n    }\n    return longestString; // Return the longest string found\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure a and b are non-negative\n    a = abs(a);\n    b = abs(b);\n    \n    // Use the Euclidean algorithm to find the GCD\n    while (b != 0) {\n        int temp = b;\n        b = a % b; // Remainder of a divided by b\n        a = temp;  // Assign b to a\n    }\n    return a; // When b is 0, a contains the GCD\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes; // Vector to store the prefixes\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i)); // Add the prefix from start to the current index\n    }\n    return prefixes; // Return the vector of prefixes\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss; // Create a string stream to build the output string\n    for (int i = 0; i <= n; ++i) {\n        ss << i; // Add the current number to the stream\n        if (i < n) {\n            ss << \" \"; // Add a space if it's not the last number\n        }\n    }\n    return ss.str(); // Convert the string stream to a string and return it\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <unordered_set>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    unordered_set<char> distinct_chars; // Set to store distinct characters\n\n    // Convert each character to lowercase and insert into the set\n    for (char c : str) {\n        distinct_chars.insert(tolower(c)); // Use tolower to ignore case\n    }\n\n    // The size of the set is the number of distinct characters\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    stringstream ss(music_string);\n    string note;\n\n    while (ss >> note) {\n        if (note == \"o\") {\n            beats.push_back(4); // whole note\n        } else if (note == \"o|\") {\n            beats.push_back(2); // half note\n        } else if (note == \".|\") {\n            beats.push_back(1); // quarter note\n        }\n    }\n\n    return beats;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (substring.empty()) return 0; // If the substring is empty, return 0\n    int count = 0;\n    size_t pos = 0;\n\n    // Loop to find all occurrences of the substring\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++; // Increment the count for each found occurrence\n        pos++;   // Move to the next position to allow for overlapping matches\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Mapping from string to integer\n    map<string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Split the input string into words\n    stringstream ss(numbers);\n    string word;\n    vector<int> num_list;\n\n    while (ss >> word) {\n        // Convert each word to its corresponding integer value\n        if (num_map.find(word) != num_map.end()) {\n            num_list.push_back(num_map[word]);\n        }\n    }\n\n    // Sort the list of numbers\n    sort(num_list.begin(), num_list.end());\n\n    // Convert sorted numbers back to strings\n    vector<string> sorted_words;\n    for (int num : num_list) {\n        for (const auto& pair : num_map) {\n            if (pair.second == num) {\n                sorted_words.push_back(pair.first);\n                break;\n            }\n        }\n    }\n\n    // Join the sorted words into a single string\n    string result;\n    for (size_t i = 0; i < sorted_words.size(); ++i) {\n        result += sorted_words[i];\n        if (i < sorted_words.size() - 1) {\n            result += \" \"; // Add space between words\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Step 1: Sort the vector\n    sort(numbers.begin(), numbers.end());\n\n    // Step 2: Initialize variables to track the closest pair\n    float min_diff = numeric_limits<float>::max(); // Start with the maximum possible float\n    vector<float> closest_pair;\n\n    // Step 3: Iterate through the sorted vector to find the closest pair\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i]; // Calculate the difference between adjacent elements\n        if (diff < min_diff) {\n            min_diff = diff; // Update the minimum difference\n            closest_pair = {numbers[i], numbers[i + 1]}; // Update the closest pair\n        }\n    }\n\n    return closest_pair; // Return the closest pair\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    // Check if the vector has at least two elements\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"The vector must contain at least two elements.\");\n    }\n\n    // Find the minimum and maximum values in the vector\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n\n    // Create a new vector to hold the rescaled values\n    vector<float> rescaled;\n\n    // Apply the linear transformation\n    for (float num : numbers) {\n        float rescaled_value = (num - min_val) / (max_val - min_val);\n        rescaled.push_back(rescaled_value);\n    }\n\n    return rescaled;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\n#include <typeinfo>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> result;\n\n    for (const auto& value : values) {\n        // Check if the value can be converted to an integer\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to return the length of the given string\nint strlen(const string& str) {\n    return str.size(); // or str.length();\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    // Start from n-1 and go downwards to find the largest divisor\n    for (int i = n - 1; i > 0; i--) {\n        if (n % i == 0) {\n            return i; // Return the first divisor found\n        }\n    }\n    return 1; // In case n is 1, the only divisor is 1\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i * i <= n; i += 2) {\n        // While i divides n, add i and divide n\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(const vector<int>& numbers) {\n    unordered_map<int, int> count_map;\n    \n    // Count occurrences of each number\n    for (int num : numbers) {\n        count_map[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Collect numbers that occur exactly once\n    for (int num : numbers) {\n        if (count_map[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for islower and isupper\n\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) { // Use a reference to modify the original string\n        if (islower(c)) {\n            c = toupper(c); // Convert to uppercase\n        } else if (isupper(c)) {\n            c = tolower(c); // Convert to lowercase\n        }\n    }\n    return str; // Return the modified string\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring concatenate(const vector<string>& strings) {\n    string result;\n    for (const string& str : strings) {\n        result += str; // Append each string to the result\n    }\n    return result; // Return the concatenated string\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_prefix(const vector<string>& strings, const string& prefix) {\n    vector<string> filtered_strings; // Vector to hold the filtered results\n\n    // Iterate through each string in the input vector\n    for (const string& str : strings) {\n        // Check if the string starts with the given prefix\n        if (str.rfind(prefix, 0) == 0) { // rfind returns the position of the first occurrence of prefix\n            filtered_strings.push_back(str); // Add to the result if it matches\n        }\n    }\n\n    return filtered_strings; // Return the filtered vector\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positive_numbers; // Vector to store positive numbers\n    for (float num : l) { // Iterate through each number in the input vector\n        if (num > 0) { // Check if the number is positive\n            positive_numbers.push_back(num); // Add to the positive numbers vector\n        }\n    }\n    return positive_numbers; // Return the vector of positive numbers\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Check if n is less than 2\n    if (n < 2) {\n        return false;\n    }\n    \n    // Check for factors from 2 to the square root of n\n    for (long long i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            return false; // n is divisible by i, so it's not prime\n        }\n    }\n    \n    return true; // n is prime\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <stdexcept>\n\nusing namespace std;\n\ndouble poly(const vector<double>& xs, double x) {\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble poly_derivative(const vector<double>& xs, double x) {\n    double sum = 0;\n    for (int i = 1; i < xs.size(); i++) {\n        sum += i * xs[i] * pow(x, i - 1);\n    }\n    return sum;\n}\n\ndouble find_zero(const vector<double>& xs) {\n    // Initial guess for the root\n    double x0 = 0.0;\n    double tolerance = 1e-7;\n    int max_iterations = 1000;\n    int iteration = 0;\n\n    while (iteration < max_iterations) {\n        double fx = poly(xs, x0);\n        double dfx = poly_derivative(xs, x0);\n\n        if (fabs(dfx) < tolerance) {\n            throw runtime_error(\"Derivative is too small; no convergence.\");\n        }\n\n        double x1 = x0 - fx / dfx; // Newton-Raphson update\n\n        if (fabs(x1 - x0) < tolerance) {\n            return x1; // Convergence\n        }\n\n        x0 = x1; // Update for next iteration\n        iteration++;\n    }\n\n    throw runtime_error(\"Maximum iterations reached; no convergence.\");\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Step 1: Extract values at indices divisible by 3\n    vector<int> to_sort;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            to_sort.push_back(l[i]);\n        }\n    }\n\n    // Step 2: Sort the extracted values\n    sort(to_sort.begin(), to_sort.end());\n\n    // Step 3: Replace the original values at indices divisible by 3 with sorted values\n    size_t j = 0; // Index for sorted values\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            l[i] = to_sort[j++];\n        }\n    }\n\n    return l;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Use a set to store unique elements\n    set<int> uniqueElements(l.begin(), l.end());\n    \n    // Convert the set back to a vector\n    vector<int> result(uniqueElements.begin(), uniqueElements.end());\n    \n    // Return the sorted unique elements\n    return result;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n#include <limits> // For std::numeric_limits\n\nusing namespace std;\n\nfloat max_element(const vector<float>& l) {\n    // Check if the vector is empty\n    if (l.empty()) {\n        // Handle the case of an empty vector (could return a specific value or throw an exception)\n        throw std::invalid_argument(\"Vector is empty\");\n    }\n\n    // Initialize max_value to the smallest possible float\n    float max_value = std::numeric_limits<float>::lowest();\n\n    // Iterate through the vector to find the maximum element\n    for (const float& num : l) {\n        if (num > max_value) {\n            max_value = num;\n        }\n    }\n\n    return max_value;\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint count_sevens(int number) {\n    int count = 0;\n    while (number > 0) {\n        if (number % 10 == 7) {\n            count++;\n        }\n        number /= 10;\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int total_count = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            total_count += count_sevens(i);\n        }\n    }\n    return total_count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Create a vector to hold the even indexed values\n    vector<float> even_values;\n\n    // Extract values at even indices\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n\n    // Sort the even indexed values\n    sort(even_values.begin(), even_values.end());\n\n    // Create a new vector to hold the result\n    vector<float> result = l;\n\n    // Replace the values at even indices with the sorted values\n    for (size_t i = 0; i < even_values.size(); ++i) {\n        result[i * 2] = even_values[i];\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.  \n    int l = s.length();\n    int num = (l + 2) / 3; // Calculate number of groups\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        // Cycle elements in each group. Unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0]; // Shift left\n        output += x; // Append to output\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    /*\n    Takes as input string encoded with encode_cyclic function. Returns decoded string. \n    */\n    int l = s.length();\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        // Reverse the cycling of elements in each group.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[x.length() - 1] + x.substr(0, 2); // Shift right\n        output += x; // Append to output\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to return the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    int count = 0; // Count of prime Fibonacci numbers found\n    int a = 0, b = 1; // Fibonacci initialization\n    int fib; // Variable to hold the current Fibonacci number\n\n    while (true) {\n        fib = a + b; // Generate the next Fibonacci number\n        a = b; // Update a to the next Fibonacci number\n        b = fib; // Update b to the next Fibonacci number\n\n        // Check if the Fibonacci number is prime\n        if (is_prime(fib)) {\n            count++; // Increment the count of prime Fibonacci numbers\n            if (count == n) {\n                return fib; // Return the n-th prime Fibonacci number\n            }\n        }\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    // Iterate through the array\n    for (int i = 0; i < n - 2; i++) {\n        // Skip duplicates for the first element\n        if (i > 0 && l[i] == l[i - 1]) {\n            continue;\n        }\n        \n        int left = i + 1;\n        int right = n - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            \n            if (sum == 0) {\n                return true; // Found a triplet\n            } else if (sum < 0) {\n                left++; // Move left pointer to the right to increase the sum\n            } else {\n                right--; // Move right pointer to the left to decrease the sum\n            }\n        }\n    }\n    \n    return false; // No triplet found\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Each car from the left will collide with each car from the right\n    return n * n; // Total collisions = n (left cars) * n (right cars)\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    // Create a new vector to store the incremented values\n    vector<int> incremented_list;\n    \n    // Iterate through each element in the input vector\n    for (int i = 0; i < l.size(); i++) {\n        // Increment the current element by 1 and add it to the new vector\n        incremented_list.push_back(l[i] + 1);\n    }\n    \n    // Return the new vector with incremented values\n    return incremented_list;\n}\n\n// Example usage\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen; // To store the numbers we have seen\n\n    for (int num : l) {\n        // Check if the negation of the current number exists in the set\n        if (seen.find(-num) != seen.end()) {\n            return true; // Found a pair that sums to zero\n        }\n        seen.insert(num); // Add the current number to the set\n    }\n\n    return false; // No pairs found that sum to zero\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (base < 2 || base >= 10) {\n        return \"\"; // Invalid base\n    }\n    \n    if (x == 0) {\n        return \"0\"; // Special case for zero\n    }\n\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base; // Get the remainder\n        result = to_string(remainder) + result; // Prepend the remainder to the result\n        x /= base; // Divide x by the base\n    }\n    \n    return result; // Return the final string representation\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h; // Calculate the area using the formula\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    // Base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    // Array to store the last four values\n    int fib[4] = {0, 0, 2, 0};\n\n    // Compute fib4(n) iteratively\n    for (int i = 4; i <= n; ++i) {\n        int next_fib = fib[0] + fib[1] + fib[2] + fib[3];\n        // Shift the values in the array\n        fib[0] = fib[1];\n        fib[1] = fib[2];\n        fib[2] = fib[3];\n        fib[3] = next_fib;\n    }\n\n    return fib[3]; // The n-th value is now in fib[3]\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Calculate the size of the vector\n    size_t size = l.size();\n    \n    // If the size is odd, return the middle element\n    if (size % 2 == 1) {\n        return l[size / 2];\n    } else {\n        // If the size is even, return the average of the two middle elements\n        return (l[size / 2 - 1] + l[size / 2]) / 2.0;\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Not a palindrome\n        }\n        left++;\n        right--;\n    }\n    return true; // Is a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\n\nint modp(int n, int p) {\n    // Handle the case when n is 0\n    if (n == 0) {\n        return 1; // 2^0 is 1\n    }\n    \n    long long result = 1; // Use long long to handle large numbers\n    long long base = 2;   // Base is 2\n    n = n % (p - 1);      // Fermat's Little Theorem optimization\n\n    while (n > 0) {\n        // If n is odd, multiply the base with the result\n        if (n % 2 == 1) {\n            result = (result * base) % p;\n        }\n        // Square the base\n        base = (base * base) % p;\n        // Divide n by 2\n        n /= 2;\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // Returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (char c : s) {\n        if (isalpha(c)) { // Check if the character is a letter\n            char base = islower(c) ? 'a' : 'A'; // Determine the base character\n            char shifted = (c - base + 5) % 26 + base; // Shift and wrap around\n            out += shifted; // Append the shifted character to the output\n        } else {\n            out += c; // Non-alphabetic characters are added unchanged\n        }\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // Takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (char c : s) {\n        if (isalpha(c)) { // Check if the character is a letter\n            char base = islower(c) ? 'a' : 'A'; // Determine the base character\n            char shifted = (c - base - 5 + 26) % 26 + base; // Shift back and wrap around\n            out += shifted; // Append the shifted character to the output\n        } else {\n            out += c; // Non-alphabetic characters are added unchanged\n        }\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        // Check if the character is not a vowel\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n            c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            result += c; // Append non-vowel character to result\n        }\n    }\n    return result; // Return the string without vowels\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false; // Found a number that is not below the threshold\n        }\n    }\n    return true; // All numbers are below the threshold\n}\n\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to add two numbers\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    unordered_set<char> set0(s0.begin(), s0.end());\n    unordered_set<char> set1(s1.begin(), s1.end());\n    \n    return set0 == set1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) return 0; // Handle the case for n = 0\n    if (n == 1) return 1; // Base case for n = 1\n\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; i++) {\n        c = a + b; // Calculate the next Fibonacci number\n        a = b;     // Move to the next number in the sequence\n        b = c;     // Update b to the new Fibonacci number\n    }\n    return b; // Return the n-th Fibonacci number\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int count = 0; // Initialize a counter for opening brackets\n\n    for (char ch : brackets) {\n        if (ch == '<') {\n            count++; // Increment for an opening bracket\n        } else if (ch == '>') {\n            count--; // Decrement for a closing bracket\n        }\n\n        // If count goes negative, there are unmatched closing brackets\n        if (count < 0) {\n            return false;\n        }\n    }\n\n    // At the end, count should be zero for all brackets to be matched\n    return count == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() < 2) return true; // A vector with less than 2 elements is considered monotonic.\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false; // Found an increasing pair, not decreasing\n        } else if (l[i] < l[i - 1]) {\n            increasing = false; // Found a decreasing pair, not increasing\n        }\n    }\n\n    return increasing || decreasing; // Return true if either increasing or decreasing\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Use a set to store unique elements from both vectors\n    set<int> set1(l1.begin(), l1.end());\n    set<int> set2(l2.begin(), l2.end());\n    \n    // Vector to store the common elements\n    vector<int> result;\n\n    // Use set_intersection to find common elements\n    set_intersection(set1.begin(), set1.end(),\n                     set2.begin(), set2.end(),\n                     back_inserter(result));\n\n    return result; // Return the sorted unique common elements\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int largest_factor = 1;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        largest_factor = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, check for odd factors from 3 to sqrt(n)\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest_factor = i;\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        largest_factor = n;\n    }\n\n    return largest_factor;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2; // Using the formula for the sum of the first n natural numbers\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // This will keep track of the balance of brackets\n\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++; // Increment for opening bracket\n        } else if (ch == ')') {\n            balance--; // Decrement for closing bracket\n        }\n\n        // If balance goes negative, there are unmatched closing brackets\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // At the end, balance should be zero for all brackets to be matched\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<float> derivative(const vector<float>& xs) {\n    vector<float> result;\n    int degree = xs.size(); // The degree of the polynomial is one less than the number of coefficients\n\n    for (int i = 1; i < degree; ++i) {\n        // Calculate the derivative coefficient for x^(i-1)\n        result.push_back(xs[i] * i);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    // Handle base cases\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Create an array to store the FibFib numbers\n    int fibfibArray[n + 1];\n    fibfibArray[0] = 0; // fibfib(0)\n    fibfibArray[1] = 0; // fibfib(1)\n    fibfibArray[2] = 1; // fibfib(2)\n\n    // Fill the array using the defined recurrence relation\n    for (int i = 3; i <= n; ++i) {\n        fibfibArray[i] = fibfibArray[i - 1] + fibfibArray[i - 2] + fibfibArray[i - 3];\n    }\n\n    // Return the n-th FibFib number\n    return fibfibArray[n];\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    int length = s.length();\n\n    for (int i = 0; i < length; i++) {\n        char ch = tolower(s[i]); // Convert to lowercase for uniformity\n        if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') {\n            count++;\n        }\n    }\n\n    // Check if the last character is 'y' (case insensitive)\n    if (length > 0 && tolower(s[length - 1]) == 'y') {\n        count++;\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert integer to string\n    string str = to_string(x);\n    int len = str.length();\n\n    // If shift is greater than the number of digits, reverse the string\n    if (shift >= len) {\n        reverse(str.begin(), str.end());\n        return str;\n    }\n\n    // Calculate the effective shift\n    shift = shift % len;\n\n    // Perform the circular shift\n    string result = str.substr(len - shift) + str.substr(0, len - shift);\n    return result;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0; // Initialize sum to 0\n    for (char c : s) { // Loop through each character in the string\n        if (c >= 'A' && c <= 'Z') { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add the ASCII value of the uppercase character\n        }\n    }\n    return sum; // Return the total sum\n}\n\n// Example usage\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0, oranges = 0;\n    \n    // Use a stringstream to parse the input string\n    stringstream ss(s);\n    string word;\n    \n    // Read through the string to find the numbers\n    while (ss >> word) {\n        if (isdigit(word[0])) { // Check if the first character is a digit\n            int count = stoi(word); // Convert the string to an integer\n            ss >> word; // Move to the next word (which should be \"apples\" or \"oranges\")\n            if (word == \"apples\") {\n                apples = count; // Assign to apples\n            } else if (word == \"oranges\") {\n                oranges = count; // Assign to oranges\n            }\n        }\n    }\n    \n    // Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n    return mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int smallest_even = -1; // Initialize to -1 to indicate no even number found\n    int index_of_smallest_even = -1; // Initialize index to -1\n\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            if (smallest_even == -1 || arr[i] < smallest_even) {\n                smallest_even = arr[i]; // Update smallest even value\n                index_of_smallest_even = i; // Update index\n            }\n        }\n    }\n\n    // If no even number was found, return an empty vector\n    if (index_of_smallest_even == -1) {\n        return {};\n    }\n\n    // Return the smallest even value and its index\n    return {smallest_even, index_of_smallest_even};\n}\n\n// Example usage\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequencyMap;\n\n    // Count the frequency of each integer in the vector\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    int result = -1;\n\n    // Check for the greatest integer that meets the condition\n    for (const auto& entry : frequencyMap) {\n        int num = entry.first;\n        int freq = entry.second;\n\n        if (freq >= num) {\n            result = max(result, num);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the input list\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int left = 0; // Pointer for the minimum values\n    int right = lst.size() - 1; // Pointer for the maximum values\n    \n    // Alternate between minimum and maximum\n    while (left <= right) {\n        if (left == right) {\n            result.push_back(lst[left]); // If both pointers meet, add the last element\n        } else {\n            result.push_back(lst[left]); // Add the minimum\n            result.push_back(lst[right]); // Add the maximum\n        }\n        left++;\n        right--;\n    }\n    \n    return result;\n}\n\n// Test the function\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b > c && a + c > b && b + c > a) {\n        // Calculate the semi-perimeter\n        float s = (a + b + c) / 2;\n        \n        // Calculate the area using Heron's formula\n        float area = sqrt(s * (s - a) * (s - b) * (s - c));\n        \n        // Return the area rounded to 2 decimal points\n        return round(area * 100) / 100; // Round to 2 decimal points\n    } else {\n        // Return -1 if the sides do not form a valid triangle\n        return -1;\n    }\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool is_palindrome(const vector<int>& q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false; // Not a palindrome\n        }\n    }\n    return true; // It's a palindrome\n}\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is a palindrome\n    if (!is_palindrome(q)) {\n        return false; // Not balanced\n    }\n    \n    // Calculate the sum of the elements\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    \n    // Check if the sum is less than or equal to the maximum weight\n    return sum <= w;\n}\n\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    // Compare elements from the start and end of the vector\n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++; // Increment changes for each mismatch\n        }\n    }\n\n    return changes; // Return the total number of changes needed\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Function to calculate total number of characters in a vector of strings\n    auto total_chars = [](const vector<string>& lst) {\n        int total = 0;\n        for (const string& str : lst) {\n            total += str.size();\n        }\n        return total;\n    };\n\n    // Calculate total characters for both vectors\n    int total1 = total_chars(lst1);\n    int total2 = total_chars(lst2);\n\n    // Compare totals and return the appropriate vector\n    if (total1 < total2) {\n        return lst1;\n    } else {\n        return lst2; // This includes the case where total1 == total2\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a list of prime numbers less than 100\nvector<int> generate_primes() {\n    vector<int> primes;\n    for (int i = 2; i < 100; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to check if a number is the product of three primes\nbool is_multiply_prime(int a) {\n    vector<int> primes = generate_primes();\n    int size = primes.size();\n    \n    // Check all combinations of three primes\n    for (int i = 0; i < size; i++) {\n        for (int j = i; j < size; j++) {\n            for (int k = j; k < size; k++) {\n                int product = primes[i] * primes[j] * primes[k];\n                if (product == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    // Handle edge cases\n    if (n <= 1) {\n        return (n == 1 && x == 1); // 1^k = 1 for any k, and 0 or negative bases are not valid for powers\n    }\n    if (x < 1) {\n        return false; // x must be a positive integer\n    }\n\n    int power = 1; // Start with n^0\n    while (power < x) {\n        power *= n; // Calculate n^k\n    }\n    \n    return power == x; // Check if we found the exact power\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool iscube(int a) {\n    // Calculate the cube root of the absolute value of a\n    double cubeRoot = cbrt(abs(a));\n    \n    // Round the cube root to the nearest integer\n    int roundedCubeRoot = round(cubeRoot);\n    \n    // Check if the cube of the rounded value equals a\n    return (roundedCubeRoot * roundedCubeRoot * roundedCubeRoot == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint hex_key(string num) {\n    // Define the set of prime hexadecimal digits\n    const string prime_hex_digits = \"2357BD\"; // B and D are included as they represent 11 and 13 respectively\n    int count = 0;\n\n    // Iterate through each character in the input string\n    for (char c : num) {\n        // Check if the character is in the prime hexadecimal digits\n        if (prime_hex_digits.find(c) != string::npos) {\n            count++;\n        }\n    }\n\n    return count; // Return the count of prime hexadecimal digits\n}\n\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Handle the case for 0 explicitly\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    string binary = \"\";\n    \n    // Convert decimal to binary\n    while (decimal > 0) {\n        // Prepend the binary digit (0 or 1) to the string\n        binary = to_string(decimal % 2) + binary;\n        decimal /= 2; // Divide by 2 to shift right\n    }\n    \n    // Add the \"db\" prefix and suffix\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is at least 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string and check every 3 consecutive characters\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        // Check if the three characters are distinct\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false; // Found a group of three that are not distinct\n        }\n    }\n\n    return true; // All groups of three are distinct\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n\n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n\n    return letter_grades;\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to check if the length of the string is prime\nbool prime_length(string str) {\n    int length = str.length(); // Get the length of the string\n    return is_prime(length); // Check if the length is prime\n}\n\n// Example usage\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        // For n = 1, the only number is '1'\n        return 1;\n    }\n\n    // Count of n-digit integers starting with '1'\n    long long count_starting_with_1 = pow(10, n - 1);\n    \n    // Count of n-digit integers ending with '1'\n    long long count_ending_with_1 = 9 * pow(10, n - 2);\n    \n    // Count of n-digit integers starting and ending with '1'\n    long long count_starting_and_ending_with_1 = pow(10, n - 2);\n    \n    // Total count\n    long long total_count = count_starting_with_1 + count_ending_with_1 - count_starting_and_ending_with_1;\n    \n    return total_count;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    // Step 1: Calculate the sum of digits\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to sum\n        N /= 10;       // Remove the last digit\n    }\n\n    // Step 2: Convert the sum to binary\n    string binary = \"\";\n    if (sum == 0) {\n        binary = \"0\"; // Handle the case where sum is 0\n    } else {\n        while (sum > 0) {\n            binary = to_string(sum % 2) + binary; // Prepend the binary digit\n            sum /= 2; // Divide sum by 2\n        }\n    }\n\n    // Step 3: Return the binary string\n    return binary;\n}\n\n// Example usage\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    // Iterate through the vector\n    for (int i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2 (odd indices)\n        if (lst[i] % 2 == 0) { // Check if the element is even\n            sum += lst[i]; // Add to sum if it's even\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    stringstream ss(s);\n    string word;\n    vector<string> words;\n\n    // Split the string into words\n    while (ss >> word) {\n        // Sort the characters of the word\n        sort(word.begin(), word.end());\n        words.push_back(word);\n    }\n\n    // Reconstruct the string with spaces\n    string result;\n    size_t pos = 0;\n    for (const auto& w : words) {\n        // Find the next space in the original string\n        size_t next_space = s.find(' ', pos);\n        // Append the word to the result\n        result += w;\n        // Append the spaces between words\n        if (next_space != string::npos) {\n            result += s.substr(pos + w.length(), next_space - (pos + w.length()));\n            pos = next_space + 1; // Move past the space\n        } else {\n            break; // No more spaces, exit the loop\n        }\n    }\n    \n    // Append any remaining spaces at the end\n    result += s.substr(pos);\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n\n    // Iterate through each row\n    for (int i = 0; i < lst.size(); ++i) {\n        // Iterate through each column in the current row\n        for (int j = 0; j < lst[i].size(); ++j) {\n            // Check if the current element matches x\n            if (lst[i][j] == x) {\n                // Store the coordinates {row, column}\n                result.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort the result first by row (ascending) and then by column (descending)\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] != b[0]) {\n            return a[0] < b[0]; // Sort by row ascending\n        }\n        return a[1] > b[1]; // Sort by column descending\n    });\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/88", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(const vector<int>& array) {\n    // Step 1: Check if the vector is empty\n    if (array.empty()) {\n        return {};\n    }\n\n    // Step 2: If the vector has only one element, return a copy of that vector\n    if (array.size() == 1) {\n        return array;\n    }\n\n    // Step 3: Calculate the sum of the first and last elements\n    int sum = array.front() + array.back();\n\n    // Step 4: Create a copy of the original array to sort\n    vector<int> sorted_array = array;\n\n    // Step 5: Sort based on the sum\n    if (sum % 2 == 0) {\n        // Even sum: sort in descending order\n        sort(sorted_array.rbegin(), sorted_array.rend());\n    } else {\n        // Odd sum: sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    // Step 6: Return the sorted vector\n    return sorted_array;\n}\n\n// Example usage\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string encrypted = \"\";\n    \n    for (char c : s) {\n        // Check if the character is a lowercase letter\n        if (c >= 'a' && c <= 'z') {\n            // Rotate the character by 4 positions\n            char newChar = c + 4;\n            // Wrap around if it goes past 'z'\n            if (newChar > 'z') {\n                newChar -= 26; // Wrap around to the start of the alphabet\n            }\n            encrypted += newChar;\n        }\n        // Check if the character is an uppercase letter\n        else if (c >= 'A' && c <= 'Z') {\n            // Rotate the character by 4 positions\n            char newChar = c + 4;\n            // Wrap around if it goes past 'Z'\n            if (newChar > 'Z') {\n                newChar -= 26; // Wrap around to the start of the alphabet\n            }\n            encrypted += newChar;\n        }\n        else {\n            // If it's not a letter, just append it unchanged\n            encrypted += c;\n        }\n    }\n    \n    return encrypted;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    // Use a set to store unique elements\n    set<int> unique_elements(lst.begin(), lst.end());\n\n    // If there are less than 2 unique elements, return -1\n    if (unique_elements.size() < 2) {\n        return -1; // or you could use a different way to indicate None\n    }\n\n    // Convert the set back to a vector and sort it\n    vector<int> sorted_unique(unique_elements.begin(), unique_elements.end());\n\n    // Return the second smallest element\n    return sorted_unique[1];\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nint is_bored(string S) {\n    // Define the delimiters\n    char delimiters[] = {'.', '?', '!'};\n    vector<string> sentences;\n    size_t start = 0;\n    \n    // Split the string into sentences\n    for (char delimiter : delimiters) {\n        size_t end = S.find(delimiter, start);\n        while (end != string::npos) {\n            sentences.push_back(S.substr(start, end - start));\n            start = end + 1;\n            end = S.find(delimiter, start);\n        }\n    }\n    // Add the last sentence if there's any remaining text\n    if (start < S.length()) {\n        sentences.push_back(S.substr(start));\n    }\n    \n    int boredom_count = 0;\n    \n    // Count sentences that start with \"I\"\n    for (const string& sentence : sentences) {\n        // Trim leading whitespace\n        size_t first_non_space = sentence.find_first_not_of(\" \\t\");\n        if (first_non_space != string::npos && sentence[first_non_space] == 'I') {\n            boredom_count++;\n        }\n    }\n    \n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n    \n    // Check if any number is equal to the sum of the other two\n    return (a == b + c) || (b == a + c) || (c == a + b);\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstring encode(string message) {\n    string encodedMessage = \"\";\n\n    for (char ch : message) {\n        // Swap case\n        if (isalpha(ch)) {\n            if (islower(ch)) {\n                ch = toupper(ch);\n            } else {\n                ch = tolower(ch);\n            }\n        }\n\n        // Replace vowels\n        switch (tolower(ch)) {\n            case 'a':\n                ch = 'c'; // 'a' -> 'c'\n                break;\n            case 'e':\n                ch = 'g'; // 'e' -> 'g'\n                break;\n            case 'i':\n                ch = 'k'; // 'i' -> 'k'\n                break;\n            case 'o':\n                ch = 'q'; // 'o' -> 'q'\n                break;\n            case 'u':\n                ch = 'w'; // 'u' -> 'w'\n                break;\n            default:\n                break; // Non-vowel characters remain unchanged\n        }\n\n        encodedMessage += ch; // Append the processed character to the result\n    }\n\n    return encodedMessage;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    if (num <= 3) return true; // 2 and 3 are prime numbers\n    if (num % 2 == 0 || num % 3 == 0) return false; // eliminate multiples of 2 and 3\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10; // add the last digit to sum\n        num /= 10; // remove the last digit\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and return the sum of its digits\nint largestPrimeDigitSum(const vector<int>& lst) {\n    int largestPrime = -1; // Initialize to -1 to indicate no prime found\n\n    // Find the largest prime number in the list\n    for (int num : lst) {\n        if (isPrime(num) && num > largestPrime) {\n            largestPrime = num;\n        }\n    }\n\n    // If no prime number was found, return 0 or handle as needed\n    if (largestPrime == -1) {\n        return 0; // or some other value indicating no prime found\n    }\n\n    // Calculate and return the sum of the digits of the largest prime\n    return sumOfDigits(largestPrime);\n}\n\n// Example usage\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <cctype> // for islower and isupper\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    // Iterate through each key in the map\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        // Check if the key is a string (it is, since we are using map<string, string>)\n        // Check if the key is all lower case or all upper case\n        if (!key.empty()) {\n            for (char c : key) {\n                if (islower(c)) {\n                    all_upper = false; // Found a lower case letter\n                } else if (isupper(c)) {\n                    all_lower = false; // Found an upper case letter\n                } else {\n                    // If the character is neither lower nor upper case, return false\n                    return false;\n                }\n            }\n        }\n    }\n\n    // Return true if all keys are either all lower or all upper case\n    return all_lower || all_upper;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to count prime numbers up to n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i); // Add prime number to the vector\n        }\n    }\n    return primes; // Return the vector of prime numbers\n}\n\n// Example usage\n"}
{"task_id": "CPP/97", "generation": "#include <stdio.h>\n\nint multiply(int a, int b) {\n    // Get the unit digits of both numbers\n    int unitDigitA = abs(a) % 10; // Use abs to handle negative numbers\n    int unitDigitB = abs(b) % 10; // Use abs to handle negative numbers\n    \n    // Return the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n\n// Example usage\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    // Define a string containing uppercase vowels for easy checking\n    string vowels = \"AEIOU\";\n\n    // Loop through the string, checking only even indices\n    for (int i = 0; i < s.length(); i += 2) {\n        // Check if the character is an uppercase vowel\n        if (vowels.find(s[i]) != string::npos) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\n\nint closest_integer(const std::string& value) {\n    // Convert string to double\n    double num = std::stod(value);\n    \n    // Get the integer part and the fractional part\n    int intPart = static_cast<int>(num);\n    double fracPart = num - intPart;\n\n    // Check for rounding conditions\n    if (fracPart > 0.5) {\n        return intPart + 1; // Round up\n    } else if (fracPart < 0.5) {\n        return intPart; // Round down\n    } else {\n        // fracPart is exactly 0.5\n        if (num > 0) {\n            return intPart + 1; // Round away from zero\n        } else {\n            return intPart - 1; // Round away from zero\n        }\n    }\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    int current_stones = n; // Start with n stones for the first level\n\n    for (int i = 0; i < n; ++i) {\n        stones.push_back(current_stones); // Add current level stones to the vector\n        // Determine the next number of stones for the next level\n        if (n % 2 == 0) {\n            // n is even, so the next number should be the next even number\n            current_stones += 2;\n        } else {\n            // n is odd, so the next number should be the next odd number\n            current_stones += 2;\n        }\n    }\n\n    return stones;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    string word;\n    stringstream ss(s);\n    \n    // Replace commas with spaces to simplify splitting\n    for (char &c : s) {\n        if (c == ',') {\n            c = ' ';\n        }\n    }\n    \n    // Use stringstream to extract words\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    \n    return words;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Check if the range is valid\n    if (y < x) {\n        return -1;\n    }\n    \n    // Find the largest even number in the range\n    if (y % 2 == 0) {\n        return y; // y is even\n    } else {\n        return y - 1; // y is odd, return the previous number\n    }\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Step 1: Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Step 2: Calculate the average of integers from n to m\n    int sum = 0;\n    int count = m - n + 1; // Total numbers from n to m\n    for (int i = n; i <= m; ++i) {\n        sum += i;\n    }\n    double average = static_cast<double>(sum) / count;\n\n    // Step 3: Round down to the nearest integer\n    int rounded_average = static_cast<int>(floor(average));\n\n    // Step 4: Convert the rounded average to binary\n    string binary = \"\";\n    if (rounded_average == 0) {\n        binary = \"0\";\n    } else {\n        while (rounded_average > 0) {\n            binary = to_string(rounded_average % 2) + binary;\n            rounded_average /= 2;\n        }\n    }\n\n    // Step 5: Return the binary representation\n    return binary;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a number has any even digits\nbool has_even_digit(int num) {\n    while (num > 0) {\n        int digit = num % 10; // Get the last digit\n        if (digit % 2 == 0) { // Check if the digit is even\n            return true; // Found an even digit\n        }\n        num /= 10; // Remove the last digit\n    }\n    return false; // No even digits found\n}\n\n// Function to return a sorted vector of integers without any even digits\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    // Iterate through each number in the input vector\n    for (int num : x) {\n        // If the number does not have any even digits, add it to the result\n        if (!has_even_digit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the result vector in increasing order\n    sort(result.begin(), result.end());\n\n    return result; // Return the sorted result\n}\n\n// Main function for testing\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Step 1: Filter the integers between 1 and 9\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Step 2: Sort the filtered integers\n    sort(filtered.begin(), filtered.end());\n\n    // Step 3: Reverse the sorted integers\n    reverse(filtered.begin(), filtered.end());\n\n    // Step 4: Map integers to their corresponding names\n    vector<string> names;\n    vector<string> numberNames = {\n        \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \n        \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    };\n\n    for (int num : filtered) {\n        names.push_back(numberNames[num]);\n    }\n\n    // Step 5: Return the resulting vector of names\n    return names;\n}\n\n// Example usage\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            // Calculate factorial for even index\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial; // Store in the vector (0-based index)\n        } else {\n            // Calculate sum from 1 to i for odd index\n            result[i - 1] = (i * (i + 1)) / 2; // Sum of first i natural numbers\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is a palindrome\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    int left = 0;\n    int right = str.length() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n\n    for (int i = 1; i <= n; i++) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n\n    return {evenCount, oddCount}; // Return the counts in a vector\n}\n\n// Example usage\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = abs(num); // Work with the absolute value for digit extraction\n\n    while (num > 0) {\n        sum += num % 10; // Add the last digit to the sum\n        num /= 10;       // Remove the last digit\n    }\n\n    // If the original number was negative, subtract twice the first digit\n    if (is_negative) {\n        // Get the first digit of the original number\n        int first_digit = abs(num);\n        while (first_digit >= 10) {\n            first_digit /= 10;\n        }\n        sum -= 2 * first_digit; // Adjust the sum for the first signed digit\n    }\n\n    return sum;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    // If the array is empty, return true\n    if (arr.empty()) {\n        return true;\n    }\n\n    int count = 0;\n    int n = arr.size();\n\n    // Iterate through the array to count the number of breaks\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            count++;\n        }\n    }\n\n    // If there is more than one break, return false\n    return count <= 1;\n}\n\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount = 0;\n    int evenCountInLst2 = 0;\n\n    // Count odd numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount++;\n        }\n    }\n\n    // Count even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCountInLst2++;\n        }\n    }\n\n    // If we have enough even numbers in lst2 to replace all odd numbers in lst1\n    if (oddCount <= evenCountInLst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nmap<string, int> histogram(string test) {\n    map<char, int> countMap;\n    map<string, int> result;\n\n    // Use a stringstream to split the input string by spaces\n    stringstream ss(test);\n    string word;\n\n    // Count occurrences of each letter\n    while (ss >> word) {\n        for (char c : word) {\n            countMap[c]++;\n        }\n    }\n\n    // Find the maximum count\n    int maxCount = 0;\n    for (const auto& pair : countMap) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Collect all letters with the maximum count\n    for (const auto& pair : countMap) {\n        if (pair.second == maxCount) {\n            result[string(1, pair.first)] = pair.second;\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Create a set of characters to be deleted\n    unordered_set<char> charsToDelete(c.begin(), c.end());\n    \n    // Build the resulting string by excluding characters in charsToDelete\n    string result;\n    for (char ch : s) {\n        if (charsToDelete.find(ch) == charsToDelete.end()) {\n            result += ch;\n        }\n    }\n    \n    // Check if the resulting string is a palindrome\n    string reversedResult = result;\n    reverse(reversedResult.begin(), reversedResult.end());\n    bool isPalindrome = (result == reversedResult);\n    \n    // Prepare the output\n    vector<string> output;\n    output.push_back(result);\n    output.push_back(isPalindrome ? \"True\" : \"False\");\n    \n    return output;\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n\n    for (int i = 0; i < lst.size(); ++i) {\n        string currentString = lst[i];\n        int oddCount = 0;\n\n        // Count odd digits in the current string\n        for (char c : currentString) {\n            if (c % 2 != 0) { // Check if the digit is odd\n                oddCount++;\n            }\n        }\n\n        // Create the formatted output string\n        string formattedString = \"the number of odd elements \" + to_string(oddCount) +\n                                  \"n the str\" + to_string(oddCount) +\n                                  \"ng \" + to_string(i + 1) + \" of the \" +\n                                  to_string(i + 1) + \"nput.\";\n        \n        result.push_back(formattedString);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\n#include <limits.h> // For INT_MAX\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long currentSum = 0;\n    long long minSum = LLONG_MAX; // Initialize to the maximum possible value\n\n    for (long long num : nums) {\n        currentSum += num; // Add the current number to the current sum\n        if (currentSum < minSum) {\n            minSum = currentSum; // Update minSum if currentSum is smaller\n        }\n        if (currentSum > 0) {\n            currentSum = 0; // Reset currentSum if it becomes positive\n        }\n    }\n\n    return minSum; // Return the minimum sum found\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowerings = 0;\n\n    for (const auto& well : grid) {\n        int water_units = 0;\n\n        // Count the number of 1s in the current well (row)\n        for (int water : well) {\n            if (water == 1) {\n                water_units++;\n            }\n        }\n\n        // Calculate the number of times we need to lower the bucket for this well\n        if (water_units > 0) {\n            total_lowerings += (water_units / capacity) + (water_units % capacity > 0 ? 1 : 0);\n        }\n    }\n\n    return total_lowerings;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count the number of 1's in the binary representation of a number\nint countOnes(int n) {\n    int count = 0;\n    while (n) {\n        count += n & 1; // Increment count if the last bit is 1\n        n >>= 1;        // Right shift to check the next bit\n    }\n    return count;\n}\n\n// Custom comparator for sorting\nbool customComparator(int a, int b) {\n    int countA = countOnes(a);\n    int countB = countOnes(b);\n    // First compare by number of 1's\n    if (countA != countB) {\n        return countA < countB;\n    }\n    // If the number of 1's is the same, compare by the value itself\n    return a < b;\n}\n\nvector<int> sort_array(vector<int> arr) {\n    sort(arr.begin(), arr.end(), customComparator);\n    return arr;\n}\n\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nbool is_consonant(char c) {\n    // Check if the character is a consonant\n    c = tolower(c); // Convert to lowercase for uniformity\n    return isalpha(c) && !strchr(\"aeiou\", c);\n}\n\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char c : word) {\n        if (is_consonant(c)) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    if (s.empty()) {\n        return result; // Return empty vector if input string is empty\n    }\n\n    stringstream ss(s);\n    string word;\n\n    // Split the string into words\n    while (ss >> word) {\n        if (count_consonants(word) == n) {\n            result.push_back(word); // Add word to result if it has exactly n consonants\n        }\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    // Define the set of vowels\n    string vowels = \"aeiouAEIOU\";\n    int n = word.length();\n\n    // Traverse the string from the end to the beginning\n    for (int i = n - 2; i > 0; --i) { // Start from n-2 to avoid the first and last character\n        if (isalpha(word[i])) { // Check if the character is a letter\n            if (vowels.find(word[i]) != string::npos) { // Check if it's a vowel\n                // Check if the characters before and after are consonants\n                if (isalpha(word[i - 1]) && isalpha(word[i + 1]) && \n                    vowels.find(word[i - 1]) == string::npos && \n                    vowels.find(word[i + 1]) == string::npos) {\n                    return string(1, word[i]); // Return the vowel as a string\n                }\n            }\n        }\n    }\n    return \"\"; // Return empty string if no valid vowel is found\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0];\n    string s2 = lst[1];\n\n    // Function to check if a concatenated string is balanced\n    auto is_balanced = [](const string& s1, const string& s2) {\n        int open = 0; // Count of open parentheses\n        int close = 0; // Count of close parentheses\n\n        // Check first string\n        for (char c : s1) {\n            if (c == '(') {\n                open++;\n            } else {\n                close++;\n            }\n            // If at any point close exceeds open, it's unbalanced\n            if (close > open) {\n                return false;\n            }\n        }\n\n        // Check second string\n        for (char c : s2) {\n            if (c == '(') {\n                open++;\n            } else {\n                close++;\n            }\n            // If at any point close exceeds open, it's unbalanced\n            if (close > open) {\n                return false;\n            }\n        }\n\n        // Finally, check if they are equal\n        return open == close;\n    };\n\n    // Check both concatenation orders\n    if (is_balanced(s1, s2) || is_balanced(s2, s1)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/120", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Step 2: Select the first k elements\n    vector<int> maxElements(arr.begin(), arr.begin() + k);\n    \n    // Step 3: Sort the selected elements in ascending order\n    sort(maxElements.begin(), maxElements.end());\n    \n    // Step 4: Return the sorted k elements\n    return maxElements;\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (size_t i = 0; i < lst.size(); i++) {\n        // Check if the index is even and the element is odd\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i]; // Add the element to sum\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0; // Initialize sum to 0\n    // Loop through the first k elements of arr\n    for (int i = 0; i < k; i++) {\n        // Check if the element has at most two digits\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i]; // Add to sum if condition is met\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers; // Vector to store odd numbers\n    while (n != 1) {\n        if (n % 2 != 0) { // Check if n is odd\n            odd_numbers.push_back(n); // Add odd number to the vector\n        }\n        // Apply the Collatz rules\n        if (n % 2 == 0) {\n            n = n / 2; // If n is even, divide by 2\n        } else {\n            n = 3 * n + 1; // If n is odd, apply 3n + 1\n        }\n    }\n    // Add the last number, which is 1\n    odd_numbers.push_back(1);\n    \n    // Sort the vector in increasing order\n    sort(odd_numbers.begin(), odd_numbers.end());\n    \n    return odd_numbers; // Return the sorted vector\n}\n\n// Example usage\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool valid_date(string date) {\n    // Rule 1: Check if the date string is not empty\n    if (date.empty()) {\n        return false;\n    }\n\n    // Rule 4: Check if the format is mm-dd-yyyy\n    if (date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n\n    // Split the date into month, day, and year\n    int month, day, year;\n    char dash1, dash2;\n    stringstream ss(date);\n    ss >> month >> dash1 >> day >> dash2 >> year;\n\n    // Check if the extraction was successful and the dashes are correct\n    if (ss.fail() || dash1 != '-' || dash2 != '-') {\n        return false;\n    }\n\n    // Rule 3: Validate the month\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    // Rule 2: Validate the day based on the month\n    if (month == 2) { // February\n        if (day < 1 || day > 29) {\n            return false;\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) { // April, June, September, November\n        if (day < 1 || day > 30) {\n            return false;\n        }\n    } else { // January, March, May, July, August, October, December\n        if (day < 1 || day > 31) {\n            return false;\n        }\n    }\n\n    // If all checks are passed, the date is valid\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    // Check for whitespace\n    if (txt.find_first_of(\" \\t\\n\") != string::npos) {\n        // Split on whitespace\n        vector<string> result;\n        stringstream ss(txt);\n        string word;\n        while (ss >> word) {\n            result.push_back(word);\n        }\n        return result;\n    }\n    \n    // Check for commas\n    if (txt.find(',') != string::npos) {\n        // Split on commas\n        vector<string> result;\n        stringstream ss(txt);\n        string word;\n        while (getline(ss, word, ',')) {\n            result.push_back(word);\n        }\n        return result;\n    }\n    \n    // Count lowercase letters with odd order in the alphabet\n    int count = 0;\n    for (char c : txt) {\n        if (islower(c)) {\n            int pos = c - 'a'; // Get the position of the letter\n            if (pos % 2 == 1) { // Check if the position is odd\n                count++;\n            }\n        }\n    }\n    \n    // Return the count as a vector with one element\n    return {to_string(count)};\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check for the sorted condition and count occurrences\n    unordered_map<int, int> count_map;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Count occurrences of each number\n        count_map[lst[i]]++;\n        \n        // If any number appears more than twice, return false\n        if (count_map[lst[i]] > 2) {\n            return false;\n        }\n        \n        // Check if the current number is less than the previous number\n        if (i > 0 && lst[i] < lst[i - 1]) {\n            return false; // Not sorted\n        }\n    }\n    \n    return true; // If we pass all checks, the list is sorted and valid\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to find the intersection of two intervals and check if its length is prime\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0];\n    int end1 = interval1[1];\n    int start2 = interval2[0];\n    int end2 = interval2[1];\n\n    // Calculate the intersection\n    int startIntersection = max(start1, start2);\n    int endIntersection = min(end1, end2);\n\n    // Check if there is an intersection\n    if (startIntersection > endIntersection) {\n        return \"NO\"; // No intersection\n    }\n\n    // Calculate the length of the intersection\n    int length = endIntersection - startIntersection + 1;\n\n    // Check if the length is prime\n    if (isPrime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/128", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    // Check if the array is empty\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int product_of_signs = 1; // Start with a positive sign\n    int sum_of_magnitudes = 0;\n\n    for (int num : arr) {\n        if (num > 0) {\n            sum_of_magnitudes += num; // Add magnitude\n        } else if (num < 0) {\n            sum_of_magnitudes += -num; // Add magnitude\n            product_of_signs *= -1; // Flip the sign\n        } else {\n            product_of_signs = 0; // If there's a zero, product of signs is zero\n        }\n    }\n\n    return sum_of_magnitudes * product_of_signs; // Return the final result\n}\n\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid dfs(vector<vector<int>>& grid, int x, int y, int k, vector<int>& currentPath, vector<int>& minPath) {\n    // If we have reached the length k, compare with the minimum path\n    if (currentPath.size() == k) {\n        if (minPath.empty() || currentPath < minPath) {\n            minPath = currentPath; // Update minimum path\n        }\n        return;\n    }\n\n    // Possible directions to move: right, down, left, up\n    vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    \n    // Explore neighbors\n    for (auto& dir : directions) {\n        int newX = x + dir.first;\n        int newY = y + dir.second;\n\n        // Check if the new position is within bounds\n        if (newX >= 0 && newX < grid.size() && newY >= 0 && newY < grid[0].size()) {\n            currentPath.push_back(grid[newX][newY]); // Add to current path\n            dfs(grid, newX, newY, k, currentPath, minPath); // Recursive DFS\n            currentPath.pop_back(); // Backtrack\n        }\n    }\n}\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    vector<int> minPath; // To store the minimum path\n    int n = grid.size();\n\n    // Try starting from every cell in the grid\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            vector<int> currentPath;\n            currentPath.push_back(grid[i][j]); // Start path with the current cell\n            dfs(grid, i, j, k, currentPath, minPath); // Start DFS\n            currentPath.pop_back(); // Backtrack\n        }\n    }\n\n    return minPath; // Return the minimum path found\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> result(n + 1); // Create a vector to hold the results\n\n    // Base case\n    if (n >= 0) result[0] = 3; // tri(1) = 3\n    if (n >= 1) result[1] = 1 + 1 / 2; // tri(2) = 1 + (2 / 2) = 2\n    if (n >= 2) result[2] = 2; // tri(2) = 2\n\n    // Calculate the rest of the values based on the recurrence relation\n    for (int i = 3; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result[i] = 1 + i / 2; // If i is even\n        } else {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1]; // If i is odd\n        }\n    }\n\n    return result; // Return the vector containing the Tribonacci sequence\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOdd = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply to the product\n            hasOdd = true; // Mark that we found an odd digit\n        }\n        n /= 10; // Remove the last digit\n    }\n\n    return hasOdd ? product : 0; // Return product if odd digits found, otherwise return 0\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int balance = 0; // To keep track of the balance of brackets\n    bool hasNested = false; // To check if we have found a nested structure\n\n    for (char ch : str) {\n        if (ch == '[') {\n            balance++;\n            // If we have already seen an opening bracket before, we have a nested structure\n            if (balance > 1) {\n                hasNested = true;\n            }\n        } else if (ch == ']') {\n            balance--;\n            // If balance goes negative, it means we have more closing brackets than opening ones\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n\n    // For the brackets to be valid, balance should be zero at the end\n    return balance == 0 && hasNested;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int rounded = ceil(num); // Round up to the nearest integer\n        sum += rounded * rounded; // Square the rounded value and add to sum\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha\n\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Trim trailing spaces\n    size_t end = txt.find_last_not_of(' ');\n    if (end == string::npos) {\n        return false; // The string is empty or only contains spaces\n    }\n    \n    // Get the last character\n    char lastChar = txt[end];\n    \n    // Check if the last character is an alphabetical character\n    if (!isalpha(lastChar)) {\n        return false; // Not an alphabetical character\n    }\n    \n    // Check if the character before the last character is a space\n    if (end == 0 || txt[end - 1] == ' ') {\n        return true; // Last character is a letter and not part of a word\n    }\n    \n    return false; // Last character is part of a word\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int n = arr.size();\n    \n    // Iterate from the second last element to the first element\n    for (int i = n - 2; i >= 0; --i) {\n        // Check if the current element is less than the next element\n        if (arr[i] > arr[i + 1]) {\n            return i + 1; // Return the index of the current element\n        }\n    }\n    \n    // If no such element is found, return -1\n    return -1;\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\n#include <limits> // For numeric limits\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = numeric_limits<int>::min(); // Initialize to the smallest possible integer\n    int smallest_positive = numeric_limits<int>::max(); // Initialize to the largest possible integer\n\n    bool found_negative = false;\n    bool found_positive = false;\n\n    for (int num : lst) {\n        if (num < 0) {\n            found_negative = true;\n            if (num > largest_negative) {\n                largest_negative = num; // Update largest negative\n            }\n        } else if (num > 0) {\n            found_positive = true;\n            if (num < smallest_positive) {\n                smallest_positive = num; // Update smallest positive\n            }\n        }\n    }\n\n    // If no negative number was found, set to 0\n    if (!found_negative) {\n        largest_negative = 0;\n    }\n\n    // If no positive number was found, set to 0\n    if (!found_positive) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n#include <sstream>\n#include <locale>\n\nusing namespace std;\n\ndouble to_double(const string& str) {\n    string s = str;\n    // Replace ',' with '.' for proper float conversion\n    replace(s.begin(), s.end(), ',', '.');\n    return stod(s);\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Check if both are of the same type\n    if (a.type() == b.type()) {\n        if (a.type() == typeid(int)) {\n            int int_a = boost::any_cast<int>(a);\n            int int_b = boost::any_cast<int>(b);\n            if (int_a == int_b) return \"None\";\n            return (int_a > int_b) ? a : b;\n        } else if (a.type() == typeid(double)) {\n            double double_a = boost::any_cast<double>(a);\n            double double_b = boost::any_cast<double>(b);\n            if (double_a == double_b) return \"None\";\n            return (double_a > double_b) ? a : b;\n        } else if (a.type() == typeid(string)) {\n            string str_a = boost::any_cast<string>(a);\n            string str_b = boost::any_cast<string>(b);\n            double double_a = to_double(str_a);\n            double double_b = to_double(str_b);\n            if (double_a == double_b) return \"None\";\n            return (double_a > double_b) ? a : b;\n        }\n    } else {\n        // If types are different, we need to convert them to comparable types\n        double double_a, double_b;\n        if (a.type() == typeid(int)) {\n            double_a = boost::any_cast<int>(a);\n            if (b.type() == typeid(double)) {\n                double_b = boost::any_cast<double>(b);\n            } else if (b.type() == typeid(string)) {\n                double_b = to_double(boost::any_cast<string>(b));\n            }\n        } else if (a.type() == typeid(double)) {\n            double_a = boost::any_cast<double>(a);\n            if (b.type() == typeid(int)) {\n                double_b = boost::any_cast<int>(b);\n            } else if (b.type() == typeid(string)) {\n                double_b = to_double(boost::any_cast<string>(b));\n            }\n        } else if (a.type() == typeid(string)) {\n            double_a = to_double(boost::any_cast<string>(a));\n            if (b.type() == typeid(int)) {\n                double_b = boost::any_cast<int>(b);\n            } else if (b.type() == typeid(double)) {\n                double_b = boost::any_cast<double>(b);\n            }\n        }\n\n        if (double_a == double_b) return \"None\";\n        return (double_a > double_b) ? a : b;\n    }\n    return \"None\"; // Fallback in case of unexpected types\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <stdio.h>\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is less than 8 or if n is odd\n    if (n < 8 || n % 2 != 0) {\n        return false;\n    }\n    return true; // n is even and n >= 8\n}\n\n// Example usage\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate factorial of a number\nlong long factorial(int n) {\n    long long result = 1;\n    for (int i = 2; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to calculate the Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; i++) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int space_count = 0; // To count consecutive spaces\n\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n        } else {\n            // If we have counted spaces before and they are more than 2\n            if (space_count > 2) {\n                result += '-'; // Replace with a single hyphen\n            } else if (space_count > 0) {\n                result += string(space_count, '_'); // Replace with underscores\n            }\n            result += c; // Add the current character\n            space_count = 0; // Reset space count\n        }\n    }\n\n    // Handle any trailing spaces\n    if (space_count > 2) {\n        result += '-';\n    } else if (space_count > 0) {\n        result += string(space_count, '_');\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check for exactly one dot\n    size_t dot_pos = file_name.find('.');\n    if (dot_pos == string::npos || file_name.find('.', dot_pos + 1) != string::npos) {\n        return \"No\";\n    }\n\n    // Split the file name into name and extension\n    string name_part = file_name.substr(0, dot_pos);\n    string ext_part = file_name.substr(dot_pos + 1);\n\n    // Check if the name part is not empty and starts with a letter\n    if (name_part.empty() || !isalpha(name_part[0])) {\n        return \"No\";\n    }\n\n    // Check the extension\n    if (ext_part != \"txt\" && ext_part != \"exe\" && ext_part != \"dll\") {\n        return \"No\";\n    }\n\n    // Count the number of digits in the file name\n    int digit_count = 0;\n    for (char c : file_name) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n    }\n\n    // Check if there are more than three digits\n    if (digit_count > 3) {\n        return \"No\";\n    }\n\n    // If all conditions are met, return \"Yes\"\n    return \"Yes\";\n}\n\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int total_sum = 0; // Initialize the sum to 0\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            // If the index is a multiple of 3, square the element\n            total_sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            // If the index is a multiple of 4 and not a multiple of 3, cube the element\n            total_sum += lst[i] * lst[i] * lst[i];\n        } else {\n            // Otherwise, just add the element as is\n            total_sum += lst[i];\n        }\n    }\n\n    return total_sum; // Return the total sum\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to extract words with prime lengths\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    vector<string> primeWords;\n\n    // Split the sentence into words\n    while (ss >> word) {\n        // Check if the length of the word is prime\n        if (isPrime(word.length())) {\n            primeWords.push_back(word); // Add to the list if prime\n        }\n    }\n\n    // Join the words with a space\n    string result;\n    for (size_t i = 0; i < primeWords.size(); i++) {\n        result += primeWords[i];\n        if (i < primeWords.size() - 1) {\n            result += \" \"; // Add space between words\n        }\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Parse the first fraction x\n    size_t pos = x.find('/');\n    int numerator_x = stoi(x.substr(0, pos));\n    int denominator_x = stoi(x.substr(pos + 1));\n\n    // Parse the second fraction n\n    pos = n.find('/');\n    int numerator_n = stoi(n.substr(0, pos));\n    int denominator_n = stoi(n.substr(pos + 1));\n\n    // Calculate the product of the fractions\n    int numerator_product = numerator_x * numerator_n;\n    int denominator_product = denominator_x * denominator_n;\n\n    // Check if the product is a whole number\n    return numerator_product % denominator_product == 0;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n// Helper function to calculate the sum of digits\nint sum_of_digits(int num) {\n    int sum = 0;\n    // Work with the absolute value of the number\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Comparator function for sorting\nbool compare(const pair<int, int>& a, const pair<int, int>& b) {\n    // Compare by sum of digits\n    int sumA = sum_of_digits(a.first);\n    int sumB = sum_of_digits(b.first);\n    \n    if (sumA == sumB) {\n        // If sums are equal, maintain original order based on index\n        return a.second < b.second;\n    }\n    return sumA < sumB;\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of pairs to store the number and its original index\n    vector<pair<int, int>> indexed_nums;\n    for (int i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({nums[i], i});\n    }\n    \n    // Sort using the custom comparator\n    sort(indexed_nums.begin(), indexed_nums.end(), compare);\n    \n    // Extract the sorted numbers\n    vector<int> sorted_nums;\n    for (const auto& p : indexed_nums) {\n        sorted_nums.push_back(p.first);\n    }\n    \n    return sorted_nums;\n}\n\n// Example usage\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if a digit is odd\nbool isOdd(int digit) {\n    return (digit % 2 != 0);\n}\n\n// Function to get the first digit of a number\nint getFirstDigit(int num) {\n    while (num >= 10) {\n        num /= 10;\n    }\n    return num;\n}\n\n// Function to get the last digit of a number\nint getLastDigit(int num) {\n    return abs(num % 10); // Use abs to handle negative numbers\n}\n\n// Function to filter the numbers based on the criteria\nint specialFilter(vector<int> nums) {\n    int count = 0;\n\n    for (int num : nums) {\n        if (num > 10) {\n            int firstDigit = getFirstDigit(num);\n            int lastDigit = getLastDigit(num);\n            if (isOdd(firstDigit) && isOdd(lastDigit)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n\n// Main function to test the specialFilter function\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    vector<int> count(3, 0); // count[0] for mod 0, count[1] for mod 1, count[2] for mod 2\n\n    // Fill the array a and count the occurrences of each modulo\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1;\n        count[a[i - 1] % 3]++;\n    }\n\n    // Now count the number of valid triples\n    int result = 0;\n\n    // Case 1: All three numbers are of the same mod\n    for (int i = 0; i < 3; ++i) {\n        if (count[i] >= 3) {\n            result += (count[i] * (count[i] - 1) * (count[i] - 2)) / 6; // nC3\n        }\n    }\n\n    // Case 2: One number from each mod\n    result += count[0] * count[1] * count[2];\n\n    return result;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // Define the order of planets in the solar system\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Find the indices of the provided planets\n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n    \n    // Check if both planets are valid\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {}; // Return an empty vector if either planet is invalid\n    }\n    \n    // Get the indices of the planets\n    int index1 = distance(planets.begin(), it1);\n    int index2 = distance(planets.begin(), it2);\n    \n    // Ensure index1 is less than index2\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Create a vector to hold the planets between planet1 and planet2\n    vector<string> result;\n    \n    // Collect the planets between the two indices\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result; // Return the result vector\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Step 1: Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& str) {\n        return str.length() % 2 != 0; // Keep only even length strings\n    }), lst.end());\n\n    // Step 2: Sort the remaining strings\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Sort alphabetically if lengths are equal\n        }\n        return a.length() < b.length(); // Sort by length\n    });\n\n    // Step 3: Return the sorted vector\n    return lst;\n}\n\n// Example usage\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to return x if n is prime, otherwise return y\nint x_or_y(int n, int x, int y) {\n    if (isPrime(n)) {\n        return x; // n is prime\n    } else {\n        return y; // n is not prime\n    }\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum_of_squares = 0;\n\n    for (float num : lst) {\n        // Check if the number is a non-negative integer\n        if (num >= 0 && floor(num) == num) {\n            int int_num = static_cast<int>(num);\n            // Check if the number is odd\n            if (int_num % 2 != 0) {\n                sum_of_squares += int_num * int_num; // Add the square of the odd integer\n            }\n        }\n    }\n\n    return sum_of_squares;\n}\n\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for abs function\n\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result; // Vector to store the results\n    int n = game.size(); // Get the size of the vectors\n\n    // Iterate through each match\n    for (int i = 0; i < n; i++) {\n        // Calculate the absolute difference and add to the result vector\n        result.push_back(abs(game[i] - guess[i]));\n    }\n\n    return result; // Return the result vector\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = -1; // Initialize to a value lower than any possible strength\n    string strongest_extension;\n\n    for (const string& extension : extensions) {\n        int CAP = 0;\n        int SM = 0;\n\n        // Calculate CAP and SM\n        for (char c : extension) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n\n        // Calculate strength\n        int strength = CAP - SM;\n\n        // Check if this extension is stronger\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    // Return the result in the required format\n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Check if b is longer than a, if so, it can't be a substring\n    if (b.length() > a.length()) {\n        return false;\n    }\n    \n    // Concatenate b with itself to get all rotations\n    string b_double = b + b;\n    \n    // Check if b_double contains a as a substring\n    return b_double.find(a) != string::npos;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Initialize counts for even and odd digits\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Work with the absolute value of the number\n    num = abs(num);\n\n    // If the number is 0, it has one even digit\n    if (num == 0) {\n        even_count = 1;\n    } else {\n        // Iterate through each digit\n        while (num > 0) {\n            int digit = num % 10; // Get the last digit\n            if (digit % 2 == 0) {\n                even_count++; // Increment even count\n            } else {\n                odd_count++; // Increment odd count\n            }\n            num /= 10; // Remove the last digit\n        }\n    }\n\n    // Return the counts as a vector\n    return {even_count, odd_count};\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the Roman numeral mappings\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string result = \"\";\n    \n    // Build the Roman numeral string\n    for (const auto& pair : roman_numerals) {\n        while (number >= pair.first) {\n            result += pair.second;\n            number -= pair.first;\n        }\n    }\n    \n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to find the longest side\n    float x = fmax(a, fmax(b, c)); // longest side\n    float y, z;\n\n    if (x == a) {\n        y = b;\n        z = c;\n    } else if (x == b) {\n        y = a;\n        z = c;\n    } else {\n        y = a;\n        z = b;\n    }\n\n    // Check the Pythagorean theorem\n    return (fabs(y * y + z * z - x * x) < 1e-6); // Using a small epsilon for floating point comparison\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string max_word;\n    int max_unique_count = 0;\n\n    for (const string& word : words) {\n        // Use a set to find unique characters\n        unordered_set<char> unique_chars(word.begin(), word.end());\n        int unique_count = unique_chars.size();\n\n        // Check if we found a new maximum or if we need to update for lexicographical order\n        if (unique_count > max_unique_count || \n            (unique_count == max_unique_count && (max_word.empty() || word < max_word))) {\n            max_unique_count = unique_count;\n            max_word = word;\n        }\n    }\n\n    return max_word;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate how many more carrots the rabbit needs to eat\n    int carrotsToEat = min(need, remaining);\n    \n    // Update the total number of eaten carrots\n    int totalEaten = number + carrotsToEat;\n    \n    // Calculate the remaining carrots after eating\n    int remainingAfterEat = remaining - carrotsToEat;\n    \n    // Return the result as a vector\n    return {totalEaten, remainingAfterEat};\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stdexcept>\n\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    if (operato.size() + 1 != operand.size()) {\n        throw invalid_argument(\"The length of operator vector must be one less than the length of operand vector.\");\n    }\n\n    // First, handle multiplication, floor division, and exponentiation\n    vector<int> temp_operand = operand;\n    vector<string> temp_operator = operato;\n\n    for (size_t i = 0; i < temp_operator.size(); ++i) {\n        if (temp_operator[i] == \"*\" || temp_operator[i] == \"//\" || temp_operator[i] == \"**\") {\n            int result = 0;\n            if (temp_operator[i] == \"*\") {\n                result = temp_operand[i] * temp_operand[i + 1];\n            } else if (temp_operator[i] == \"//\") {\n                if (temp_operand[i + 1] == 0) {\n                    throw invalid_argument(\"Division by zero is not allowed.\");\n                }\n                result = temp_operand[i] / temp_operand[i + 1];\n            } else if (temp_operator[i] == \"**\") {\n                result = pow(temp_operand[i], temp_operand[i + 1]);\n            }\n\n            // Replace the operands and operator\n            temp_operand[i] = result;\n            temp_operand.erase(temp_operand.begin() + i + 1);\n            temp_operator.erase(temp_operator.begin() + i);\n            i--; // Adjust index after removal\n        }\n    }\n\n    // Now handle addition and subtraction\n    int final_result = temp_operand[0];\n\n    for (size_t i = 0; i < temp_operator.size(); ++i) {\n        if (temp_operator[i] == \"+\") {\n            final_result += temp_operand[i + 1];\n        } else if (temp_operator[i] == \"-\") {\n            final_result -= temp_operand[i + 1];\n        }\n    }\n\n    return final_result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha, tolower, toupper\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetter = false;\n\n    // First pass to check if there's any letter\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    // If there are letters, reverse their case\n    if (hasLetter) {\n        for (char &c : s) {\n            if (isalpha(c)) {\n                // Reverse case\n                if (islower(c)) {\n                    c = toupper(c);\n                } else {\n                    c = tolower(c);\n                }\n            }\n        }\n    } else {\n        // If no letters, reverse the entire string\n        reverse(s.begin(), s.end());\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n#include <sstream>\n#include <iomanip>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\"; // Return an empty string if input is empty\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.size(), digest);\n\n    // Convert the unsigned char array to a hex string\n    stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {\n        ss << hex << setw(2) << setfill('0') << (int)digest[i];\n    }\n\n    return ss.str();\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> even_digits;\n    // Ensure we iterate from the smaller to the larger value\n    int start = min(a, b);\n    int end = max(a, b);\n    \n    // Check for even digits from 2 to 8\n    for (int i = start; i <= end; ++i) {\n        if (i >= 2 && i <= 8 && i % 2 == 0) {\n            even_digits.push_back(i);\n        }\n    }\n    \n    return even_digits;\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::sort\n#include <cmath>     // For std::abs\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector\n    sort(numbers.begin(), numbers.end());\n\n    // Check adjacent elements\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (fabs(numbers[i + 1] - numbers[i]) < threshold) {\n            return true; // Found two elements that are too close\n        }\n    }\n    \n    return false; // No elements found that are too close\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype> // for isspace\n\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (isspace(ch)) {\n            continue; // Ignore spaces\n        }\n\n        if (ch == '(') {\n            if (balance == 0 && !current_group.empty()) {\n                // If we are starting a new group, save the current one\n                result.push_back(current_group);\n                current_group.clear();\n            }\n            current_group += ch; // Add the opening parenthesis\n            balance++;\n        } else if (ch == ')') {\n            current_group += ch; // Add the closing parenthesis\n            balance--;\n        }\n\n        // When balance is zero, we have a complete group\n        if (balance == 0 && !current_group.empty()) {\n            result.push_back(current_group);\n            current_group.clear(); // Clear for the next group\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    // Get the integer part of the number\n    int integer_part = (int)floor(number);\n    // Calculate the decimal part\n    float decimal_part = number - integer_part;\n    return decimal_part;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a balance of zero\n\n    // Iterate through each operation\n    for (int operation : operations) {\n        balance += operation; // Update the balance\n\n        // Check if the balance falls below zero\n        if (balance < 0) {\n            return true; // Return true if balance is below zero\n        }\n    }\n\n    return false; // Return false if balance never goes below zero\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(const vector<float>& numbers) {\n    if (numbers.empty()) {\n        return 0.0; // Return 0 for empty input\n    }\n\n    // Step 1: Calculate the mean\n    float sum = 0.0;\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / numbers.size();\n\n    // Step 2: Calculate the absolute differences and their average\n    float mad_sum = 0.0;\n    for (float num : numbers) {\n        mad_sum += fabs(num - mean);\n    }\n    \n    // Step 3: Calculate the Mean Absolute Deviation\n    float mad = mad_sum / numbers.size();\n    return mad;\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimiter) {\n    // Create a new vector to hold the result\n    vector<int> result;\n\n    // Check if the input vector is empty\n    if (numbers.empty()) {\n        return result; // Return an empty vector\n    }\n\n    // Iterate through the input vector\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        // Add the current number to the result\n        result.push_back(numbers[i]);\n        \n        // If it's not the last element, add the delimiter\n        if (i < numbers.size() - 1) {\n            result.push_back(delimiter);\n        }\n    }\n\n    return result; // Return the result vector\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <set>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result; // To store the maximum nesting levels for each group\n    stringstream ss(paren_string); // Use stringstream to split the input string\n    string group;\n\n    // Process each group separated by spaces\n    while (ss >> group) {\n        int current_level = 0; // Current level of nesting\n        int max_level = 0; // Maximum level of nesting for this group\n\n        // Iterate through each character in the group\n        for (char ch : group) {\n            if (ch == '(') {\n                current_level++; // Increase level for opening parenthesis\n                if (current_level > max_level) {\n                    max_level = current_level; // Update max level if current is greater\n                }\n            } else if (ch == ')') {\n                current_level--; // Decrease level for closing parenthesis\n            }\n        }\n\n        result.push_back(max_level); // Store the maximum level for this group\n    }\n\n    return result; // Return the result vector\n}\n\n// Example usage\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to filter strings containing the given substring\nvector<string> filter_by_substring(const vector<string>& strings, const string& substring) {\n    vector<string> filtered; // Vector to store filtered results\n\n    // Iterate through each string in the input vector\n    for (const string& str : strings) {\n        // Check if the substring is found in the current string\n        if (str.find(substring) != string::npos) {\n            filtered.push_back(str); // Add to filtered results if found\n        }\n    }\n\n    return filtered; // Return the filtered vector\n}\n\n// Example usage\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Check if the vector is empty\n    if (numbers.empty()) {\n        return {sum, product}; // Return (0, 1) for empty vector\n    }\n\n    // Calculate sum and product\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return {sum, product};\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(const vector<int>& numbers) {\n    vector<int> result;\n    int current_max = INT_MIN; // Initialize to the smallest integer\n\n    for (int num : numbers) {\n        // Update the current maximum if the current number is greater\n        if (num > current_max) {\n            current_max = num;\n        }\n        // Append the current maximum to the result vector\n        result.push_back(current_max);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(const string& str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    int n = str.length();\n    \n    // Find the longest palindromic suffix\n    for (int i = n; i >= 0; --i) {\n        string suffix = str.substr(i);\n        if (is_palindrome(suffix)) {\n            // If the suffix is a palindrome, we need to append the reverse of the prefix\n            string prefix = str.substr(0, i);\n            string reversed_prefix(prefix.rbegin(), prefix.rend());\n            return str + reversed_prefix;\n        }\n    }\n    \n    // If no palindromic suffix is found, return the original string + its reverse\n    return str + string(str.rbegin(), str.rend());\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of the same length\n    if (a.length() != b.length()) {\n        throw invalid_argument(\"Strings must be of the same length\");\n    }\n\n    string result = \"\";\n    for (size_t i = 0; i < a.length(); i++) {\n        // Perform XOR operation\n        if (a[i] == b[i]) {\n            result += '0'; // Both bits are the same\n        } else {\n            result += '1'; // Bits are different\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <optional> // For std::optional\n\nusing namespace std;\n\n// Forward declaration of the longest function\nstd::optional<string> longest(const vector<string>& strings);\n\n// Definition of the longest function\nstd::optional<string> longest(const vector<string>& strings) {\n    if (strings.empty()) {\n        return std::nullopt; // Return an empty optional if the input vector is empty\n    }\n\n    string longestStr = strings[0]; // Start with the first string\n    for (const auto& str : strings) {\n        if (str.length() > longestStr.length()) {\n            longestStr = str; // Update longestStr if a longer string is found\n        }\n    }\n    return longestStr; // Return the longest string found\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure a and b are non-negative\n    a = abs(a);\n    b = abs(b);\n    \n    // Use the Euclidean algorithm\n    while (b != 0) {\n        int temp = b;\n        b = a % b; // Remainder of a divided by b\n        a = temp;  // Update a to be the previous b\n    }\n    \n    return a; // When b is 0, a contains the GCD\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes; // Vector to store prefixes\n    for (size_t i = 1; i <= str.length(); ++i) { // Loop from 1 to length of the string\n        prefixes.push_back(str.substr(0, i)); // Add the prefix to the vector\n    }\n    return prefixes; // Return the vector of prefixes\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss; // Create a stringstream to build the output string\n    for (int i = 0; i <= n; ++i) {\n        ss << i; // Add the current number to the stringstream\n        if (i < n) {\n            ss << \" \"; // Add a space if it's not the last number\n        }\n    }\n    return ss.str(); // Convert the stringstream to a string and return it\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <unordered_set>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    unordered_set<char> distinct_chars;\n\n    // Convert each character to lowercase and insert into the set\n    for (char c : str) {\n        distinct_chars.insert(tolower(c));\n    }\n\n    // The size of the set gives the number of distinct characters\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> durations;\n    stringstream ss(music_string);\n    string note;\n\n    while (ss >> note) {\n        if (note == \"o\") {\n            durations.push_back(4); // Whole note\n        } else if (note == \"o|\") {\n            durations.push_back(2); // Half note\n        } else if (note == \".|\") {\n            durations.push_back(1); // Quarter note\n        }\n    }\n\n    return durations;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (substring.empty()) {\n        return 0; // If the substring is empty, return 0\n    }\n\n    int count = 0;\n    size_t pos = 0;\n\n    // Loop to find all occurrences of the substring\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++;\n        pos++; // Move to the next position to allow for overlapping matches\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Mapping from string to integer\n    map<string, int> num_map = {\n        {\"zero\", 0},\n        {\"one\", 1},\n        {\"two\", 2},\n        {\"three\", 3},\n        {\"four\", 4},\n        {\"five\", 5},\n        {\"six\", 6},\n        {\"seven\", 7},\n        {\"eight\", 8},\n        {\"nine\", 9}\n    };\n\n    // Vector to hold the integers\n    vector<int> num_list;\n    stringstream ss(numbers);\n    string word;\n\n    // Split the input string into words and convert to integers\n    while (ss >> word) {\n        num_list.push_back(num_map[word]);\n    }\n\n    // Sort the integers\n    sort(num_list.begin(), num_list.end());\n\n    // Convert sorted integers back to strings\n    vector<string> sorted_words;\n    for (int num : num_list) {\n        for (const auto& pair : num_map) {\n            if (pair.second == num) {\n                sorted_words.push_back(pair.first);\n                break;\n            }\n        }\n    }\n\n    // Join the sorted words into a single string\n    string result;\n    for (size_t i = 0; i < sorted_words.size(); ++i) {\n        result += sorted_words[i];\n        if (i < sorted_words.size() - 1) {\n            result += \" \"; // Add space between words\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\npair<float, float> find_closest_elements(vector<float> numbers) {\n    // Step 1: Sort the vector\n    sort(numbers.begin(), numbers.end());\n\n    // Initialize variables to track the closest pair\n    float min_diff = numeric_limits<float>::max(); // Start with the maximum possible float value\n    pair<float, float> closest_pair;\n\n    // Step 2: Find the closest pair\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i]; // Calculate the difference between consecutive elements\n        if (diff < min_diff) {\n            min_diff = diff; // Update the minimum difference\n            closest_pair = make_pair(numbers[i], numbers[i + 1]); // Update the closest pair\n        }\n    }\n\n    // Step 3: Return the closest pair\n    return closest_pair;\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    // Find the minimum and maximum values in the vector\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n\n    // Create a new vector to hold the rescaled values\n    vector<float> rescaled;\n\n    // Rescale each number in the input vector\n    for (float num : numbers) {\n        float rescaled_value = (num - min_val) / (max_val - min_val);\n        rescaled.push_back(rescaled_value);\n    }\n\n    return rescaled;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\n#include <typeinfo>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> result;\n\n    for (const auto& value : values) {\n        // Check if the value can be cast to an int\n        if (value.type() == typeid(int)) {\n            // Safely cast and add to the result vector\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint strlen(string str) {\n    return str.size(); // or str.length();\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    // Start from n-1 and go down to 1\n    for (int i = n - 1; i > 0; i--) {\n        if (n % i == 0) {\n            return i; // Return the first divisor found\n        }\n    }\n    return 1; // In case n is 1, the largest divisor is 1\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i * i <= n; i += 2) {\n        // While i divides n, add i and divide n\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(const vector<int>& numbers) {\n    unordered_map<int, int> count_map;\n    \n    // Count occurrences of each number\n    for (int num : numbers) {\n        count_map[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Add elements that occur exactly once to the result\n    for (int num : numbers) {\n        if (count_map[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for islower and isupper\n\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) { // Use a reference to modify the original string\n        if (islower(c)) {\n            c = toupper(c); // Convert to uppercase\n        } else if (isupper(c)) {\n            c = tolower(c); // Convert to lowercase\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result; // Initialize an empty string to hold the concatenated result\n    for (const string& str : strings) { // Iterate over each string in the vector\n        result += str; // Append the current string to the result\n    }\n    return result; // Return the concatenated string\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_prefix(const vector<string>& strings, const string& prefix) {\n    vector<string> filtered_strings;\n\n    for (const auto& str : strings) {\n        // Check if the string starts with the given prefix\n        if (str.rfind(prefix, 0) == 0) { // rfind returns 0 if prefix is found at the start\n            filtered_strings.push_back(str);\n        }\n    }\n\n    return filtered_strings;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positive_numbers; // Vector to store positive numbers\n    for (float num : l) { // Iterate through each number in the input vector\n        if (num > 0) { // Check if the number is positive\n            positive_numbers.push_back(num); // Add to the positive numbers vector\n        }\n    }\n    return positive_numbers; // Return the vector of positive numbers\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Check if n is less than 2\n    if (n < 2) {\n        return false;\n    }\n    // Check for factors from 2 to the square root of n\n    for (long long i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            return false; // n is divisible by i, hence not prime\n        }\n    }\n    return true; // n is prime\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <stdexcept>\n\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble poly_derivative(vector<double> xs, double x) {\n    double sum = 0;\n    for (int i = 1; i < xs.size(); i++) {\n        sum += i * xs[i] * pow(x, i - 1);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    // Initial guess for the root\n    double x0 = 0.0; // You may choose a better initial guess based on the polynomial\n    double tolerance = 1e-7; // Tolerance for convergence\n    int max_iterations = 1000; // Maximum number of iterations\n    int iteration = 0;\n\n    while (iteration < max_iterations) {\n        double fx = poly(xs, x0);\n        double dfx = poly_derivative(xs, x0);\n\n        if (fabs(fx) < tolerance) {\n            return x0; // Found a root\n        }\n\n        if (fabs(dfx) < tolerance) {\n            throw runtime_error(\"Derivative is too small; no convergence.\");\n        }\n\n        // Newton-Raphson update\n        x0 -= fx / dfx;\n        iteration++;\n    }\n\n    throw runtime_error(\"Maximum iterations reached; no convergence.\");\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    // Create a vector to hold the values at indices divisible by 3\n    vector<int> to_sort;\n\n    // Collect values at indices divisible by 3\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            to_sort.push_back(l[i]);\n        }\n    }\n\n    // Sort the collected values\n    sort(to_sort.begin(), to_sort.end());\n\n    // Replace the original values at indices divisible by 3 with sorted values\n    size_t sort_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            l[i] = to_sort[sort_index++];\n        }\n    }\n\n    return l;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Remove duplicates\n    auto last = unique(l.begin(), l.end());\n    \n    // Resize the vector to contain only unique elements\n    l.erase(last, l.end());\n    \n    return l;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    // Check if the vector is empty\n    if (l.empty()) {\n        throw std::invalid_argument(\"The vector is empty.\");\n    }\n\n    // Initialize max with the first element of the vector\n    float max_val = l[0];\n\n    // Iterate through the vector to find the maximum element\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint count_sevens(int number) {\n    int count = 0;\n    string num_str = to_string(number);\n    for (char c : num_str) {\n        if (c == '7') {\n            count++;\n        }\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int total_count = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            total_count += count_sevens(i);\n        }\n    }\n    return total_count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Create a vector to hold the even indexed values\n    vector<float> even_values;\n\n    // Extract even indexed values\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n\n    // Sort the even indexed values\n    sort(even_values.begin(), even_values.end());\n\n    // Create a new vector to hold the result\n    vector<float> result(l.size());\n\n    // Fill the result vector\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            // Even index: use sorted value\n            result[i] = even_values[i / 2];\n        } else {\n            // Odd index: keep original value\n            result[i] = l[i];\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++) {\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output = output + x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string. \n    */\n    int l = s.length();\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++) {\n        // reverse the cycling of elements in each group.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x[x.length() - 1] + x.substr(0, 2);\n        output = output + x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    if (num <= 3) return true; // 2 and 3 are prime numbers\n    if (num % 2 == 0 || num % 3 == 0) return false; // eliminate multiples of 2 and 3\n\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\n// Function to return the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    int count = 0; // Count of prime Fibonacci numbers\n    int a = 0, b = 1; // Fibonacci numbers initialization\n    int fib;\n\n    while (count < n) {\n        fib = a + b; // Calculate the next Fibonacci number\n        a = b; // Update a to the next Fibonacci number\n        b = fib; // Update b to the next Fibonacci number\n\n        if (is_prime(fib)) { // Check if the Fibonacci number is prime\n            count++; // Increment the count of prime Fibonacci numbers\n            if (count == n) {\n                return fib; // Return the n-th prime Fibonacci number\n            }\n        }\n    }\n    return -1; // In case n is not valid (should not happen in this context)\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    // Iterate through the vector\n    for (int i = 0; i < n - 2; i++) {\n        // To avoid duplicates for the first element\n        if (i > 0 && l[i] == l[i - 1]) continue;\n\n        int left = i + 1;\n        int right = n - 1;\n\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n\n            if (sum == 0) {\n                return true; // Found a triplet\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    \n    return false; // No triplet found\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Each car moving left to right will collide with each car moving right to left\n    return n * n; // Total collisions = n (left to right) * n (right to left)\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (size_t i = 0; i < l.size(); ++i) {\n        l[i] += 1; // Increment each element by 1\n    }\n    return l; // Return the modified vector\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen; // Set to store the numbers we have seen\n\n    for (int num : l) {\n        // Check if the negation of the current number is in the set\n        if (seen.count(-num)) {\n            return true; // Found a pair that sums to zero\n        }\n        seen.insert(num); // Add the current number to the set\n    }\n    \n    return false; // No pairs found that sum to zero\n}\n\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // for std::reverse\n\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (x == 0) return \"0\"; // Handle the case for 0\n\n    string result;\n    \n    while (x > 0) {\n        int remainder = x % base; // Get the remainder\n        result += to_string(remainder); // Append the remainder to the result\n        x /= base; // Divide x by the base\n    }\n    \n    reverse(result.begin(), result.end()); // Reverse the string to get the correct order\n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h; // Calculate the area using the formula\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    // Base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    // Array to store the last four values\n    int fib[4] = {0, 0, 2, 0};\n\n    // Compute fib4(n) iteratively\n    for (int i = 4; i <= n; ++i) {\n        // Calculate the next value based on the last four values\n        int next_value = fib[0] + fib[1] + fib[2] + fib[3];\n        \n        // Shift the values in the array\n        fib[0] = fib[1];\n        fib[1] = fib[2];\n        fib[2] = fib[3];\n        fib[3] = next_value;\n    }\n\n    // The result for fib4(n) will be in fib[3] after the loop\n    return fib[3];\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Calculate the size of the vector\n    size_t size = l.size();\n    \n    // If the size is odd, return the middle element\n    if (size % 2 == 1) {\n        return l[size / 2];\n    } else {\n        // If the size is even, return the average of the two middle elements\n        return (l[size / 2 - 1] + l[size / 2]) / 2.0;\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Not a palindrome\n        }\n        left++;\n        right--;\n    }\n    return true; // Is a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\n\nint modp(int n, int p) {\n    if (p == 1) return 0; // Since any number mod 1 is 0\n    long long result = 1; // Use long long to avoid overflow\n    long long base = 2;   // Base is 2\n\n    // Exponentiation by squaring\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base\n        n /= 2; // Divide n by 2\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // Returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (char c : s) {\n        // Check if the character is a lowercase letter\n        if (c >= 'a' && c <= 'z') {\n            char shifted = (c - 'a' + 5) % 26 + 'a';\n            out += shifted;\n        } else {\n            // If it's not a lowercase letter, keep it unchanged\n            out += c;\n        }\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // Takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (char c : s) {\n        // Check if the character is a lowercase letter\n        if (c >= 'a' && c <= 'z') {\n            char shifted = (c - 'a' - 5 + 26) % 26 + 'a'; // +26 to handle negative values\n            out += shifted;\n        } else {\n            // If it's not a lowercase letter, keep it unchanged\n            out += c;\n        }\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        // Check if the character is a vowel (both lowercase and uppercase)\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n            c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            result += c; // Append non-vowel characters to result\n        }\n    }\n    return result; // Return the string without vowels\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false; // If any number is not below the threshold, return false\n        }\n    }\n    return true; // All numbers are below the threshold\n}\n\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to add two numbers\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    unordered_set<char> set0(s0.begin(), s0.end());\n    unordered_set<char> set1(s1.begin(), s1.end());\n    \n    return set0 == set1; // Compare the two sets\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) return 0; // Handle the case for n = 0\n    if (n == 1) return 1; // Base case for n = 1\n\n    int a = 0; // F(0)\n    int b = 1; // F(1)\n    int c; // To store the current Fibonacci number\n\n    for (int i = 2; i <= n; i++) {\n        c = a + b; // F(n) = F(n-1) + F(n-2)\n        a = b; // Move to the next Fibonacci number\n        b = c; // Update b to the current Fibonacci number\n    }\n\n    return c; // Return the n-th Fibonacci number\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int count = 0; // Initialize a counter for opening brackets\n\n    for (char ch : brackets) {\n        if (ch == '<') {\n            count++; // Increment for an opening bracket\n        } else if (ch == '>') {\n            count--; // Decrement for a closing bracket\n        }\n\n        // If count goes negative, we have more closing brackets than opening\n        if (count < 0) {\n            return false;\n        }\n    }\n\n    // At the end, count should be zero if all brackets are matched\n    return count == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() < 2) return true; // A vector with less than 2 elements is considered monotonic\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); i++) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false; // Found an increasing pair\n        } else if (l[i] < l[i - 1]) {\n            increasing = false; // Found a decreasing pair\n        }\n    }\n\n    return increasing || decreasing; // Return true if either increasing or decreasing\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Use a set to store unique elements from both vectors\n    set<int> set1(l1.begin(), l1.end());\n    set<int> set2(l2.begin(), l2.end());\n    \n    // Vector to store the common elements\n    vector<int> commonElements;\n\n    // Use set_intersection to find common elements\n    set_intersection(set1.begin(), set1.end(),\n                     set2.begin(), set2.end(),\n                     back_inserter(commonElements));\n\n    // Return the sorted unique common elements\n    return commonElements;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int largest_factor = -1;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        largest_factor = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest_factor = i;\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        largest_factor = n;\n    }\n\n    return largest_factor;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    int sum = 0; // Initialize sum to 0\n    for (int i = 1; i <= n; i++) { // Loop from 1 to n\n        sum += i; // Add each number to sum\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // This will keep track of the balance of brackets\n\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++; // Increment for an opening bracket\n        } else if (ch == ')') {\n            balance--; // Decrement for a closing bracket\n        }\n\n        // If balance goes negative, it means there's a closing bracket without a matching opening bracket\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // At the end, balance should be zero if all opening brackets have been matched\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    int n = xs.size();\n    \n    // Start from the first coefficient (which corresponds to x^1)\n    for (int i = 1; i < n; i++) {\n        // The derivative of xs[i] * x^i is i * xs[i]\n        result.push_back(i * xs[i]);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    // Handle base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Initialize an array to store the FibFib numbers\n    int fibfibArr[n + 1];\n    fibfibArr[0] = 0;\n    fibfibArr[1] = 0;\n    fibfibArr[2] = 1;\n\n    // Compute the FibFib numbers iteratively\n    for (int i = 3; i <= n; i++) {\n        fibfibArr[i] = fibfibArr[i - 1] + fibfibArr[i - 2] + fibfibArr[i - 3];\n    }\n\n    return fibfibArr[n];\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    int length = s.length();\n\n    for (int i = 0; i < length; i++) {\n        char c = tolower(s[i]); // Convert character to lowercase for uniformity\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n\n    // Check if the last character is 'y' (case insensitive)\n    if (length > 0 && tolower(s[length - 1]) == 'y') {\n        count++;\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string\n    string str = to_string(x);\n    int n = str.length(); // Number of digits\n\n    // Calculate effective shift\n    shift = shift % n;\n\n    // If shift is 0, return the original string\n    if (shift == 0) {\n        return str;\n    }\n\n    // If shift is equal to the number of digits, return the reversed string\n    if (shift == n) {\n        return string(str.rbegin(), str.rend());\n    }\n\n    // Perform the circular shift\n    string shifted = str.substr(n - shift) + str.substr(0, n - shift);\n    return shifted;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0; // Initialize sum to 0\n    for (char c : s) { // Iterate through each character in the string\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add the ASCII value of the uppercase character to sum\n        }\n    }\n    return sum; // Return the final sum\n}\n\n// Example usage\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0, oranges = 0;\n\n    // Use a stringstream to parse the input string\n    stringstream ss(s);\n    string word;\n\n    // Read the number of apples\n    ss >> apples; // Read the first number (apples)\n    ss >> word;   // Read the word \"apples\"\n    ss >> oranges; // Read the second number (oranges)\n    ss >> word;   // Read the word \"oranges\"\n\n    // Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n\n    return mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int smallest_even_value = -1; // Initialize to -1 to indicate no even number found\n    int smallest_even_index = -1; // Initialize to -1 for the same reason\n\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            if (smallest_even_value == -1 || arr[i] < smallest_even_value) {\n                smallest_even_value = arr[i];\n                smallest_even_index = i;\n            }\n        }\n    }\n\n    // If we found an even number, return it along with its index\n    if (smallest_even_index != -1) {\n        return {smallest_even_value, smallest_even_index};\n    } else {\n        return {}; // Return an empty vector if no even number was found\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequencyMap;\n\n    // Count the frequency of each integer in the vector\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    int result = -1;\n\n    // Check for the greatest integer that meets the condition\n    for (const auto& entry : frequencyMap) {\n        int value = entry.first;\n        int frequency = entry.second;\n\n        // Check if the frequency is greater than or equal to the value\n        if (frequency >= value) {\n            result = max(result, value);\n        }\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/70", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the input list\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int left = 0; // Pointer for the minimum values\n    int right = lst.size() - 1; // Pointer for the maximum values\n    \n    // Alternate between minimum and maximum\n    while (left <= right) {\n        if (left == right) {\n            result.push_back(lst[left]); // If both pointers meet, add the last element\n        } else {\n            result.push_back(lst[left]); // Add the minimum\n            result.push_back(lst[right]); // Add the maximum\n        }\n        left++;\n        right--;\n    }\n    \n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check for a valid triangle using the triangle inequality theorem\n    if (a + b > c && a + c > b && b + c > a) {\n        // Calculate the semi-perimeter\n        float s = (a + b + c) / 2;\n        \n        // Calculate the area using Heron's formula\n        float area = sqrt(s * (s - a) * (s - b) * (s - c));\n        \n        // Return the area rounded to 2 decimal points\n        return round(area * 100) / 100; // Rounding to 2 decimal points\n    } else {\n        // Return -1 if the sides do not form a valid triangle\n        return -1;\n    }\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool is_palindrome(const vector<int>& q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false; // Not a palindrome\n        }\n    }\n    return true; // Is a palindrome\n}\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is a palindrome\n    if (!is_palindrome(q)) {\n        return false; // Not balanced\n    }\n    \n    // Calculate the sum of the elements\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    \n    // Check if the sum is less than or equal to the maximum weight\n    return sum <= w;\n}\n\n// Example usage\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    // Use two pointers to compare elements from the start and end\n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++; // Increment changes for each mismatch\n        }\n    }\n\n    return changes; // Return the total number of changes needed\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Function to calculate total number of characters in a vector of strings\n    auto total_chars = [](const vector<string>& lst) {\n        int total = 0;\n        for (const string& str : lst) {\n            total += str.size();\n        }\n        return total;\n    };\n\n    // Calculate total characters for both vectors\n    int total1 = total_chars(lst1);\n    int total2 = total_chars(lst2);\n\n    // Compare totals and return the appropriate vector\n    if (total1 < total2) {\n        return lst1;\n    } else {\n        return lst2; // This includes the case where totals are equal\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a list of prime numbers less than 100\nvector<int> generate_primes() {\n    vector<int> primes;\n    for (int i = 2; i < 100; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to check if the given number is the product of three prime numbers\nbool is_multiply_prime(int a) {\n    vector<int> primes = generate_primes();\n    int size = primes.size();\n\n    // Check all combinations of three primes\n    for (int i = 0; i < size; i++) {\n        for (int j = 0; j < size; j++) {\n            for (int k = 0; k < size; k++) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    // Handle special cases\n    if (n <= 1) {\n        return (n == 1 && x == 1); // 1^k = 1 for any k, and 0^k is not defined\n    }\n    if (x < 1) {\n        return false; // x must be a positive integer\n    }\n    \n    int power = 1; // Start with n^0\n    while (power < x) {\n        power *= n; // Calculate n^k\n    }\n    \n    return power == x; // Check if we found a match\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool iscube(int a) {\n    // Calculate the cube root of the absolute value of a\n    int cubeRoot = round(pow(abs(a), 1.0 / 3.0));\n    \n    // Check if the cube of the rounded cube root equals a\n    return (cubeRoot * cubeRoot * cubeRoot == a) || (-cubeRoot * -cubeRoot * -cubeRoot == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint hex_key(string num) {\n    // Set of prime hexadecimal digits\n    const string primeHexDigits = \"2357BD\"; // B and D are included as they represent 11 and 13 respectively\n    int count = 0;\n\n    // Iterate through each character in the input string\n    for (char c : num) {\n        // Check if the character is in the set of prime hexadecimal digits\n        if (primeHexDigits.find(c) != string::npos) {\n            count++; // Increment count if it's a prime digit\n        }\n    }\n\n    return count; // Return the total count of prime hexadecimal digits\n}\n\n// Example usage\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Handle the case for 0 explicitly\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    string binary = \"\";\n    \n    // Convert decimal to binary\n    while (decimal > 0) {\n        // Prepend the remainder (0 or 1) to the binary string\n        binary = to_string(decimal % 2) + binary;\n        decimal /= 2; // Divide the number by 2\n    }\n\n    // Add \"db\" at the beginning and end\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is at least 3\n    if (s.length() < 3) {\n        return false;\n    }\n    \n    // Iterate through the string and check every 3 consecutive characters\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        // Check if the three characters are distinct\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    \n    // If all checks passed, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letterGrades;\n\n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letterGrades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letterGrades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letterGrades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letterGrades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letterGrades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letterGrades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letterGrades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letterGrades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letterGrades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letterGrades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letterGrades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letterGrades.push_back(\"D-\");\n        } else {\n            letterGrades.push_back(\"E\");\n        }\n    }\n\n    return letterGrades;\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) { // Check for factors up to the square root of n\n        if (n % i == 0) return false; // If n is divisible by i, it's not prime\n    }\n    return true; // n is prime\n}\n\nbool prime_length(string str) {\n    int length = str.length(); // Get the length of the string\n    return is_prime(length); // Check if the length is prime\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        // For 1-digit numbers, only '1' is valid\n        return 1;\n    }\n\n    // Count of n-digit numbers that start with '1'\n    long long start_with_1 = pow(10, n - 1);\n    \n    // Count of n-digit numbers that end with '1'\n    long long end_with_1 = 9 * pow(10, n - 2);\n    \n    // Count of n-digit numbers that start and end with '1'\n    long long start_and_end_with_1 = pow(10, n - 2);\n    \n    // Total count using inclusion-exclusion principle\n    long long total_count = start_with_1 + end_with_1 - start_and_end_with_1;\n    \n    return total_count;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\n#include <bitset>\n\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n\n    // Calculate the sum of digits\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to sum\n        N /= 10;       // Remove the last digit\n    }\n\n    // Convert the sum to binary\n    return bitset<32>(sum).to_string().substr(32 - (sum == 0 ? 1 : (int)log2(sum) + 1));\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    // Loop through the vector\n    for (int i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2 (odd indices)\n        if (lst[i] % 2 == 0) { // Check if the element is even\n            sum += lst[i]; // Add to sum if it's even\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <sstream>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result;\n    stringstream ss(s);\n    string word;\n\n    // Process each word in the string\n    while (ss >> word) {\n        // Sort the characters of the word\n        sort(word.begin(), word.end());\n        result += word + \" \"; // Add sorted word followed by a space\n    }\n\n    // Remove the trailing space if there is one\n    if (!result.empty()) {\n        result.pop_back();\n    }\n\n    // Now we need to handle the spaces in the original string\n    size_t pos = 0;\n    string final_result;\n    for (char c : s) {\n        if (c == ' ') {\n            final_result += ' '; // Preserve spaces\n        } else {\n            // Add the next sorted word character\n            if (pos < result.length()) {\n                final_result += result[pos++];\n                // Move to the next word if we reach the end of the current word\n                while (pos < result.length() && result[pos] != ' ') {\n                    pos++;\n                }\n                // Skip the space in the sorted result\n                if (pos < result.length()) {\n                    pos++;\n                }\n            }\n        }\n    }\n\n    return final_result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n\n    // Iterate through each row\n    for (int i = 0; i < lst.size(); ++i) {\n        // Iterate through each column in the current row\n        for (int j = 0; j < lst[i].size(); ++j) {\n            // Check if the current element matches x\n            if (lst[i][j] == x) {\n                // Store the coordinates {row, column}\n                result.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort the result by row (ascending) and then by column (descending)\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort by column in descending order\n        }\n        return a[0] < b[0]; // Sort by row in ascending order\n    });\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/88", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(const vector<int>& array) {\n    // Step 1: Check if the vector is empty\n    if (array.empty()) {\n        return {};\n    }\n    \n    // Step 2: If the vector has only one element, return a copy of that vector\n    if (array.size() == 1) {\n        return array;\n    }\n    \n    // Step 3: Calculate the sum of the first and last elements\n    int sum = array.front() + array.back();\n    \n    // Step 4: Create a copy of the original array to sort\n    vector<int> sorted_array = array;\n    \n    // Step 5: Sort based on the sum\n    if (sum % 2 == 0) {\n        // Even sum: sort in descending order\n        sort(sorted_array.rbegin(), sorted_array.rend());\n    } else {\n        // Odd sum: sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n    \n    // Step 6: Return the sorted vector\n    return sorted_array;\n}\n\n// Example usage\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string encrypted = \"\";\n    \n    for (char c : s) {\n        // Check if the character is a lowercase letter\n        if (c >= 'a' && c <= 'z') {\n            // Rotate the character by 4 positions\n            char newChar = c + 4;\n            // Wrap around if it goes past 'z'\n            if (newChar > 'z') {\n                newChar -= 26; // Wrap around\n            }\n            encrypted += newChar;\n        } else {\n            // If it's not a lowercase letter, just append it as is\n            encrypted += c;\n        }\n    }\n    \n    return encrypted;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    // Use a set to remove duplicates\n    set<int> unique_elements(lst.begin(), lst.end());\n    \n    // If there are less than 2 unique elements, return -1\n    if (unique_elements.size() < 2) {\n        return -1; // Indicating that there is no second smallest\n    }\n    \n    // Convert the set back to a vector\n    vector<int> sorted_unique(unique_elements.begin(), unique_elements.end());\n    \n    // Return the second smallest element\n    return sorted_unique[1];\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <cctype>\n\nusing namespace std;\n\nint is_bored(string S) {\n    // Define the delimiters\n    const string delimiters = \".!?\";\n    int boredom_count = 0;\n\n    // Create a string stream from the input string\n    stringstream ss(S);\n    string sentence;\n\n    // Read each sentence until the end of the string\n    while (getline(ss, sentence, '.')) {\n        // Check for other delimiters\n        size_t pos = sentence.find_first_of(\"!?\");\n        if (pos != string::npos) {\n            sentence = sentence.substr(0, pos);\n        }\n\n        // Trim leading whitespace\n        size_t start = sentence.find_first_not_of(\" \\t\");\n        if (start != string::npos) {\n            sentence = sentence.substr(start);\n        }\n\n        // Check if the sentence starts with \"I\"\n        if (sentence == \"I\" || (sentence.size() > 1 && sentence[0] == 'I' && isspace(sentence[1]))) {\n            boredom_count++;\n        }\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n    \n    // Check if one number is equal to the sum of the other two\n    return (a == b + c) || (b == a + c) || (c == a + b);\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstring encode(string message) {\n    string encodedMessage = \"\";\n\n    for (char ch : message) {\n        // Swap case\n        if (isupper(ch)) {\n            ch = tolower(ch);\n        } else if (islower(ch)) {\n            ch = toupper(ch);\n        }\n\n        // Replace vowels\n        switch (ch) {\n            case 'a': ch = 'c'; break;\n            case 'e': ch = 'g'; break;\n            case 'i': ch = 'k'; break;\n            case 'o': ch = 'q'; break;\n            case 'u': ch = 'w'; break;\n            case 'A': ch = 'C'; break;\n            case 'E': ch = 'G'; break;\n            case 'I': ch = 'K'; break;\n            case 'O': ch = 'Q'; break;\n            case 'U': ch = 'W'; break;\n            default: break; // Do nothing for non-vowel characters\n        }\n\n        encodedMessage += ch; // Append the modified character to the result\n    }\n\n    return encodedMessage;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10; // Add the last digit\n        num /= 10; // Remove the last digit\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and return the sum of its digits\nint largestPrimeSumOfDigits(const vector<int>& lst) {\n    int largestPrime = -1; // Initialize to -1 to indicate no prime found\n\n    // Iterate through the list to find the largest prime\n    for (int num : lst) {\n        if (isPrime(num) && num > largestPrime) {\n            largestPrime = num; // Update largest prime found\n        }\n    }\n\n    // If no prime was found, return 0 (or handle as needed)\n    if (largestPrime == -1) return 0;\n\n    // Return the sum of the digits of the largest prime\n    return sumOfDigits(largestPrime);\n}\n\n// Main function\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <cctype> // for islower and isupper\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool allLower = true;\n    bool allUpper = true;\n\n    // Iterate through each key in the map\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        // Check if the key is a valid string (it is, since we are using map<string, string>)\n        // Check if the key is lower case or upper case\n        if (islower(key[0])) {\n            allUpper = false; // If any key is lower case, set allUpper to false\n        } else if (isupper(key[0])) {\n            allLower = false; // If any key is upper case, set allLower to false\n        } else {\n            return false; // If the key is neither lower nor upper case, return false\n        }\n\n        // Check the rest of the characters in the key\n        for (size_t i = 1; i < key.size(); ++i) {\n            if (islower(key[i])) {\n                allUpper = false;\n            } else if (isupper(key[i])) {\n                allLower = false;\n            } else {\n                return false; // If any character is not a letter, return false\n            }\n        }\n    }\n\n    // Return true if all keys are either all lower case or all upper case\n    return allLower || allUpper;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to return a vector of prime numbers less than n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i); // Add prime number to the vector\n        }\n    }\n    return primes; // Return the vector of prime numbers\n}\n\n// Example usage\n"}
{"task_id": "CPP/97", "generation": "#include <stdio.h>\n\nint multiply(int a, int b) {\n    // Get the unit digits\n    int unitDigitA = abs(a) % 10; // Use abs to handle negative numbers\n    int unitDigitB = abs(b) % 10; // Use abs to handle negative numbers\n    \n    // Calculate the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n\n// Example usage\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    // Loop through the string, checking only even indices\n    for (int i = 0; i < s.length(); i += 2) {\n        // Check if the character is an uppercase vowel\n        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert the string to a double\n    double num = stod(value);\n    \n    // Use the floor and ceil functions to find the two closest integers\n    int lower = static_cast<int>(floor(num));\n    int upper = static_cast<int>(ceil(num));\n    \n    // Check if the number is equidistant from lower and upper\n    if (num - lower == 0.5) {\n        // If it's equidistant and positive, round up\n        return upper;\n    } else if (num - lower == -0.5) {\n        // If it's equidistant and negative, round down\n        return lower;\n    } else {\n        // Otherwise, round normally\n        return static_cast<int>(round(num));\n    }\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    int current_stones = n; // Start with n stones for the first level\n\n    for (int i = 0; i < n; ++i) {\n        stones.push_back(current_stones); // Add the current level's stones to the vector\n        // Determine the next number of stones based on whether n is odd or even\n        if (n % 2 == 0) {\n            // n is even, so the next number should be the next even number\n            current_stones += 2; // Increment by 2 to get the next even number\n        } else {\n            // n is odd, so the next number should be the next odd number\n            current_stones += 2; // Increment by 2 to get the next odd number\n        }\n    }\n\n    return stones; // Return the vector containing the number of stones in each level\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    stringstream ss(s);\n    string word;\n\n    // Replace commas with spaces to simplify splitting\n    for (char &c : s) {\n        if (c == ',') {\n            c = ' ';\n        }\n    }\n\n    // Extract words from the stringstream\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    return words;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Check if the range is valid\n    if (x > y) {\n        return -1;\n    }\n    \n    // If y is even, return y\n    if (y % 2 == 0) {\n        return y;\n    } else {\n        // If y is odd, return y - 1\n        if (y - 1 >= x) {\n            return y - 1;\n        } else {\n            return -1; // No even number in the range\n        }\n    }\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    int count = m - n + 1; // Number of integers from n to m\n    int sum = (count * (n + m)) / 2; // Sum of the integers\n    int average = sum / count; // Average\n\n    // Round down the average\n    int rounded_average = floor(average);\n\n    // Convert the rounded average to binary\n    string binary = \"\";\n    if (rounded_average == 0) {\n        binary = \"0\";\n    } else {\n        while (rounded_average > 0) {\n            binary = to_string(rounded_average % 2) + binary;\n            rounded_average /= 2;\n        }\n    }\n\n    return binary;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to check if a number contains any even digits\nbool has_even_digit(int num) {\n    while (num > 0) {\n        int digit = num % 10; // Get the last digit\n        if (digit % 2 == 0) { // Check if the digit is even\n            return true; // Found an even digit\n        }\n        num /= 10; // Remove the last digit\n    }\n    return false; // No even digits found\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    // Iterate through the input vector\n    for (int num : x) {\n        // If the number does not have any even digits, add it to the result\n        if (!has_even_digit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    // Sort the result vector in increasing order\n    sort(result.begin(), result.end());\n\n    return result;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Step 1: Filter the vector to keep only integers between 1 and 9\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Step 2: Sort the filtered vector\n    sort(filtered.begin(), filtered.end());\n\n    // Step 3: Reverse the sorted vector\n    reverse(filtered.begin(), filtered.end());\n\n    // Step 4: Map integers to their corresponding names\n    vector<string> result;\n    vector<string> names = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    \n    for (int num : filtered) {\n        result.push_back(names[num - 1]); // num - 1 to get the correct index\n    }\n\n    // Step 5: Return the resulting vector of strings\n    return result;\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n); // Create a vector of size n\n\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) { // Check if i is even\n            // Calculate factorial of i\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial; // Store the factorial in the vector\n        } else { // i is odd\n            // Calculate the sum of numbers from 1 to i\n            int sum = (i * (i + 1)) / 2; // Using the formula for the sum of first i natural numbers\n            result[i - 1] = sum; // Store the sum in the vector\n        }\n    }\n\n    return result; // Return the resulting vector\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is a palindrome\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    string revStr = string(str.rbegin(), str.rend());\n    return str == revStr;\n}\n\n// Function to count even and odd palindromes\nvector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n\n    return {evenCount, oddCount};\n}\n\n// Example usage\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = abs(num); // Work with the absolute value for digit extraction\n\n    // Calculate the sum of digits\n    while (num > 0) {\n        sum += num % 10; // Add the last digit\n        num /= 10;       // Remove the last digit\n    }\n\n    // If the original number was negative, subtract twice the first digit\n    if (is_negative) {\n        // Get the first digit of the original number\n        int first_digit = abs(num);\n        while (first_digit >= 10) {\n            first_digit /= 10;\n        }\n        sum -= 2 * first_digit; // Adjust the sum for the signed first digit\n    }\n\n    return sum;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/109", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return true; // An empty vector is considered sorted.\n\n    int count = 0; // To count the number of breaks in order.\n    \n    for (int i = 0; i < n; i++) {\n        // Check if the current element is greater than the next element\n        if (arr[i] > arr[(i + 1) % n]) {\n            count++;\n        }\n    }\n    \n    // If there is more than one break, we cannot sort the array by shifts\n    return count <= 1;\n}\n\n// Example usage\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount = 0;\n    int evenCountInLst2 = 0;\n\n    // Count odd numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount++;\n        }\n    }\n\n    // Count even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCountInLst2++;\n        }\n    }\n\n    // If there are no odd numbers in lst1, it's already valid\n    if (oddCount == 0) {\n        return \"YES\";\n    }\n\n    // Check if lst2 has enough even numbers to replace odd numbers in lst1\n    if (evenCountInLst2 >= oddCount) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nmap<string, int> histogram(string test) {\n    map<char, int> countMap;\n    map<string, int> resultMap;\n\n    // Split the string into characters\n    stringstream ss(test);\n    string word;\n    while (ss >> word) {\n        for (char c : word) {\n            countMap[c]++;\n        }\n    }\n\n    // Find the maximum count\n    int maxCount = 0;\n    for (const auto& pair : countMap) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Collect all characters with the maximum count\n    for (const auto& pair : countMap) {\n        if (pair.second == maxCount) {\n            resultMap[string(1, pair.first)] = pair.second;\n        }\n    }\n\n    return resultMap;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_set>\n\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Create a set of characters to delete for faster lookup\n    unordered_set<char> charsToDelete(c.begin(), c.end());\n    \n    // Create a new string to store the result after deletion\n    string result;\n    \n    // Iterate through the original string and build the result\n    for (char ch : s) {\n        if (charsToDelete.find(ch) == charsToDelete.end()) {\n            result += ch; // Add character to result if it's not in charsToDelete\n        }\n    }\n    \n    // Check if the result string is a palindrome\n    string reversedResult = result;\n    reverse(reversedResult.begin(), reversedResult.end());\n    bool isPalindrome = (result == reversedResult);\n    \n    // Prepare the output vector\n    vector<string> output;\n    output.push_back(result);\n    output.push_back(isPalindrome ? \"True\" : \"False\");\n    \n    return output;\n}\n\n// Example usage\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n\n    for (int i = 0; i < lst.size(); ++i) {\n        string str = lst[i];\n        int odd_count = 0;\n\n        // Count the odd digits in the current string\n        for (char ch : str) {\n            if (ch % 2 != 0) { // Check if the digit is odd\n                odd_count++;\n            }\n        }\n\n        // Create the formatted output string\n        string formatted_string = \"the number of odd elements \" + to_string(odd_count) +\n                                  \"n the str\" + to_string(i + 1) + \n                                  \"ng \" + to_string(i + 1) + \n                                  \" of the \" + to_string(i + 1) + \n                                  \"nput.\";\n        result.push_back(formatted_string);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\n#include <limits.h> // For INT_MAX\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long minSum = LLONG_MAX; // Initialize to maximum possible value\n    long long currentSum = 0; // To keep track of the current subarray sum\n\n    for (long long num : nums) {\n        currentSum += num; // Add the current number to the current sum\n        if (currentSum < minSum) {\n            minSum = currentSum; // Update minSum if currentSum is smaller\n        }\n        if (currentSum > 0) {\n            currentSum = 0; // Reset currentSum if it becomes positive\n        }\n    }\n\n    return minSum; // Return the minimum sum found\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_times = 0;\n\n    // Iterate through each well (row)\n    for (const auto& well : grid) {\n        int units_of_water = 0;\n\n        // Count the number of 1s in the current well (row)\n        for (int water : well) {\n            if (water == 1) {\n                units_of_water++;\n            }\n        }\n\n        // Calculate the number of times we need to lower the bucket for this well\n        if (units_of_water > 0) {\n            total_times += (units_of_water + capacity - 1) / capacity; // This is equivalent to ceil(units_of_water / capacity)\n        }\n    }\n\n    return total_times;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to count the number of 1's in the binary representation of a number\nint countOnes(int n) {\n    int count = 0;\n    while (n) {\n        count += n & 1; // Increment count if the last bit is 1\n        n >>= 1; // Right shift the number\n    }\n    return count;\n}\n\n// Custom comparator for sorting\nbool customComparator(int a, int b) {\n    int onesA = countOnes(a);\n    int onesB = countOnes(b);\n    \n    // First compare by number of 1's\n    if (onesA != onesB) {\n        return onesA < onesB;\n    }\n    // If they have the same number of 1's, compare by value\n    return a < b;\n}\n\nvector<int> sort_array(vector<int> arr) {\n    sort(arr.begin(), arr.end(), customComparator);\n    return arr;\n}\n\n// Example usage\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\n// Function to count consonants in a word\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char ch : word) {\n        // Check if the character is a letter and not a vowel\n        if (isalpha(ch) && !strchr(\"aeiouAEIOU\", ch)) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Main function to select words with exactly n consonants\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    // Split the string into words\n    while (ss >> word) {\n        // Count consonants in the current word\n        int consonant_count = count_consonants(word);\n        // If the count matches n, add the word to the result\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha and islower\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    // Define the set of vowels\n    string vowels = \"aeiouAEIOU\";\n    \n    // Length of the word\n    int n = word.length();\n    \n    // We need at least 3 characters to have a vowel between two consonants\n    if (n < 3) {\n        return \"\";\n    }\n    \n    // Iterate from the end of the string\n    for (int i = n - 2; i > 0; i--) { // Start from n-2 to avoid the last character and end at 1 to avoid the first character\n        if (isalpha(word[i])) { // Check if the character is an alphabet\n            if (vowels.find(word[i]) != string::npos) { // Check if it's a vowel\n                // Check if the characters before and after are consonants\n                if (isalpha(word[i - 1]) && isalpha(word[i + 1]) && \n                    vowels.find(word[i - 1]) == string::npos && \n                    vowels.find(word[i + 1]) == string::npos) {\n                    return string(1, word[i]); // Return the vowel found\n                }\n            }\n        }\n    }\n    \n    // If no vowel found, return an empty string\n    return \"\";\n}\n\n// Example usage\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0];\n    string s2 = lst[1];\n\n    // Function to check if a string can be a prefix of a balanced string\n    auto canBeBalanced = [](const string& s1, const string& s2) {\n        int open = 0, close = 0;\n\n        // Check the first string\n        for (char c : s1) {\n            if (c == '(') {\n                open++;\n            } else {\n                close++;\n            }\n            // At any point, close should not exceed open\n            if (close > open) {\n                return false;\n            }\n        }\n\n        // Now check the second string\n        for (char c : s2) {\n            if (c == '(') {\n                open++;\n            } else {\n                close++;\n            }\n            // At any point, close should not exceed open\n            if (close > open) {\n                return false;\n            }\n        }\n\n        // Finally, check if total open and close are equal\n        return open == close;\n    };\n\n    // Check both concatenation orders\n    if (canBeBalanced(s1, s2) || canBeBalanced(s2, s1)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Step 2: Select the first k elements\n    vector<int> max_k_elements(arr.begin(), arr.begin() + k);\n    \n    // Step 3: Sort the k elements in ascending order\n    sort(max_k_elements.begin(), max_k_elements.end());\n    \n    return max_k_elements;\n}\n\n// Example usage\n"}
{"task_id": "CPP/121", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (size_t i = 0; i < lst.size(); i++) {\n        // Check if the index is even and the element is odd\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i]; // Add the element to sum\n        }\n    }\n    return sum; // Return the total sum\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0; // Initialize sum to 0\n    // Iterate through the first k elements\n    for (int i = 0; i < k; i++) {\n        // Check if the element has at most two digits\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i]; // Add to sum if condition is met\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    set<int> odd_numbers; // Use a set to avoid duplicates\n    while (n != 1) {\n        if (n % 2 != 0) { // Check if n is odd\n            odd_numbers.insert(n); // Insert odd number into the set\n        }\n        // Apply the Collatz rules\n        if (n % 2 == 0) {\n            n /= 2; // n is even\n        } else {\n            n = 3 * n + 1; // n is odd\n        }\n    }\n    // Don't forget to include 1, which is always part of the sequence\n    odd_numbers.insert(1);\n\n    // Convert set to vector\n    vector<int> result(odd_numbers.begin(), odd_numbers.end());\n    sort(result.begin(), result.end()); // Sort the vector (though set is already sorted)\n    return result;\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) {\n        return false;\n    }\n\n    // Check if the date is in the format mm-dd-yyyy\n    if (date.size() != 10 || date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n\n    // Extract month, day, and year\n    int month, day, year;\n    stringstream ss(date);\n    string monthStr, dayStr, yearStr;\n\n    getline(ss, monthStr, '-');\n    getline(ss, dayStr, '-');\n    getline(ss, yearStr);\n\n    // Convert strings to integers\n    month = stoi(monthStr);\n    day = stoi(dayStr);\n    year = stoi(yearStr);\n\n    // Check if month is valid\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    // Check days based on the month\n    if (month == 2) {\n        // February: check for leap year\n        if (day < 1 || day > 29) {\n            return false;\n        }\n        // Leap year check\n        if (day == 29) {\n            if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {\n                return true; // valid leap year date\n            } else {\n                return false; // invalid leap year date\n            }\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        // Months with 30 days\n        if (day < 1 || day > 30) {\n            return false;\n        }\n    } else {\n        // Months with 31 days\n        if (day < 1 || day > 31) {\n            return false;\n        }\n    }\n\n    // If all checks passed, the date is valid\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    // Check for whitespace\n    size_t pos = txt.find_first_of(\" \\t\\n\");\n    if (pos != string::npos) {\n        // Split by whitespace\n        vector<string> result;\n        stringstream ss(txt);\n        string word;\n        while (ss >> word) {\n            result.push_back(word);\n        }\n        return result;\n    }\n\n    // Check for commas\n    pos = txt.find(',');\n    if (pos != string::npos) {\n        // Split by commas\n        vector<string> result;\n        stringstream ss(txt);\n        string word;\n        while (getline(ss, word, ',')) {\n            result.push_back(word);\n        }\n        return result;\n    }\n\n    // Count lowercase letters with odd order in the alphabet\n    int count = 0;\n    for (char c : txt) {\n        if (islower(c)) {\n            int index = c - 'a'; // Get the index (0 for 'a', 1 for 'b', ...)\n            if (index % 2 == 1) { // Check if the index is odd\n                count++;\n            }\n        }\n    }\n\n    // Return the count as a string in a vector\n    return {to_string(count)};\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check for the sorted condition and count occurrences\n    unordered_map<int, int> countMap;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Count occurrences of each number\n        countMap[lst[i]]++;\n        \n        // If any number appears more than twice, return false\n        if (countMap[lst[i]] > 2) {\n            return false;\n        }\n        \n        // Check if the current number is less than the previous number\n        if (i > 0 && lst[i] < lst[i - 1]) {\n            return false;\n        }\n    }\n    \n    // If we pass both checks, return true\n    return true;\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to find the intersection of two intervals and check if its length is prime\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n\n    // Calculate the intersection\n    int start_intersection = max(start1, start2);\n    int end_intersection = min(end1, end2);\n\n    // Calculate the length of the intersection\n    int length = 0;\n    if (start_intersection <= end_intersection) {\n        length = end_intersection - start_intersection + 1; // +1 because intervals are closed\n    }\n\n    // Check if the length is prime\n    if (length > 0 && isPrime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/128", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768; // Return -32768 for empty array\n    }\n\n    int sign_product = 1; // Start with a neutral product\n    int magnitude_sum = 0; // Initialize sum of magnitudes\n\n    for (int num : arr) {\n        if (num > 0) {\n            // Positive number\n            magnitude_sum += num; // Add to magnitude sum\n        } else if (num < 0) {\n            // Negative number\n            magnitude_sum += -num; // Add absolute value to magnitude sum\n            sign_product *= -1; // Flip sign product\n        } else {\n            // Zero encountered\n            return 0; // If there's a zero, return 0 immediately\n        }\n    }\n\n    return sign_product * magnitude_sum; // Return the product of signs and sum of magnitudes\n}\n\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid dfs(const vector<vector<int>>& grid, int x, int y, vector<int>& currentPath, vector<int>& minPath, int k) {\n    // If we have reached the desired path length\n    if (currentPath.size() == k) {\n        if (minPath.empty() || currentPath < minPath) {\n            minPath = currentPath; // Update the minimum path\n        }\n        return;\n    }\n\n    // Directions for moving up, down, left, right\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    // Explore all four directions\n    for (const auto& dir : directions) {\n        int newX = x + dir.first;\n        int newY = y + dir.second;\n\n        // Check if the new position is within bounds\n        if (newX >= 0 && newX < grid.size() && newY >= 0 && newY < grid[0].size()) {\n            currentPath.push_back(grid[newX][newY]); // Add the new cell value to the path\n            dfs(grid, newX, newY, currentPath, minPath, k); // Recur\n            currentPath.pop_back(); // Backtrack\n        }\n    }\n}\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    vector<int> minPath; // To store the minimum path found\n    int N = grid.size();\n\n    // Try starting from each cell in the grid\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            vector<int> currentPath = {grid[i][j]}; // Start path with the current cell\n            dfs(grid, i, j, currentPath, minPath, k); // Start DFS\n        }\n    }\n\n    return minPath; // Return the minimum path found\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> result(n + 1); // Create a vector to hold the results\n\n    // Base case\n    if (n >= 0) result[0] = 3; // tri(1) = 3\n    if (n >= 1) result[1] = 1 + (1 / 2); // tri(2) = 1 + (2 / 2) = 2\n    if (n >= 2) result[2] = 2; // tri(2) = 2\n\n    // Calculate the rest of the values\n    for (int i = 3; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result[i] = 1 + (i / 2); // If n is even\n        } else {\n            // If n is odd, calculate tri(n) using tri(n - 1), tri(n - 2), and tri(n + 1)\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n\n    return result; // Return the vector containing the Tribonacci sequence\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <stdio.h>\n#include <string>\n\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool foundOdd = false;\n\n    // Convert the integer to a string to iterate over each digit\n    string str = to_string(n);\n    \n    for (char c : str) {\n        int digit = c - '0'; // Convert character to integer\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit;\n            foundOdd = true; // Mark that we found at least one odd digit\n        }\n    }\n\n    // If no odd digits were found, return 0\n    return foundOdd ? product : 0;\n}\n\n// Example usage\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int openCount = 0; // Count of opening brackets\n    int closeCount = 0; // Count of closing brackets\n\n    // Iterate through the string to count brackets\n    for (char ch : str) {\n        if (ch == '[') {\n            openCount++;\n        } else if (ch == ']') {\n            closeCount++;\n        }\n\n        // If at any point closeCount exceeds openCount, it's invalid\n        if (closeCount > openCount) {\n            return false;\n        }\n    }\n\n    // To have a nested structure, we need at least two opening brackets\n    // and at least one closing bracket\n    return openCount >= 2 && closeCount >= 1 && openCount == closeCount;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int rounded = ceil(num);  // Round up to the nearest integer\n        sum += rounded * rounded;  // Square the rounded value and add to sum\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha function\n\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Trim trailing spaces\n    size_t end = txt.find_last_not_of(' ');\n    if (end == string::npos) {\n        return false; // The string is empty or consists only of spaces\n    }\n\n    // Get the last character\n    char lastChar = txt[end];\n\n    // Check if the last character is an alphabetical character\n    if (isalpha(lastChar)) {\n        // Check if it is not part of a word (i.e., the last character is not preceded by any non-space character)\n        if (end == 0 || txt[end - 1] == ' ') {\n            return true; // Last character is a letter and not part of a word\n        }\n    }\n\n    return false; // Either not a letter or part of a word\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int largestIndex = -1; // Initialize to -1, which will be returned if no such element exists\n\n    // Iterate through the vector starting from the second element\n    for (int i = 1; i < arr.size(); i++) {\n        // Check if the current element is less than the previous element\n        if (arr[i] < arr[i - 1]) {\n            largestIndex = i; // Update the largest index\n        }\n    }\n\n    return largestIndex; // Return the largest index found, or -1 if none found\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = numeric_limits<int>::min(); // Initialize to the smallest possible integer\n    int smallest_positive = numeric_limits<int>::max(); // Initialize to the largest possible integer\n\n    bool found_negative = false;\n    bool found_positive = false;\n\n    for (int num : lst) {\n        if (num < 0) {\n            found_negative = true;\n            if (num > largest_negative) {\n                largest_negative = num; // Update largest negative\n            }\n        } else if (num > 0) {\n            found_positive = true;\n            if (num < smallest_positive) {\n                smallest_positive = num; // Update smallest positive\n            }\n        }\n    }\n\n    // If no negative was found, set largest_negative to 0\n    if (!found_negative) {\n        largest_negative = 0;\n    }\n\n    // If no positive was found, set smallest_positive to 0\n    if (!found_positive) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n#include <sstream>\n#include <locale>\n\nusing namespace std;\n\ndouble convert_to_double(const string& str) {\n    // Replace ',' with '.' for decimal conversion\n    string modified_str = str;\n    replace(modified_str.begin(), modified_str.end(), ',', '.');\n\n    // Convert string to double\n    return stod(modified_str);\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Check if both are of the same type\n    if (a.type() == b.type()) {\n        if (a.type() == typeid(int)) {\n            int int_a = boost::any_cast<int>(a);\n            int int_b = boost::any_cast<int>(b);\n            if (int_a == int_b) return \"None\";\n            return (int_a > int_b) ? a : b;\n        } else if (a.type() == typeid(double)) {\n            double double_a = boost::any_cast<double>(a);\n            double double_b = boost::any_cast<double>(b);\n            if (double_a == double_b) return \"None\";\n            return (double_a > double_b) ? a : b;\n        } else if (a.type() == typeid(string)) {\n            string str_a = boost::any_cast<string>(a);\n            string str_b = boost::any_cast<string>(b);\n            double double_a = convert_to_double(str_a);\n            double double_b = convert_to_double(str_b);\n            if (double_a == double_b) return \"None\";\n            return (double_a > double_b) ? a : b;\n        }\n    } else {\n        // If types are different, we need to handle conversion\n        double double_a, double_b;\n\n        if (a.type() == typeid(int)) {\n            double_a = boost::any_cast<int>(a);\n            if (b.type() == typeid(double)) {\n                double_b = boost::any_cast<double>(b);\n            } else if (b.type() == typeid(string)) {\n                double_b = convert_to_double(boost::any_cast<string>(b));\n            }\n        } else if (a.type() == typeid(double)) {\n            double_a = boost::any_cast<double>(a);\n            if (b.type() == typeid(int)) {\n                double_b = boost::any_cast<int>(b);\n            } else if (b.type() == typeid(string)) {\n                double_b = convert_to_double(boost::any_cast<string>(b));\n            }\n        } else if (a.type() == typeid(string)) {\n            double_a = convert_to_double(boost::any_cast<string>(a));\n            if (b.type() == typeid(int)) {\n                double_b = boost::any_cast<int>(b);\n            } else if (b.type() == typeid(double)) {\n                double_b = boost::any_cast<double>(b);\n            }\n        }\n\n        if (double_a == double_b) return \"None\";\n        return (double_a > double_b) ? a : b;\n    }\n\n    return \"None\"; // Fallback case\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <stdio.h>\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is less than 8\n    if (n < 8) {\n        return false;\n    }\n    // Check if n is even\n    if (n % 2 != 0) {\n        return false;\n    }\n    // If n is even and >= 8, return true\n    return true;\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate factorial of a number\nlong long factorial(int num) {\n    long long result = 1;\n    for (int i = 2; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to calculate the Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int space_count = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n        } else {\n            if (space_count > 0) {\n                if (space_count == 1) {\n                    result += '_'; // Replace single space with underscore\n                } else {\n                    result += '-'; // Replace more than one space with hyphen\n                }\n                space_count = 0; // Reset space count\n            }\n            result += c; // Add the current character to the result\n        }\n    }\n\n    // Handle trailing spaces if any\n    if (space_count > 0) {\n        if (space_count == 1) {\n            result += '_'; // Replace single space with underscore\n        } else {\n            result += '-'; // Replace more than one space with hyphen\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check for exactly one dot\n    size_t dot_pos = file_name.find('.');\n    if (dot_pos == string::npos || file_name.find('.', dot_pos + 1) != string::npos) {\n        return \"No\";\n    }\n\n    // Split the file name into name and extension\n    string name_part = file_name.substr(0, dot_pos);\n    string ext_part = file_name.substr(dot_pos + 1);\n\n    // Check if the name part is not empty and starts with a letter\n    if (name_part.empty() || !isalpha(name_part[0])) {\n        return \"No\";\n    }\n\n    // Check for the number of digits in the name part\n    int digit_count = 0;\n    for (char c : name_part) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n    }\n    if (digit_count > 3) {\n        return \"No\";\n    }\n\n    // Check if the extension is valid\n    if (ext_part == \"txt\" || ext_part == \"exe\" || ext_part == \"dll\") {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int total_sum = 0; // Initialize the sum to 0\n\n    // Iterate through the vector\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            // If the index is a multiple of 3, square the entry\n            total_sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            // If the index is a multiple of 4 and not a multiple of 3, cube the entry\n            total_sum += lst[i] * lst[i] * lst[i];\n        } else {\n            // If the index is not a multiple of 3 or 4, just add the entry as is\n            total_sum += lst[i];\n        }\n    }\n\n    return total_sum; // Return the total sum\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it is prime\n}\n\n// Function to extract words with prime lengths from a sentence\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    vector<string> prime_length_words;\n\n    // Split the sentence into words\n    while (ss >> word) {\n        // Check if the length of the word is prime\n        if (is_prime(word.length())) {\n            prime_length_words.push_back(word);\n        }\n    }\n\n    // Join the words with prime lengths into a single string\n    string result;\n    for (size_t i = 0; i < prime_length_words.size(); ++i) {\n        result += prime_length_words[i];\n        if (i < prime_length_words.size() - 1) {\n            result += \" \"; // Add space between words\n        }\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Parse the first fraction x\n    size_t pos = x.find('/');\n    int numerator_x = stoi(x.substr(0, pos));\n    int denominator_x = stoi(x.substr(pos + 1));\n\n    // Parse the second fraction n\n    pos = n.find('/');\n    int numerator_n = stoi(n.substr(0, pos));\n    int denominator_n = stoi(n.substr(pos + 1));\n\n    // Calculate the product of the fractions\n    int product_numerator = numerator_x * numerator_n;\n    int product_denominator = denominator_x * denominator_n;\n\n    // Check if the product is a whole number\n    return product_numerator % product_denominator == 0;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n// Helper function to calculate the sum of digits\nint digit_sum(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = abs(num); // Work with absolute value for digit extraction\n\n    while (num > 0) {\n        sum += num % 10; // Add the last digit\n        num /= 10;       // Remove the last digit\n    }\n\n    // If the number was negative, we need to subtract the first digit\n    if (is_negative) {\n        sum -= 1; // Adjust for the negative sign\n    }\n\n    return sum;\n}\n\n// Function to sort the vector based on the sum of digits\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of pairs to store the original index and the number\n    vector<pair<int, int>> indexed_nums;\n    for (int i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({i, nums[i]});\n    }\n\n    // Sort the vector based on the digit sum and original index\n    sort(indexed_nums.begin(), indexed_nums.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        int sum_a = digit_sum(a.second);\n        int sum_b = digit_sum(b.second);\n        if (sum_a == sum_b) {\n            return a.first < b.first; // Maintain original order if sums are equal\n        }\n        return sum_a < sum_b; // Sort by digit sum\n    });\n\n    // Extract the sorted numbers\n    vector<int> sorted_nums;\n    for (const auto& p : indexed_nums) {\n        sorted_nums.push_back(p.second);\n    }\n\n    return sorted_nums;\n}\n\n// Example usage\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool isOdd(int digit) {\n    return (digit % 2 != 0);\n}\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n\n    for (int num : nums) {\n        // Check if the number is greater than 10\n        if (num > 10) {\n            // Convert the number to a string\n            string numStr = to_string(num);\n            // Get the first and last digits\n            int firstDigit = numStr[0] - '0'; // Convert char to int\n            int lastDigit = numStr[numStr.length() - 1] - '0'; // Convert char to int\n\n            // Check if both first and last digits are odd\n            if (isOdd(firstDigit) && isOdd(lastDigit)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    // Step 1: Create the vector a\n    vector<int> a(n);\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1; // a[i] = i^2 - i + 1\n    }\n\n    // Step 2: Count occurrences of each remainder when divided by 3\n    int count[3] = {0}; // count[0] for remainder 0, count[1] for remainder 1, count[2] for remainder 2\n    for (int i = 0; i < n; ++i) {\n        count[a[i] % 3]++;\n    }\n\n    // Step 3: Count valid triples\n    int total_triples = 0;\n\n    // Case 1: All three have remainder 0\n    if (count[0] >= 3) {\n        total_triples += (count[0] * (count[0] - 1) * (count[0] - 2)) / 6; // nC3\n    }\n\n    // Case 2: All three have remainder 1\n    if (count[1] >= 3) {\n        total_triples += (count[1] * (count[1] - 1) * (count[1] - 2)) / 6; // nC3\n    }\n\n    // Case 3: All three have remainder 2\n    if (count[2] >= 3) {\n        total_triples += (count[2] * (count[2] - 1) * (count[2] - 2)) / 6; // nC3\n    }\n\n    // Case 4: One of each remainder (0, 1, 2)\n    total_triples += count[0] * count[1] * count[2];\n\n    return total_triples;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // Define the order of planets\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Find the indices of the input planets\n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n    \n    // Check if both planets are valid\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {}; // Return empty vector if either planet is invalid\n    }\n    \n    // Get the indices of the planets\n    int index1 = distance(planets.begin(), it1);\n    int index2 = distance(planets.begin(), it2);\n    \n    // Ensure index1 is less than index2\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Create a vector to hold the planets in between\n    vector<string> result;\n    \n    // Collect planets between index1 and index2\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to sort the vector of strings\nvector<string> vector_sort(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0; // Keep only even length strings\n    }), lst.end());\n\n    // Sort the remaining strings by length and then alphabetically\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() != b.length()) {\n            return a.length() < b.length(); // Sort by length\n        }\n        return a < b; // Sort alphabetically\n    });\n\n    return lst;\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to return x if n is prime, otherwise return y\nint x_or_y(int n, int x, int y) {\n    if (isPrime(n)) {\n        return x; // n is prime\n    } else {\n        return y; // n is not prime\n    }\n}\n\n// Main function to test the x_or_y function\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0; // Initialize sum to 0\n\n    for (float num : lst) {\n        // Check if the number is a non-negative integer\n        if (num >= 0 && static_cast<int>(num) == num) {\n            int intNum = static_cast<int>(num); // Convert to integer\n            // Check if the number is odd\n            if (intNum % 2 != 0) {\n                sum += intNum * intNum; // Add the square of the odd number to sum\n            }\n        }\n    }\n\n    return sum; // Return the total sum\n}\n\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for abs function\n\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result; // Vector to store the results\n    // Ensure both vectors are of the same length\n    if (game.size() != guess.size()) {\n        throw invalid_argument(\"Vectors must be of the same length\");\n    }\n    \n    // Iterate through both vectors\n    for (size_t i = 0; i < game.size(); ++i) {\n        // Calculate the absolute difference and store it in the result vector\n        result.push_back(abs(game[i] - guess[i]));\n    }\n    \n    return result; // Return the result vector\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = -1; // Initialize to a value lower than any possible strength\n    string strongest_extension = \"\";\n\n    for (const string& extension : extensions) {\n        int CAP = 0; // Count of uppercase letters\n        int SM = 0;  // Count of lowercase letters\n\n        // Calculate CAP and SM\n        for (char c : extension) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n\n        // Calculate strength\n        int strength = CAP - SM;\n\n        // Update strongest extension if this one is stronger\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    // Return the result in the specified format\n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // If b is longer than a, it can't be a substring\n    if (b.length() > a.length()) {\n        return false;\n    }\n    \n    // Concatenate b with itself\n    string b_double = b + b;\n    \n    // Check if a contains any substring of b_double that is of length b\n    return b_double.find(a) != string::npos;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Initialize counts for even and odd digits\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Handle negative numbers by taking the absolute value\n    num = abs(num);\n\n    // If the number is 0, it has one even digit\n    if (num == 0) {\n        even_count = 1;\n    } else {\n        // Loop through each digit\n        while (num > 0) {\n            int digit = num % 10; // Get the last digit\n            if (digit % 2 == 0) {\n                even_count++; // Increment even count\n            } else {\n                odd_count++; // Increment odd count\n            }\n            num /= 10; // Remove the last digit\n        }\n    }\n\n    // Return the counts as a vector\n    return {even_count, odd_count};\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the Roman numeral symbols and their corresponding values\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string result = \"\";\n\n    // Iterate through the roman_numerals vector\n    for (const auto& pair : roman_numerals) {\n        while (number >= pair.first) {\n            result += pair.second; // Append the Roman numeral\n            number -= pair.first;  // Decrease the number\n        }\n    }\n\n    return result; // Return the final Roman numeral string\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to identify the longest side\n    float sides[3] = {a, b, c};\n    // Sort the array\n    for (int i = 0; i < 3; i++) {\n        for (int j = i + 1; j < 3; j++) {\n            if (sides[i] > sides[j]) {\n                float temp = sides[i];\n                sides[i] = sides[j];\n                sides[j] = temp;\n            }\n        }\n    }\n\n    // Now sides[2] is the longest side\n    float x = sides[0];\n    float y = sides[1];\n    float z = sides[2];\n\n    // Check the Pythagorean theorem\n    return (fabs(x * x + y * y - z * z) < 1e-6); // Using a small epsilon for floating point comparison\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to count unique characters in a string\nint count_unique_characters(const string& word) {\n    unordered_set<char> unique_chars(word.begin(), word.end());\n    return unique_chars.size();\n}\n\nstring find_max(vector<string> words) {\n    string max_word;\n    int max_unique_count = 0;\n\n    for (const string& word : words) {\n        int unique_count = count_unique_characters(word);\n        \n        // Check if this word has more unique characters or is lexicographically smaller\n        if (unique_count > max_unique_count || \n            (unique_count == max_unique_count && (max_word.empty() || word < max_word))) {\n            max_unique_count = unique_count;\n            max_word = word;\n        }\n    }\n\n    return max_word;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate total carrots needed after current eaten\n    int totalNeeded = number + need;\n    \n    // Check if there are enough remaining carrots\n    if (remaining >= need) {\n        // If enough, eat the needed amount\n        number += need;\n        remaining -= need;\n    } else {\n        // If not enough, eat all remaining carrots\n        number += remaining;\n        remaining = 0; // All remaining carrots are eaten\n    }\n    \n    // Return the result as a vector\n    return {number, remaining};\n}\n\n// Example usage\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stdexcept>\n\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    if (operato.size() != operand.size() - 1) {\n        throw invalid_argument(\"The length of operator vector must be one less than operand vector.\");\n    }\n\n    // Start with the first operand\n    int result = operand[0];\n\n    // Iterate through the operators and operands\n    for (size_t i = 0; i < operato.size(); ++i) {\n        string op = operato[i];\n        int next_operand = operand[i + 1];\n\n        if (op == \"+\") {\n            result += next_operand;\n        } else if (op == \"-\") {\n            result -= next_operand;\n        } else if (op == \"*\") {\n            result *= next_operand;\n        } else if (op == \"//\") {\n            if (next_operand == 0) {\n                throw invalid_argument(\"Division by zero is not allowed.\");\n            }\n            result /= next_operand; // Floor division\n        } else if (op == \"**\") {\n            result = pow(result, next_operand); // Exponentiation\n        } else {\n            throw invalid_argument(\"Invalid operator: \" + op);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha, tolower, toupper\n\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetter = false;\n\n    // Check if the string contains any letters\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    if (hasLetter) {\n        // Reverse case for letters\n        for (char &c : s) {\n            if (isalpha(c)) {\n                if (islower(c)) {\n                    c = toupper(c);\n                } else {\n                    c = tolower(c);\n                }\n            }\n        }\n    } else {\n        // Reverse the entire string\n        reverse(s.begin(), s.end());\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n#include <sstream>\n#include <iomanip>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    // Return None (or equivalent) if the input string is empty\n    if (text.empty()) {\n        return \"\"; // You can return \"None\" as a string if you prefer\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    // Convert the unsigned char array to a hex string\n    stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        ss << hex << setw(2) << setfill('0') << (int)digest[i];\n    }\n\n    return ss.str();\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    // Create a set to store unique even digits\n    set<int> even_digits;\n\n    // Determine the range\n    int start = min(a, b);\n    int end = max(a, b);\n\n    // Check for even digits between start and end\n    for (int i = start; i <= end; i++) {\n        // Check if the number is a single digit and even\n        if (i >= 0 && i < 10 && i % 2 == 0) {\n            even_digits.insert(i);\n        }\n    }\n\n    // Convert the set to a vector for the result\n    vector<int> result(even_digits.begin(), even_digits.end());\n    return result;\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector\n    sort(numbers.begin(), numbers.end());\n    \n    // Check adjacent elements for closeness\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (fabs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true; // Found two numbers closer than the threshold\n        }\n    }\n    \n    return false; // No such pair found\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype> // for isspace\n\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        // Ignore spaces\n        if (isspace(ch)) {\n            continue;\n        }\n\n        // Add the character to the current group\n        current_group += ch;\n\n        // Update the balance\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n        }\n\n        // If balance is zero, we have a complete group\n        if (balance == 0 && !current_group.empty()) {\n            result.push_back(current_group);\n            current_group.clear(); // Reset for the next group\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    // Get the integer part of the number\n    int integer_part = (int)floor(number);\n    // Calculate the decimal part\n    float decimal_part = number - integer_part;\n    return decimal_part;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a balance of zero\n\n    for (int operation : operations) {\n        balance += operation; // Update balance with the current operation\n        if (balance < 0) { // Check if balance falls below zero\n            return true; // Return true if it does\n        }\n    }\n    \n    return false; // Return false if balance never goes below zero\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Step 1: Calculate the mean\n    float sum = 0.0;\n    int n = numbers.size();\n    \n    for (float num : numbers) {\n        sum += num;\n    }\n    \n    float mean = sum / n;\n\n    // Step 2: Calculate the absolute differences and their average\n    float mad_sum = 0.0;\n    \n    for (float num : numbers) {\n        mad_sum += fabs(num - mean);\n    }\n    \n    float mad = mad_sum / n;\n\n    return mad;\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimiter) {\n    // If the input vector is empty, return an empty vector\n    if (numbers.empty()) {\n        return {};\n    }\n\n    // Create a new vector to hold the result\n    vector<int> result;\n\n    // Iterate through the input vector\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        // Add the current element to the result\n        result.push_back(numbers[i]);\n        \n        // If it's not the last element, add the delimiter\n        if (i < numbers.size() - 1) {\n            result.push_back(delimiter);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths; // To store the maximum depths for each group\n    stringstream ss(paren_string);\n    string group;\n\n    // Process each group separated by spaces\n    while (ss >> group) {\n        int current_depth = 0; // Current depth of nesting\n        int max_depth = 0; // Maximum depth for the current group\n\n        // Iterate through each character in the group\n        for (char ch : group) {\n            if (ch == '(') {\n                current_depth++; // Increase depth for opening parenthesis\n                max_depth = max(max_depth, current_depth); // Update max depth\n            } else if (ch == ')') {\n                current_depth--; // Decrease depth for closing parenthesis\n            }\n        }\n\n        depths.push_back(max_depth); // Store the maximum depth for this group\n    }\n\n    return depths; // Return the vector of maximum depths\n}\n\n// Example usage\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_substring(const vector<string>& strings, const string& substring) {\n    vector<string> filtered_strings;\n\n    for (const string& str : strings) {\n        // Check if the substring is found in the current string\n        if (str.find(substring) != string::npos) {\n            filtered_strings.push_back(str);\n        }\n    }\n\n    return filtered_strings;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\npair<int, int> sum_product(const vector<int>& numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // If the vector is empty, return (0, 1)\n    if (numbers.empty()) {\n        return make_pair(sum, product);\n    }\n\n    // Calculate sum and product\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return make_pair(sum, product);\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(const vector<int>& numbers) {\n    vector<int> result; // Vector to store the rolling maximums\n    int current_max = INT_MIN; // Initialize current_max to the smallest integer\n\n    for (int number : numbers) {\n        // Update current_max if the current number is greater\n        if (number > current_max) {\n            current_max = number;\n        }\n        // Add the current maximum to the result vector\n        result.push_back(current_max);\n    }\n\n    return result; // Return the vector of rolling maximums\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(const string& str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    int n = str.length();\n    \n    // Find the longest palindromic suffix\n    for (int i = n; i >= 0; --i) {\n        if (is_palindrome(str.substr(i))) {\n            // If the substring from i to the end is a palindrome\n            string prefix = str.substr(0, i); // Get the prefix before the palindromic suffix\n            string reversed_prefix(prefix.rbegin(), prefix.rend()); // Reverse the prefix\n            return str + reversed_prefix; // Append the reversed prefix to the original string\n        }\n    }\n    \n    // If the entire string is a palindrome, return it as is\n    return str;\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of the same length\n    if (a.length() != b.length()) {\n        throw invalid_argument(\"Strings must be of the same length\");\n    }\n\n    string result = \"\";\n    for (size_t i = 0; i < a.length(); ++i) {\n        // Perform XOR operation\n        if (a[i] == b[i]) {\n            result += '0'; // Same bits result in '0'\n        } else {\n            result += '1'; // Different bits result in '1'\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring longest(const vector<string>& strings) {\n    // Check if the input vector is empty\n    if (strings.empty()) {\n        return \"\"; // Return an empty string to represent None\n    }\n\n    string longestString = strings[0]; // Start with the first string\n\n    // Iterate through the vector to find the longest string\n    for (const string& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str; // Update longestString if a longer string is found\n        }\n    }\n\n    return longestString; // Return the longest string found\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure a and b are non-negative\n    a = abs(a);\n    b = abs(b);\n    \n    // Euclidean algorithm\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes; // Vector to store the prefixes\n    string current_prefix;   // Temporary string to build prefixes\n\n    // Iterate through the string and build prefixes\n    for (char c : str) {\n        current_prefix += c; // Append the current character\n        prefixes.push_back(current_prefix); // Add the current prefix to the vector\n    }\n\n    return prefixes; // Return the vector of prefixes\n}\n\n// Example usage\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss; // Create a stringstream to build the string\n    for (int i = 0; i <= n; ++i) {\n        ss << i; // Add the current number to the stream\n        if (i < n) {\n            ss << \" \"; // Add a space after each number except the last one\n        }\n    }\n    return ss.str(); // Convert the stringstream to a string and return it\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <set>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    set<char> distinct_chars; // Set to store distinct characters\n\n    // Iterate through each character in the string\n    for (char c : str) {\n        // Convert character to lowercase and insert into the set\n        distinct_chars.insert(tolower(c));\n    }\n\n    // The size of the set is the number of distinct characters\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> durations;\n    stringstream ss(music_string);\n    string note;\n\n    while (ss >> note) {\n        if (note == \"o\") {\n            durations.push_back(4); // whole note\n        } else if (note == \"o|\") {\n            durations.push_back(2); // half note\n        } else if (note == \".|\") {\n            durations.push_back(1); // quarter note\n        }\n    }\n\n    return durations;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (substring.empty()) {\n        return 0; // If the substring is empty, return 0\n    }\n\n    int count = 0;\n    size_t pos = 0;\n\n    // Loop until we find the substring in the string\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++; // Increment the count for each found occurrence\n        pos++; // Move to the next character to allow overlapping\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Mapping from string representations to their integer values\n    map<string, int> num_map = {\n        {\"zero\", 0},\n        {\"one\", 1},\n        {\"two\", 2},\n        {\"three\", 3},\n        {\"four\", 4},\n        {\"five\", 5},\n        {\"six\", 6},\n        {\"seven\", 7},\n        {\"eight\", 8},\n        {\"nine\", 9}\n    };\n\n    // Vector to hold the integer values\n    vector<int> num_values;\n    stringstream ss(numbers);\n    string word;\n\n    // Split the input string and convert to integer values\n    while (ss >> word) {\n        num_values.push_back(num_map[word]);\n    }\n\n    // Sort the integer values\n    sort(num_values.begin(), num_values.end());\n\n    // Convert sorted integer values back to string representations\n    vector<string> sorted_words;\n    for (int num : num_values) {\n        for (const auto& pair : num_map) {\n            if (pair.second == num) {\n                sorted_words.push_back(pair.first);\n                break;\n            }\n        }\n    }\n\n    // Join the sorted words into a single output string\n    string result;\n    for (size_t i = 0; i < sorted_words.size(); ++i) {\n        result += sorted_words[i];\n        if (i < sorted_words.size() - 1) {\n            result += \" \"; // Add space between words\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\npair<float, float> find_closest_elements(vector<float> numbers) {\n    // Sort the vector\n    sort(numbers.begin(), numbers.end());\n\n    // Initialize variables to track the closest pair\n    float min_diff = numeric_limits<float>::max();\n    pair<float, float> closest_pair;\n\n    // Iterate through the sorted vector to find the closest pair\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {numbers[i], numbers[i + 1]};\n        }\n    }\n\n    return closest_pair;\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    // Check that the vector has at least two elements\n    if (numbers.size() < 2) {\n        throw invalid_argument(\"The vector must contain at least two elements.\");\n    }\n\n    // Find the minimum and maximum values in the vector\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n\n    // Create a new vector to hold the rescaled values\n    vector<float> rescaled;\n\n    // Rescale each number\n    for (float num : numbers) {\n        float rescaled_value = (num - min_val) / (max_val - min_val);\n        rescaled.push_back(rescaled_value);\n    }\n\n    return rescaled;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <list>\n#include <boost/any.hpp>\n#include <typeinfo>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> integers;\n\n    for (const auto& value : values) {\n        // Check if the value can be cast to an int\n        if (value.type() == typeid(int)) {\n            // Safely cast and add to the vector\n            integers.push_back(boost::any_cast<int>(value));\n        }\n    }\n\n    return integers;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to return the length of a given string\nint my_strlen(const string& str) {\n    return str.length(); // or str.size();\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    // Start from n-1 and go downwards\n    for (int i = n - 1; i > 0; i--) {\n        if (n % i == 0) { // Check if i is a divisor of n\n            return i; // Return the largest divisor found\n        }\n    }\n    return 1; // In case n is 1, the largest divisor smaller than 1 is not defined, return 1\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    \n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i * i <= n; i += 2) {\n        // While i divides n, add i and divide n\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> frequency;\n    \n    // Count the frequency of each number\n    for (int num : numbers) {\n        frequency[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Add elements that occur only once to the result\n    for (int num : numbers) {\n        if (frequency[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) { // Use a reference to modify the original string\n        if (isupper(c)) {\n            c = tolower(c); // Convert uppercase to lowercase\n        } else if (islower(c)) {\n            c = toupper(c); // Convert lowercase to uppercase\n        }\n    }\n    return str; // Return the modified string\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result; // Initialize an empty string to hold the concatenated result\n    for (const string& str : strings) { // Iterate through each string in the vector\n        result += str; // Append the current string to the result\n    }\n    return result; // Return the concatenated string\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_prefix(const vector<string>& strings, const string& prefix) {\n    vector<string> result; // Vector to store the filtered results\n\n    // Iterate through each string in the input vector\n    for (const string& str : strings) {\n        // Check if the string starts with the given prefix\n        if (str.rfind(prefix, 0) == 0) { // rfind returns the position of the prefix, 0 means it starts at the beginning\n            result.push_back(str); // Add to result if it matches\n        }\n    }\n\n    return result; // Return the filtered vector\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positives; // Vector to store positive numbers\n    for (float num : l) { // Iterate through each number in the input vector\n        if (num > 0) { // Check if the number is positive\n            positives.push_back(num); // Add positive number to the positives vector\n        }\n    }\n    return positives; // Return the vector containing only positive numbers\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Handle special cases\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    if (n <= 3) return true;  // 2 and 3 are prime numbers\n\n    // Check for even numbers and multiples of 3\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    // Check for factors from 5 to sqrt(n)\n    for (long long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n\n    return true; // n is prime\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble poly_derivative(vector<double> xs, double x) {\n    double sum = 0;\n    for (int i = 1; i < xs.size(); i++) {\n        sum += i * xs[i] * pow(x, i - 1);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    double x0 = 0.0; // Initial guess\n    double tolerance = 1e-7; // Tolerance for convergence\n    int max_iterations = 1000; // Maximum number of iterations\n    int iteration = 0;\n\n    while (iteration < max_iterations) {\n        double fx = poly(xs, x0);\n        double dfx = poly_derivative(xs, x0);\n\n        if (fabs(fx) < tolerance) {\n            return x0; // Found a root\n        }\n\n        if (fabs(dfx) < tolerance) {\n            // Derivative is too small, we can't proceed\n            throw runtime_error(\"Derivative too small; no convergence.\");\n        }\n\n        // Newton-Raphson update\n        x0 = x0 - fx / dfx;\n        iteration++;\n    }\n\n    throw runtime_error(\"Maximum iterations reached; no convergence.\");\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> result(l.size());\n    vector<int> third_indices_values;\n\n    // Collect values at indices divisible by 3\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            third_indices_values.push_back(l[i]);\n        } else {\n            result[i] = l[i]; // Copy values for indices not divisible by 3\n        }\n    }\n\n    // Sort the collected values\n    sort(third_indices_values.begin(), third_indices_values.end());\n\n    // Place sorted values back into the result vector at the correct indices\n    size_t sorted_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            result[i] = third_indices_values[sorted_index++];\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Use a set to store unique elements\n    set<int> unique_set(l.begin(), l.end());\n    \n    // Convert the set back to a vector\n    vector<int> unique_vector(unique_set.begin(), unique_set.end());\n    \n    // Return the sorted unique elements\n    return unique_vector;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n#include <limits> // For std::numeric_limits\n\nusing namespace std;\n\nfloat max_element(const vector<float>& l) {\n    // Check if the vector is empty\n    if (l.empty()) {\n        // Handle the case of an empty vector\n        // You can return a special value or throw an exception\n        // Here we return the smallest float value\n        return std::numeric_limits<float>::lowest();\n    }\n\n    // Initialize max with the first element of the vector\n    float max_val = l[0];\n\n    // Iterate through the vector to find the maximum element\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint count_sevens(int number) {\n    int count = 0;\n    string num_str = to_string(number);\n    for (char c : num_str) {\n        if (c == '7') {\n            count++;\n        }\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int total_count = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            total_count += count_sevens(i);\n        }\n    }\n    return total_count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Create a vector to hold the even indexed values\n    vector<float> even_values;\n\n    // Extract values at even indices\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n\n    // Sort the even indexed values\n    sort(even_values.begin(), even_values.end());\n\n    // Create a new vector to hold the result\n    vector<float> result(l.size());\n\n    // Fill the result vector\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            // Even index: use sorted value\n            result[i] = even_values[i / 2];\n        } else {\n            // Odd index: keep original value\n            result[i] = l[i];\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.  \n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            x = x.substr(1) + x[0]; // Cycle the characters\n        }\n        output += x; // Append the processed group to output\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    // takes as input string encoded with encode_cyclic function. Returns decoded string. \n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            x = x[x.length() - 1] + x.substr(0, 2); // Reverse the cycling\n        }\n        output += x; // Append the processed group to output\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to return the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    int count = 0; // Count of prime Fibonacci numbers\n    int a = 0, b = 1; // Fibonacci numbers initialization\n    int fib; // Variable to hold the current Fibonacci number\n\n    while (true) {\n        fib = a + b; // Generate the next Fibonacci number\n        a = b; // Move to the next Fibonacci number\n        b = fib;\n\n        // Check if the Fibonacci number is prime\n        if (is_prime(fib)) {\n            count++; // Increment the count of prime Fibonacci numbers\n            if (count == n) {\n                return fib; // Return the n-th prime Fibonacci number\n            }\n        }\n    }\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    \n    // Iterate through the vector\n    for (int i = 0; i < n - 2; i++) {\n        // Skip duplicates for the first element\n        if (i > 0 && l[i] == l[i - 1]) continue;\n\n        int left = i + 1;\n        int right = n - 1;\n\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true; // Found a triplet\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    \n    return false; // No triplet found\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <stdio.h>\n\nint car_race_collision(int n) {\n    // Each car moving left to right will collide with each car moving right to left\n    return n * n; // Total collisions = n (left to right) * n (right to left)\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    // Create a new vector to store the incremented values\n    vector<int> incremented_list;\n    \n    // Iterate through each element in the input vector\n    for (int i = 0; i < l.size(); i++) {\n        // Increment the current element by 1 and add it to the new vector\n        incremented_list.push_back(l[i] + 1);\n    }\n    \n    // Return the new vector with incremented values\n    return incremented_list;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen; // Set to store the numbers we have seen\n\n    for (int num : l) {\n        // Check if the negation of the current number is in the set\n        if (seen.count(-num)) {\n            return true; // Found a pair that sums to zero\n        }\n        // Add the current number to the set\n        seen.insert(num);\n    }\n\n    return false; // No pairs found that sum to zero\n}\n\n// Example usage\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    // Check if the base is valid\n    if (base < 2 || base >= 10) {\n        return \"\"; // Return an empty string for invalid base\n    }\n    \n    // Handle the case when x is 0\n    if (x == 0) {\n        return \"0\";\n    }\n\n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base; // Get the remainder\n        result = to_string(remainder) + result; // Prepend the remainder to the result\n        x /= base; // Divide x by base\n    }\n\n    return result; // Return the final string representation\n}\n\n// Example usage\n"}
{"task_id": "CPP/45", "generation": "#include <iostream>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h; // Calculate the area using the formula\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    // Base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    // Array to store the last four values\n    int fib[4] = {0, 0, 2, 0}; // fib4(0), fib4(1), fib4(2), fib4(3)\n\n    // Compute fib4(n) iteratively\n    for (int i = 4; i <= n; ++i) {\n        int next_fib = fib[0] + fib[1] + fib[2] + fib[3];\n        // Update the array to hold the last four values\n        fib[0] = fib[1];\n        fib[1] = fib[2];\n        fib[2] = fib[3];\n        fib[3] = next_fib;\n    }\n\n    return fib[3]; // fib[3] will hold fib4(n)\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Step 1: Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Step 2: Calculate the size of the vector\n    size_t size = l.size();\n    \n    // Step 3: Check if the size is odd or even\n    if (size % 2 == 1) {\n        // Odd size: return the middle element\n        return l[size / 2];\n    } else {\n        // Even size: return the average of the two middle elements\n        return (l[size / 2 - 1] + l[size / 2]) / 2.0;\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Not a palindrome\n        }\n        left++;\n        right--;\n    }\n    return true; // Is a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <iostream>\nusing namespace std;\n\nint modp(int n, int p) {\n    // Handle the case where p is 1, since any number mod 1 is 0\n    if (p == 1) return 0;\n\n    long long result = 1; // Use long long to prevent overflow\n    long long base = 2;   // The base is 2\n\n    // Exponentiation by squaring\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd\n            result = (result * base) % p; // Multiply the result by base and take mod p\n        }\n        base = (base * base) % p; // Square the base and take mod p\n        n /= 2; // Divide n by 2\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // Returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (char c : s) {\n        if (isalpha(c)) { // Check if the character is an alphabet\n            char base = islower(c) ? 'a' : 'A'; // Determine the base for lowercase or uppercase\n            char shifted = (c - base + 5) % 26 + base; // Shift and wrap around\n            out += shifted; // Append the shifted character to the output string\n        } else {\n            out += c; // Non-alphabet characters are added unchanged\n        }\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // Takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (char c : s) {\n        if (isalpha(c)) { // Check if the character is an alphabet\n            char base = islower(c) ? 'a' : 'A'; // Determine the base for lowercase or uppercase\n            char shifted = (c - base - 5 + 26) % 26 + base; // Shift back and wrap around\n            out += shifted; // Append the shifted character to the output string\n        } else {\n            out += c; // Non-alphabet characters are added unchanged\n        }\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        // Check if the character is not a vowel\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n            c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            result += c; // Append non-vowel characters to result\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false; // Found a number that is not below the threshold\n        }\n    }\n    return true; // All numbers are below the threshold\n}\n\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to add two numbers\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    unordered_set<char> set0(s0.begin(), s0.end());\n    unordered_set<char> set1(s1.begin(), s1.end());\n    \n    return set0 == set1; // Compare the two sets\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) return 0; // Handle the case for n = 0\n    if (n == 1) return 1; // Base case for n = 1\n\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; i++) {\n        c = a + b; // Calculate the next Fibonacci number\n        a = b;     // Move to the next pair\n        b = c;\n    }\n    return b; // b now holds the n-th Fibonacci number\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // This will track the balance of brackets\n\n    for (char ch : brackets) {\n        if (ch == '<') {\n            balance++; // Increment for opening bracket\n        } else if (ch == '>') {\n            balance--; // Decrement for closing bracket\n        }\n\n        // If balance goes negative, there are unmatched closing brackets\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // At the end, balance should be zero for all brackets to be matched\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() < 2) return true; // A single element or empty vector is considered monotonic\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); i++) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false; // Found an increasing pair, so not decreasing\n        } else if (l[i] < l[i - 1]) {\n            increasing = false; // Found a decreasing pair, so not increasing\n        }\n    }\n\n    return increasing || decreasing; // Return true if either is true\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Use a set to store unique elements from both vectors\n    set<int> set1(l1.begin(), l1.end());\n    set<int> set2(l2.begin(), l2.end());\n    \n    // Vector to store the common elements\n    vector<int> commonElements;\n\n    // Use set_intersection to find common elements\n    set_intersection(set1.begin(), set1.end(),\n                     set2.begin(), set2.end(),\n                     back_inserter(commonElements));\n\n    // The commonElements vector is already sorted due to the nature of sets\n    return commonElements;\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int largest_factor = 1;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        largest_factor = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest_factor = i;\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        largest_factor = n;\n    }\n\n    return largest_factor;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2; // Using the formula to calculate the sum\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // This will keep track of the balance of brackets\n\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++; // Increment for an opening bracket\n        } else if (ch == ')') {\n            balance--; // Decrement for a closing bracket\n        }\n\n        // If balance goes negative, it means there's a closing bracket without a matching opening bracket\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // At the end, balance should be zero if all brackets are matched\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<float> derivative(const vector<float>& xs) {\n    vector<float> result;\n    int degree = xs.size();\n\n    // Iterate through the coefficients, starting from the first term (x^1)\n    for (int i = 1; i < degree; ++i) {\n        // The derivative of the term xs[i] * x^i is i * xs[i]\n        result.push_back(i * xs[i]);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\nusing namespace std;\n\nint fibfib(int n) {\n    // Base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Variables to store the last three values\n    int a = 0; // fibfib(0)\n    int b = 0; // fibfib(1)\n    int c = 1; // fibfib(2)\n    int result;\n\n    // Calculate fibfib(n) iteratively\n    for (int i = 3; i <= n; ++i) {\n        result = a + b + c; // fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n        a = b; // Move to the next value\n        b = c; // Move to the next value\n        c = result; // Update the current value\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    int length = s.length();\n    \n    for (int i = 0; i < length; i++) {\n        char c = tolower(s[i]); // Convert to lowercase for uniform comparison\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    \n    // Check if the last character is 'y' (considering case)\n    if (length > 0 && (s[length - 1] == 'y' || s[length - 1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string\n    string str = to_string(x);\n    int n = str.length(); // Get the number of digits\n\n    // If shift is greater than the number of digits, reverse the string\n    if (shift >= n) {\n        reverse(str.begin(), str.end());\n        return str;\n    }\n\n    // Calculate effective shift\n    int effective_shift = shift % n;\n\n    // Perform the circular shift\n    string result = str.substr(n - effective_shift) + str.substr(0, n - effective_shift);\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0; // Initialize sum to 0\n    for (char c : s) { // Iterate through each character in the string\n        if (isupper(c)) { // Check if the character is an uppercase letter\n            sum += static_cast<int>(c); // Add the ASCII value of the uppercase letter to sum\n        }\n    }\n    return sum; // Return the total sum of ASCII values of uppercase letters\n}\n\n// Example usage\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0;\n    int oranges = 0;\n\n    // Use a stringstream to parse the input string\n    stringstream ss(s);\n    string word;\n\n    // Read the number of apples\n    ss >> apples; // Read the first number (apples)\n    ss >> word;   // Read the word \"apples\"\n    ss >> oranges; // Read the second number (oranges)\n    ss >> word;   // Read the word \"oranges\"\n\n    // Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n    return mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <iostream>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int smallest_even = numeric_limits<int>::max(); // Initialize to maximum integer value\n    int index_of_smallest_even = -1; // Initialize index to -1 (indicating not found)\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            if (arr[i] < smallest_even) { // Check if it's smaller than the current smallest even\n                smallest_even = arr[i];\n                index_of_smallest_even = i; // Update the index\n            }\n        }\n    }\n\n    // If we found an even number, return it and its index\n    if (index_of_smallest_even != -1) {\n        return {smallest_even, index_of_smallest_even};\n    } else {\n        return {}; // Return empty vector if no even number was found\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequencyMap;\n\n    // Count the frequency of each integer\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    int result = -1;\n\n    // Check for the greatest integer meeting the condition\n    for (const auto& pair : frequencyMap) {\n        int value = pair.first;\n        int frequency = pair.second;\n\n        // Check if frequency is greater than or equal to the value\n        if (frequency >= value) {\n            result = max(result, value);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the input list\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int left = 0; // Pointer for the minimum values\n    int right = lst.size() - 1; // Pointer for the maximum values\n    \n    // Alternate between the minimum and maximum values\n    while (left <= right) {\n        if (left == right) {\n            result.push_back(lst[left]); // If both pointers meet, add the last element\n        } else {\n            result.push_back(lst[left]); // Add minimum\n            result.push_back(lst[right]); // Add maximum\n        }\n        left++;\n        right--;\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b > c && a + c > b && b + c > a) {\n        // Calculate the semi-perimeter\n        float s = (a + b + c) / 2;\n        \n        // Calculate the area using Heron's formula\n        float area = sqrt(s * (s - a) * (s - b) * (s - c));\n        \n        // Return the area rounded to 2 decimal points\n        return round(area * 100) / 100;\n    } else {\n        // Return -1 if the sides do not form a valid triangle\n        return -1;\n    }\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool is_palindrome(const vector<int>& q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false; // Not a palindrome\n        }\n    }\n    return true; // Is a palindrome\n}\n\nbool will_it_fly(const vector<int>& q, int w) {\n    // Check if the vector is a palindrome\n    if (!is_palindrome(q)) {\n        return false; // Not balanced\n    }\n    \n    // Calculate the sum of the elements\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    \n    // Check the weight condition\n    return sum <= w; // Return true if the sum is less than or equal to w\n}\n\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    // Compare elements from the start and end of the vector\n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++; // Increment changes if elements are not equal\n        }\n    }\n\n    return changes; // Return the total number of changes needed\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Function to calculate total number of characters in a vector of strings\n    auto total_chars = [](const vector<string>& lst) {\n        int total = 0;\n        for (const string& str : lst) {\n            total += str.size();\n        }\n        return total;\n    };\n\n    // Calculate total characters in both vectors\n    int total1 = total_chars(lst1);\n    int total2 = total_chars(lst2);\n\n    // Compare totals and return the appropriate vector\n    if (total1 < total2) {\n        return lst1;\n    } else {\n        return lst2; // This includes the case where totals are equal\n    }\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a list of prime numbers less than 100\nvector<int> generate_primes() {\n    vector<int> primes;\n    for (int i = 2; i < 100; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to check if the given number is the product of three prime numbers\nbool is_multiply_prime(int a) {\n    vector<int> primes = generate_primes();\n    int size = primes.size();\n\n    // Check all combinations of three primes\n    for (int i = 0; i < size; i++) {\n        for (int j = 0; j < size; j++) {\n            for (int k = 0; k < size; k++) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nbool is_simple_power(int x, int n) {\n    // Handle special cases\n    if (n <= 1) {\n        return (n == 1 && x == 1); // 1^k = 1 for any k, and 0 or negative bases are not valid\n    }\n    if (x < 1) {\n        return false; // x must be a positive integer\n    }\n\n    int power = 1; // Start with n^0\n    while (power < x) {\n        power *= n; // Calculate n^k iteratively\n    }\n    \n    return power == x; // Check if we found x\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool iscube(int a) {\n    // Handle the case for 0 separately\n    if (a == 0) return true;\n\n    // Calculate the cube root of the absolute value of a\n    int cubeRoot = round(cbrt(abs(a)));\n\n    // Check if the cube of the calculated root equals a\n    return (cubeRoot * cubeRoot * cubeRoot == abs(a));\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint hex_key(string num) {\n    // Define the set of prime hexadecimal digits\n    const string primeHexDigits = \"2357BD\"; // B and D are included as prime digits\n\n    int count = 0; // Initialize the count of prime hexadecimal digits\n\n    // Iterate through each character in the input string\n    for (char c : num) {\n        // Check if the character is in the set of prime hexadecimal digits\n        if (primeHexDigits.find(c) != string::npos) {\n            count++; // Increment the count if it's a prime digit\n        }\n    }\n\n    return count; // Return the total count\n}\n\n// Example usage\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Handle the case for 0 explicitly\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    string binary = \"\";\n    \n    // Convert decimal to binary\n    while (decimal > 0) {\n        // Prepend the remainder (0 or 1) to the binary string\n        binary = to_string(decimal % 2) + binary;\n        decimal /= 2; // Divide the number by 2\n    }\n\n    // Add the \"db\" prefix and suffix\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is at least 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string and check every 3 consecutive characters\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        // Check if the three characters are distinct\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false; // Found a group of three that are not distinct\n        }\n    }\n\n    // If we passed all checks, the string is happy\n    return true;\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letterGrades;\n\n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letterGrades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letterGrades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letterGrades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letterGrades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letterGrades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letterGrades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letterGrades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letterGrades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letterGrades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letterGrades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letterGrades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letterGrades.push_back(\"D-\");\n        } else {\n            letterGrades.push_back(\"E\");\n        }\n    }\n\n    return letterGrades;\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to check if the length of the string is prime\nbool prime_length(string str) {\n    int length = str.length(); // Get the length of the string\n    return is_prime(length); // Check if the length is prime\n}\n\n// Example usage\n"}
{"task_id": "CPP/83", "generation": "#include <stdio.h>\n#include <cmath>\n\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        // For 1-digit numbers, only '1' is valid\n        return 1;\n    }\n    \n    // Count of n-digit numbers starting with '1'\n    long long count_starting_with_1 = pow(10, n - 1);\n    \n    // Count of n-digit numbers ending with '1'\n    long long count_ending_with_1 = 9 * pow(10, n - 2);\n    \n    // Count of n-digit numbers starting and ending with '1'\n    long long count_both = pow(10, n - 2);\n    \n    // Total count\n    long long total_count = count_starting_with_1 + count_ending_with_1 - count_both;\n    \n    return total_count;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n\n    // Calculate the sum of the digits of N\n    while (N > 0) {\n        sum += N % 10;  // Add the last digit to sum\n        N /= 10;        // Remove the last digit\n    }\n\n    // Convert the sum to binary\n    string binary = \"\";\n    if (sum == 0) {\n        return \"0\"; // Handle the case where sum is 0\n    }\n    \n    while (sum > 0) {\n        binary = to_string(sum % 2) + binary; // Prepend the binary digit\n        sum /= 2; // Divide sum by 2\n    }\n\n    return binary; // Return the binary representation\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (int i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2 to check odd indices\n        if (lst[i] % 2 == 0) { // Check if the element is even\n            sum += lst[i]; // Add to sum if it's even\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    stringstream ss(s);\n    string word;\n    vector<string> words;\n\n    // Split the string into words\n    while (ss >> word) {\n        // Sort the characters in the word\n        sort(word.begin(), word.end());\n        words.push_back(word);\n    }\n\n    // Reconstruct the string with spaces\n    string result;\n    size_t pos = 0;\n    for (const auto& w : words) {\n        // Find the next space in the original string\n        size_t next_space = s.find(' ', pos);\n        // Append the word to the result\n        result += w;\n        // Append the spaces between words\n        if (next_space != string::npos) {\n            result += s.substr(pos + w.length(), next_space - pos - w.length());\n            pos = next_space + 1; // Move past the space\n        } else {\n            break; // No more spaces, exit the loop\n        }\n    }\n\n    // Append any remaining spaces at the end of the original string\n    result += s.substr(pos);\n\n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n\n    // Iterate through each row\n    for (int i = 0; i < lst.size(); i++) {\n        // Iterate through each column in the current row\n        for (int j = 0; j < lst[i].size(); j++) {\n            // Check if the current element matches x\n            if (lst[i][j] == x) {\n                // Store the coordinates in the result\n                result.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort the result first by row (ascending) and then by column (descending)\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort by column in descending order\n        }\n        return a[0] < b[0]; // Sort by row in ascending order\n    });\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/88", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(const vector<int>& array) {\n    // Step 1: Check if the vector is empty\n    if (array.empty()) {\n        return {};\n    }\n    \n    // Step 2: If the vector has only one element, return a copy of that vector\n    if (array.size() == 1) {\n        return array;\n    }\n\n    // Step 3: Calculate the sum of the first and last elements\n    int sum = array.front() + array.back();\n\n    // Step 4: Create a copy of the original array to sort\n    vector<int> sorted_array = array;\n\n    // Step 5: Sort based on the sum\n    if (sum % 2 == 0) {\n        // Even sum: sort in descending order\n        sort(sorted_array.rbegin(), sorted_array.rend());\n    } else {\n        // Odd sum: sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    // Step 6: Return the sorted vector\n    return sorted_array;\n}\n\n// Example usage\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string encrypted = \"\";\n    \n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') { // Check if the character is a lowercase letter\n            char shifted = c + 4; // Shift the character by 4\n            if (shifted > 'z') { // Wrap around if it goes past 'z'\n                shifted = shifted - 26; // Wrap around to the start of the alphabet\n            }\n            encrypted += shifted; // Append the shifted character to the result\n        }\n    }\n    \n    return encrypted; // Return the encrypted string\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    // Use a set to store unique elements\n    set<int> unique_elements(lst.begin(), lst.end());\n\n    // If there are fewer than 2 unique elements, return None (or -1)\n    if (unique_elements.size() < 2) {\n        return -1; // or you can use a different value to indicate None\n    }\n\n    // Convert the set back to a vector to access elements by index\n    vector<int> sorted_unique(unique_elements.begin(), unique_elements.end());\n\n    // Return the second smallest element\n    return sorted_unique[1];\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <cctype>\n\nusing namespace std;\n\nint is_bored(string S) {\n    // Define the delimiters\n    const string delimiters = \".!?\";\n    vector<string> sentences;\n    size_t start = 0, end;\n\n    // Split the string into sentences\n    while ((end = S.find_first_of(delimiters, start)) != string::npos) {\n        sentences.push_back(S.substr(start, end - start));\n        start = end + 1; // Move past the delimiter\n    }\n    // Add the last sentence if there is any\n    if (start < S.length()) {\n        sentences.push_back(S.substr(start));\n    }\n\n    int boredom_count = 0;\n\n    // Check each sentence\n    for (const string& sentence : sentences) {\n        // Trim leading whitespace\n        size_t first_non_space = sentence.find_first_not_of(\" \\t\");\n        if (first_non_space != string::npos) {\n            // Check if the trimmed sentence starts with \"I\"\n            if (sentence[first_non_space] == 'I') {\n                boredom_count++;\n            }\n        }\n    }\n\n    return boredom_count;\n}\n\n// Example usage\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n\n    // Convert to integers\n    int int_a = static_cast<int>(a);\n    int int_b = static_cast<int>(b);\n    int int_c = static_cast<int>(c);\n\n    // Check if any number is equal to the sum of the other two\n    return (int_a == int_b + int_c) || (int_b == int_a + int_c) || (int_c == int_a + int_b);\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode(string message) {\n    string encodedMessage = \"\";\n\n    for (char c : message) {\n        // Swap case\n        if (isalpha(c)) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n\n            // Replace vowels\n            switch (c) {\n                case 'A':\n                    c = 'C'; // A -> C\n                    break;\n                case 'E':\n                    c = 'G'; // E -> G\n                    break;\n                case 'I':\n                    c = 'K'; // I -> K\n                    break;\n                case 'O':\n                    c = 'Q'; // O -> Q\n                    break;\n                case 'U':\n                    c = 'W'; // U -> W\n                    break;\n                case 'a':\n                    c = 'c'; // a -> c\n                    break;\n                case 'e':\n                    c = 'g'; // e -> g\n                    break;\n                case 'i':\n                    c = 'k'; // i -> k\n                    break;\n                case 'o':\n                    c = 'q'; // o -> q\n                    break;\n                case 'u':\n                    c = 'w'; // u -> w\n                    break;\n                default:\n                    break; // Non-vowel letters remain unchanged\n            }\n        }\n        encodedMessage += c; // Append the modified character to the result\n    }\n\n    return encodedMessage;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to calculate the sum of the digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10; // Add the last digit\n        num /= 10; // Remove the last digit\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and return the sum of its digits\nint largestPrimeSumOfDigits(vector<int> lst) {\n    int largestPrime = -1; // Initialize to -1 to indicate no prime found\n\n    // Iterate through the list to find the largest prime\n    for (int num : lst) {\n        if (isPrime(num) && num > largestPrime) {\n            largestPrime = num; // Update largest prime found\n        }\n    }\n\n    // If no prime was found, return 0 (or handle as needed)\n    if (largestPrime == -1) return 0;\n\n    // Calculate and return the sum of the digits of the largest prime\n    return sumOfDigits(largestPrime);\n}\n\n// Main function\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <cctype> // for islower and isupper\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    // Iterate through each key in the map\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        // Check if the key is a string (it is, since the map uses string as key type)\n        // Check if the key is lowercase or uppercase\n        if (islower(key[0])) {\n            all_upper = false; // If any key is lowercase, set all_upper to false\n        } else if (isupper(key[0])) {\n            all_lower = false; // If any key is uppercase, set all_lower to false\n        } else {\n            // If the key is neither lower nor upper (e.g., contains numbers or special characters)\n            return false;\n        }\n\n        // Check the rest of the characters in the key\n        for (size_t i = 1; i < key.size(); ++i) {\n            if (islower(key[i])) {\n                all_upper = false;\n            } else if (isupper(key[i])) {\n                all_lower = false;\n            } else {\n                // If the key contains any non-alphabetic character\n                return false;\n            }\n        }\n    }\n\n    // Return true if all keys are either all lower or all upper\n    return all_lower || all_upper;\n}\n\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to return a vector of prime numbers less than n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i); // Add prime number to the vector\n        }\n    }\n    return primes; // Return the vector of prime numbers\n}\n\n// Main function to test the count_up_to function\n"}
{"task_id": "CPP/97", "generation": "#include <iostream>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the unit digit of a\n    int unitDigitA = abs(a) % 10; // Use abs to handle negative numbers\n    // Get the unit digit of b\n    int unitDigitB = abs(b) % 10; // Use abs to handle negative numbers\n    // Return the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    // Define a string of uppercase vowels for easy checking\n    string vowels = \"AEIOU\";\n    \n    // Loop through the string, checking only even indices\n    for (int i = 0; i < s.length(); i += 2) {\n        // Check if the character is an uppercase vowel\n        if (vowels.find(s[i]) != string::npos) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert the string to a double\n    double num = stod(value);\n    \n    // Get the floor and ceil values\n    int lower = static_cast<int>(floor(num));\n    int upper = static_cast<int>(ceil(num));\n    \n    // Check the distance to the lower and upper integers\n    double distanceToLower = abs(num - lower);\n    double distanceToUpper = abs(num - upper);\n    \n    // If the distances are equal, round away from zero\n    if (distanceToLower == distanceToUpper) {\n        if (num > 0) {\n            return upper; // Round up for positive numbers\n        } else {\n            return lower; // Round down for negative numbers\n        }\n    }\n    \n    // Otherwise, return the closest integer\n    return (distanceToLower < distanceToUpper) ? lower : upper;\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    int current_stones = n; // Start with n stones for the first level\n    \n    for (int i = 0; i < n; ++i) {\n        stones.push_back(current_stones); // Add current level stones to the vector\n        // Determine the next number of stones based on whether n is odd or even\n        if (n % 2 == 0) {\n            current_stones += 2; // Next even number\n        } else {\n            current_stones += 2; // Next odd number\n        }\n    }\n    \n    return stones;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    stringstream ss(s);\n    string word;\n\n    // Replace commas with spaces to simplify splitting\n    for (char &c : s) {\n        if (c == ',') {\n            c = ' ';\n        }\n    }\n\n    // Use stringstream to extract words\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    return words;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Check if the range is valid\n    if (x > y) {\n        return -1;\n    }\n    \n    // Find the largest even number in the range\n    int largest_even;\n    if (y % 2 == 0) {\n        largest_even = y; // y is even\n    } else {\n        largest_even = y - 1; // y is odd, so take y - 1\n    }\n    \n    // Check if the largest even number is within the range [x, y]\n    if (largest_even >= x) {\n        return largest_even;\n    } else {\n        return -1; // No even number in the range\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n    \n    // Calculate the average\n    double average = (n + m) / 2.0;\n    \n    // Round down to the nearest integer\n    int rounded_average = floor(average);\n    \n    // Convert to binary\n    string binary = \"\";\n    if (rounded_average == 0) {\n        binary = \"0\";\n    } else {\n        while (rounded_average > 0) {\n            binary = to_string(rounded_average % 2) + binary;\n            rounded_average /= 2;\n        }\n    }\n    \n    return binary;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool has_even_digit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true; // Found an even digit\n        }\n        num /= 10;\n    }\n    return false; // No even digits found\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        if (!has_even_digit(num)) {\n            result.push_back(num); // Add to result if no even digits\n        }\n    }\n\n    sort(result.begin(), result.end()); // Sort the result vector\n    return result;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Step 1: Filter the array to keep only numbers between 1 and 9\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Step 2: Sort the filtered array\n    sort(filtered.begin(), filtered.end());\n\n    // Step 3: Reverse the sorted array\n    reverse(filtered.begin(), filtered.end());\n\n    // Step 4: Map integers to their corresponding string names\n    vector<string> result;\n    vector<string> names = {\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    \n    for (int num : filtered) {\n        result.push_back(names[num]); // num is guaranteed to be between 1 and 9\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            // Calculate factorial for even index\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial; // Store in the vector (0-based index)\n        } else {\n            // Calculate sum from 1 to i for odd index\n            result[i - 1] = (i * (i + 1)) / 2; // Sum of first i natural numbers\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is a palindrome\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    string reversedStr = string(str.rbegin(), str.rend());\n    return str == reversedStr;\n}\n\nvector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n\n    return {evenCount, oddCount};\n}\n\n// Example usage\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n// Function to calculate the sum of digits of a number\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0; // Check if the number is negative\n    num = abs(num); // Work with the absolute value for digit extraction\n\n    while (num > 0) {\n        int digit = num % 10; // Get the last digit\n        sum += is_negative ? -digit : digit; // Add the digit, considering the sign\n        num /= 10; // Remove the last digit\n    }\n\n    return sum;\n}\n\n// Function to count numbers with a sum of digits greater than 0\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Test cases\n"}
{"task_id": "CPP/109", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    // If the array is empty, return true\n    if (arr.empty()) {\n        return true;\n    }\n\n    int count_breaks = 0;\n    int n = arr.size();\n\n    // Check for breaks in the order\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            count_breaks++;\n        }\n    }\n\n    // If there is more than one break, return false\n    return count_breaks <= 1;\n}\n\n// Example usage\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount = 0;\n    int evenCountInLst2 = 0;\n\n    // Count odd numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount++;\n        }\n    }\n\n    // Count even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCountInLst2++;\n        }\n    }\n\n    // Check if we can replace all odd numbers in lst1 with even numbers from lst2\n    if (oddCount <= evenCountInLst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    map<char, int> countMap;\n    stringstream ss(test);\n    string word;\n\n    // Count occurrences of each letter\n    while (ss >> word) {\n        for (char c : word) {\n            countMap[c]++;\n        }\n    }\n\n    // Find the maximum count\n    int maxCount = 0;\n    for (const auto& pair : countMap) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Prepare the result map with letters that have the maximum count\n    map<char, int> resultMap;\n    for (const auto& pair : countMap) {\n        if (pair.second == maxCount) {\n            resultMap[pair.first] = pair.second;\n        }\n    }\n\n    return resultMap;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Create a set of characters to delete\n    unordered_set<char> charsToDelete(c.begin(), c.end());\n    \n    // Build the resulting string by excluding characters in charsToDelete\n    string result;\n    for (char ch : s) {\n        if (charsToDelete.find(ch) == charsToDelete.end()) {\n            result += ch;\n        }\n    }\n    \n    // Check if the resulting string is a palindrome\n    string reversedResult = result;\n    reverse(reversedResult.begin(), reversedResult.end());\n    bool isPalindrome = (result == reversedResult);\n    \n    // Prepare the output\n    vector<string> output;\n    output.push_back(result);\n    output.push_back(isPalindrome ? \"True\" : \"False\");\n    \n    return output;\n}\n\n// Example usage\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n\n    for (int i = 0; i < lst.size(); ++i) {\n        string str = lst[i];\n        int odd_count = 0;\n\n        // Count the number of odd digits in the current string\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) { // Check if the digit is odd\n                odd_count++;\n            }\n        }\n\n        // Create the output string with the required format\n        string output = \"the number of odd elements \" + to_string(odd_count) + \n                        \"n the str\" + to_string(i + 1) + \n                        \"ng \" + to_string(i + 1) + \n                        \" of the \" + to_string(i + 1) + \n                        \"nput.\";\n        \n        result.push_back(output);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\n#include <limits.h> // For INT_MAX\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long currentSum = 0;\n    long long minSum = LLONG_MAX; // Initialize to maximum possible value\n\n    for (long long num : nums) {\n        currentSum += num; // Add the current number to the current sum\n        if (currentSum < minSum) {\n            minSum = currentSum; // Update minSum if currentSum is smaller\n        }\n        // If currentSum is positive, reset it to 0\n        if (currentSum > 0) {\n            currentSum = 0;\n        }\n    }\n\n    return minSum;\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_times = 0;\n\n    for (const auto& well : grid) {\n        int units_of_water = 0;\n\n        // Count the number of 1s in the current well (row)\n        for (int water : well) {\n            if (water == 1) {\n                units_of_water++;\n            }\n        }\n\n        // Calculate the number of times we need to lower the bucket for this well\n        if (units_of_water > 0) {\n            total_times += (units_of_water + capacity - 1) / capacity; // Ceiling division\n        }\n    }\n\n    return total_times;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count the number of 1s in the binary representation of a number\nint countOnes(int n) {\n    int count = 0;\n    while (n) {\n        count += n & 1; // Increment count if the last bit is 1\n        n >>= 1;        // Right shift to check the next bit\n    }\n    return count;\n}\n\n// Custom comparator for sorting\nbool customComparator(int a, int b) {\n    int countA = countOnes(a);\n    int countB = countOnes(b);\n    \n    // First compare by number of 1s\n    if (countA != countB) {\n        return countA < countB;\n    }\n    // If the number of 1s is the same, compare by the decimal value\n    return a < b;\n}\n\n// Main sorting function\nvector<int> sort_array(vector<int> arr) {\n    sort(arr.begin(), arr.end(), customComparator);\n    return arr;\n}\n\n// Example usage\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\n// Function to count consonants in a word\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char c : word) {\n        // Check if the character is a letter and not a vowel\n        if (isalpha(c) && !strchr(\"aeiouAEIOU\", c)) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// Function to select words with exactly n consonants\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    if (s.empty()) {\n        return result; // Return empty vector if input string is empty\n    }\n\n    // Split the string into words\n    stringstream ss(s);\n    string word;\n\n    while (ss >> word) {\n        // Count consonants in the current word\n        int consonant_count = count_consonants(word);\n        // If the count matches n, add the word to the result\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    // Define the set of vowels\n    string vowels = \"aeiouAEIOU\";\n    int n = word.length();\n    \n    // We need at least 3 characters to have a vowel between two consonants\n    if (n < 3) {\n        return \"\";\n    }\n\n    // Iterate from the end of the string\n    for (int i = n - 2; i > 0; --i) {\n        // Check if the current character is a vowel\n        if (vowels.find(word[i]) != string::npos) {\n            // Check if the characters before and after are consonants\n            if (isalpha(word[i - 1]) && isalpha(word[i + 1]) && \n                vowels.find(word[i - 1]) == string::npos && \n                vowels.find(word[i + 1]) == string::npos) {\n                return string(1, word[i]); // Return the vowel as a string\n            }\n        }\n    }\n\n    // If no such vowel is found, return an empty string\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0];\n    string s2 = lst[1];\n\n    // Function to check if a concatenated string is balanced\n    auto is_balanced = [](const string& s1, const string& s2) {\n        int balance = 0;\n        for (char c : s1) {\n            balance += (c == '(') ? 1 : -1;\n            if (balance < 0) return false; // More ')' than '(' at any point\n        }\n        for (char c : s2) {\n            balance += (c == '(') ? 1 : -1;\n            if (balance < 0) return false; // More ')' than '(' at any point\n        }\n        return balance == 0; // Must end with equal number of '(' and ')'\n    };\n\n    // Check both concatenation orders\n    if (is_balanced(s1, s2) || is_balanced(s2, s1)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/120", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Step 2: Select the first k elements\n    vector<int> maxElements(arr.begin(), arr.begin() + k);\n    \n    // Step 3: Sort the selected k elements in ascending order\n    sort(maxElements.begin(), maxElements.end());\n    \n    return maxElements;\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (size_t i = 0; i < lst.size(); i++) {\n        // Check if the index is even and the element is odd\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i]; // Add the element to sum\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0; // Initialize sum to 0\n\n    // Loop through the first k elements of the array\n    for (int i = 0; i < k; i++) {\n        // Check if the element has at most two digits\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i]; // Add to sum if condition is met\n        }\n    }\n\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers; // Vector to store odd numbers\n    while (n != 1) {\n        if (n % 2 != 0) { // Check if n is odd\n            odd_numbers.push_back(n); // Add odd number to the vector\n        }\n        // Apply the Collatz rules\n        if (n % 2 == 0) {\n            n = n / 2; // If n is even, divide by 2\n        } else {\n            n = 3 * n + 1; // If n is odd, apply 3n + 1\n        }\n    }\n    // Add 1 to the vector, as it is the last term in the sequence\n    odd_numbers.push_back(1);\n\n    // Sort the vector in increasing order\n    sort(odd_numbers.begin(), odd_numbers.end());\n\n    return odd_numbers; // Return the sorted vector of odd numbers\n}\n\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) {\n        return false;\n    }\n\n    // Check if the date is in the format mm-dd-yyyy\n    if (date.size() != 10 || date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n\n    // Extract month, day, and year from the date string\n    int month, day, year;\n    stringstream ss(date);\n    string month_str, day_str, year_str;\n\n    getline(ss, month_str, '-');\n    getline(ss, day_str, '-');\n    getline(ss, year_str);\n\n    // Convert strings to integers\n    month = stoi(month_str);\n    day = stoi(day_str);\n    year = stoi(year_str);\n\n    // Check if month is valid\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    // Check if day is valid based on the month\n    if (day < 1) {\n        return false;\n    }\n\n    // Days in each month\n    if (month == 2) {\n        // Check for leap year for February\n        bool isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n        if (day > (isLeapYear ? 29 : 28)) {\n            return false;\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        if (day > 30) {\n            return false;\n        }\n    } else {\n        if (day > 31) {\n            return false;\n        }\n    }\n\n    // If all checks passed, the date is valid\n    return true;\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    // Check for whitespace\n    if (txt.find(' ') != string::npos) {\n        // Split by whitespace\n        vector<string> result;\n        stringstream ss(txt);\n        string word;\n        while (ss >> word) {\n            result.push_back(word);\n        }\n        return result;\n    }\n    \n    // Check for commas\n    if (txt.find(',') != string::npos) {\n        // Split by commas\n        vector<string> result;\n        stringstream ss(txt);\n        string word;\n        while (getline(ss, word, ',')) {\n            result.push_back(word);\n        }\n        return result;\n    }\n    \n    // If no whitespace or commas, count lowercase letters in odd positions\n    int count = 0;\n    for (char c : txt) {\n        if (islower(c)) {\n            int position = c - 'a'; // Get the position of the letter\n            if (position % 2 == 1) { // Check if it's odd\n                count++;\n            }\n        }\n    }\n    \n    // Return the count as a string in a vector\n    return {to_string(count)};\n}\n\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check for duplicates\n    unordered_map<int, int> count_map;\n    for (int num : lst) {\n        count_map[num]++;\n        if (count_map[num] > 2) {\n            return false; // More than two occurrences\n        }\n    }\n\n    // Check if the vector is sorted\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i - 1]) {\n            return false; // Not sorted\n        }\n    }\n\n    return true; // Sorted and no duplicates\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    // Extracting start and end points from the intervals\n    int start1 = interval1[0], end1 = interval1[1];\n    int start2 = interval2[0], end2 = interval2[1];\n\n    // Calculate the intersection\n    int start = max(start1, start2);\n    int end = min(end1, end2);\n\n    // Calculate the length of the intersection\n    if (end < start) {\n        return \"NO\"; // No intersection\n    }\n\n    int length = end - start + 1; // Length of the intersection\n\n    // Check if the length is a prime number\n    if (isPrime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/128", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768; // Return -32768 for empty array\n    }\n\n    int sum_magnitudes = 0;\n    int product_signs = 1; // Start with 1 for multiplication\n\n    for (int num : arr) {\n        if (num > 0) {\n            sum_magnitudes += num; // Add magnitude\n            product_signs *= 1; // Positive sign\n        } else if (num < 0) {\n            sum_magnitudes += -num; // Add magnitude\n            product_signs *= -1; // Negative sign\n        } else { // num == 0\n            product_signs = 0; // If any number is 0, product of signs is 0\n            break; // No need to check further\n        }\n    }\n\n    return sum_magnitudes * product_signs; // Return the final result\n}\n\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> bestPath;\n    \n    void dfs(vector<vector<int>>& grid, vector<int>& currentPath, int x, int y, int k) {\n        currentPath.push_back(grid[x][y]);\n        \n        if (currentPath.size() == k) {\n            if (bestPath.empty() || currentPath < bestPath) {\n                bestPath = currentPath;\n            }\n        } else {\n            // Explore neighbors\n            int N = grid.size();\n            vector<pair<int, int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n            for (auto& dir : directions) {\n                int newX = x + dir.first;\n                int newY = y + dir.second;\n                if (newX >= 0 && newX < N && newY >= 0 && newY < N) {\n                    dfs(grid, currentPath, newX, newY, k);\n                }\n            }\n        }\n        \n        currentPath.pop_back(); // Backtrack\n    }\n    \n    vector<int> minPath(vector<vector<int>> grid, int k) {\n        int N = grid.size();\n        bestPath.clear();\n        \n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                vector<int> currentPath;\n                dfs(grid, currentPath, i, j, k);\n            }\n        }\n        \n        return bestPath;\n    }\n};\n\n"}
{"task_id": "CPP/130", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> result(n + 1); // Create a vector to hold the first n + 1 numbers of the Tribonacci sequence\n\n    // Base case\n    if (n >= 0) result[0] = 3; // tri(1) = 3\n    if (n >= 1) result[1] = 1 + (1 / 2); // tri(2) = 1 + (2 / 2) = 2\n    if (n >= 2) result[2] = 2; // tri(2) = 2\n\n    // Calculate the rest of the values based on the rules\n    for (int i = 3; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result[i] = 1 + (i / 2); // If n is even\n        } else {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1]; // If n is odd\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <stdio.h>\n\nint digits(int n) {\n    int product = 1;\n    bool foundOdd = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply to the product\n            foundOdd = true; // Mark that we've found an odd digit\n        }\n        n /= 10; // Remove the last digit\n    }\n\n    return foundOdd ? product : 0; // Return product if odd digits found, else return 0\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int openCount = 0; // Count of open brackets\n    int nestedCount = 0; // Count of nested brackets\n\n    for (char ch : str) {\n        if (ch == '[') {\n            openCount++; // Increment open bracket count\n            if (openCount > 1) {\n                nestedCount++; // We have found a nested bracket\n            }\n        } else if (ch == ']') {\n            if (openCount > 0) {\n                openCount--; // A matching open bracket is found\n            } else {\n                return false; // More closing brackets than opening\n            }\n        }\n    }\n\n    // We need at least one nested bracket and all brackets must be matched\n    return nestedCount > 0 && openCount == 0;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int rounded = ceil(num); // Round up to the nearest integer\n        sum += rounded * rounded; // Square the rounded value and add to sum\n    }\n    return sum;\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha\n\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Trim trailing spaces\n    size_t end = txt.find_last_not_of(' ');\n    if (end == string::npos) {\n        return false; // String is empty or only spaces\n    }\n    txt = txt.substr(0, end + 1); // Trimmed string\n\n    // Check if the last character is an alphabetical character\n    char lastChar = txt.back();\n    if (!isalpha(lastChar)) {\n        return false; // Last character is not a letter\n    }\n\n    // Check if the last character is part of a word\n    if (txt.length() > 1 && isalpha(txt[txt.length() - 2])) {\n        return false; // Last character is preceded by another letter\n    }\n\n    return true; // Last character is a letter and not part of a word\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int n = arr.size();\n    \n    // Iterate from the second last element to the first element\n    for (int i = n - 2; i >= 0; i--) {\n        // Check if the current element is not greater than or equal to the next element\n        if (arr[i] >= arr[i + 1]) {\n            return i + 1; // Return the index of the element\n        }\n    }\n    \n    // If no such element exists, return -1\n    return -1;\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\n#include <limits> // For numeric limits\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = numeric_limits<int>::min(); // Start with the smallest possible integer\n    int smallest_positive = numeric_limits<int>::max(); // Start with the largest possible integer\n\n    bool found_negative = false;\n    bool found_positive = false;\n\n    for (int num : lst) {\n        if (num < 0) {\n            found_negative = true;\n            if (num > largest_negative) {\n                largest_negative = num; // Update largest negative\n            }\n        } else if (num > 0) {\n            found_positive = true;\n            if (num < smallest_positive) {\n                smallest_positive = num; // Update smallest positive\n            }\n        }\n    }\n\n    // If no negative number was found, set largest_negative to 0\n    if (!found_negative) {\n        largest_negative = 0;\n    }\n    \n    // If no positive number was found, set smallest_positive to 0\n    if (!found_positive) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n#include <sstream>\n#include <locale>\n\nusing namespace std;\n\n// Function to convert a string to a float, handling both '.' and ',' as decimal points\nfloat string_to_float(const string& str) {\n    string s = str;\n    replace(s.begin(), s.end(), ',', '.'); // Replace ',' with '.' for float conversion\n    return stof(s);\n}\n\n// Function to compare two boost::any variables\nboost::any compare_one(boost::any a, boost::any b) {\n    // Check if both are of the same type\n    if (a.type() == b.type()) {\n        if (a.type() == typeid(int)) {\n            int int_a = boost::any_cast<int>(a);\n            int int_b = boost::any_cast<int>(b);\n            if (int_a == int_b) return \"None\";\n            return (int_a > int_b) ? int_a : int_b;\n        } else if (a.type() == typeid(float)) {\n            float float_a = boost::any_cast<float>(a);\n            float float_b = boost::any_cast<float>(b);\n            if (float_a == float_b) return \"None\";\n            return (float_a > float_b) ? float_a : float_b;\n        } else if (a.type() == typeid(string)) {\n            string str_a = boost::any_cast<string>(a);\n            string str_b = boost::any_cast<string>(b);\n            float float_a = string_to_float(str_a);\n            float float_b = string_to_float(str_b);\n            if (float_a == float_b) return \"None\";\n            return (float_a > float_b) ? str_a : str_b;\n        }\n    } else {\n        // If types are different, we need to convert them to comparable types\n        float float_a, float_b;\n\n        if (a.type() == typeid(int)) {\n            float_a = boost::any_cast<int>(a);\n            if (b.type() == typeid(float)) {\n                float_b = boost::any_cast<float>(b);\n            } else if (b.type() == typeid(string)) {\n                float_b = string_to_float(boost::any_cast<string>(b));\n            }\n        } else if (a.type() == typeid(float)) {\n            float_a = boost::any_cast<float>(a);\n            if (b.type() == typeid(int)) {\n                float_b = boost::any_cast<int>(b);\n            } else if (b.type() == typeid(string)) {\n                float_b = string_to_float(boost::any_cast<string>(b));\n            }\n        } else if (a.type() == typeid(string)) {\n            float_a = string_to_float(boost::any_cast<string>(a));\n            if (b.type() == typeid(int)) {\n                float_b = boost::any_cast<int>(b);\n            } else if (b.type() == typeid(float)) {\n                float_b = boost::any_cast<float>(b);\n            }\n        }\n\n        if (float_a == float_b) return \"None\";\n        return (float_a > float_b) ? a : b;\n    }\n\n    return \"None\"; // Fallback case\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <stdio.h>\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is less than 8 or if n is odd\n    if (n < 8 || n % 2 != 0) {\n        return false;\n    }\n    return true; // n is even and >= 8\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate factorial of a number\nlong long factorial(int num) {\n    long long result = 1;\n    for (int i = 1; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to calculate the Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int space_count = 0; // To count consecutive spaces\n\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++; // Increment space count\n        } else {\n            // If we have counted spaces, we need to handle them\n            if (space_count > 0) {\n                if (space_count == 1) {\n                    result += '_'; // Replace single space with underscore\n                } else {\n                    result += '-'; // Replace more than one space with hyphen\n                }\n                space_count = 0; // Reset space count\n            }\n            result += c; // Add the current character to the result\n        }\n    }\n\n    // Handle any trailing spaces at the end of the string\n    if (space_count > 0) {\n        if (space_count == 1) {\n            result += '_'; // Replace single space with underscore\n        } else {\n            result += '-'; // Replace more than one space with hyphen\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check for exactly one dot\n    size_t dot_pos = file_name.find('.');\n    if (dot_pos == string::npos || file_name.find('.', dot_pos + 1) != string::npos) {\n        return \"No\";\n    }\n\n    // Split the file name into name and extension\n    string name_part = file_name.substr(0, dot_pos);\n    string ext_part = file_name.substr(dot_pos + 1);\n\n    // Check if the name part is empty and starts with a letter\n    if (name_part.empty() || !isalpha(name_part[0])) {\n        return \"No\";\n    }\n\n    // Check for valid extension\n    if (ext_part != \"txt\" && ext_part != \"exe\" && ext_part != \"dll\") {\n        return \"No\";\n    }\n\n    // Count digits in the name part\n    int digit_count = 0;\n    for (char c : name_part) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n    }\n\n    // Check for the digit count\n    if (digit_count > 3) {\n        return \"No\";\n    }\n\n    // If all conditions are met, return \"Yes\"\n    return \"Yes\";\n}\n\n// Example usage\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int total_sum = 0;\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            // Index is a multiple of 3, square the element\n            total_sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            // Index is a multiple of 4 but not a multiple of 3, cube the element\n            total_sum += lst[i] * lst[i] * lst[i];\n        } else {\n            // Index is neither a multiple of 3 nor 4, add the element as is\n            total_sum += lst[i];\n        }\n    }\n\n    return total_sum;\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to extract words with prime lengths\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    vector<string> prime_length_words;\n\n    // Split the sentence into words\n    while (ss >> word) {\n        // Check if the length of the word is prime\n        if (is_prime(word.length())) {\n            prime_length_words.push_back(word);\n        }\n    }\n\n    // Join the words with prime lengths into a single string\n    string result;\n    for (size_t i = 0; i < prime_length_words.size(); ++i) {\n        result += prime_length_words[i];\n        if (i < prime_length_words.size() - 1) {\n            result += \" \"; // Add space between words\n        }\n    }\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Parse the first fraction x\n    size_t pos = x.find('/');\n    int numerator_x = stoi(x.substr(0, pos));\n    int denominator_x = stoi(x.substr(pos + 1));\n\n    // Parse the second fraction n\n    pos = n.find('/');\n    int numerator_n = stoi(n.substr(0, pos));\n    int denominator_n = stoi(n.substr(pos + 1));\n\n    // Calculate the product of the fractions\n    int product_numerator = numerator_x * numerator_n;\n    int product_denominator = denominator_x * denominator_n;\n\n    // Check if the product is a whole number\n    return product_numerator % product_denominator == 0;\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n// Helper function to calculate the sum of digits\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = abs(num); // Work with the absolute value\n\n    // Store the original number for later use\n    int original_num = num;\n\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n\n    // If the number was negative, subtract twice the first digit\n    if (is_negative) {\n        // Calculate the first digit of the original number\n        int first_digit = original_num;\n        while (first_digit >= 10) {\n            first_digit /= 10;\n        }\n        sum -= 2 * first_digit; // Subtract twice the first digit\n    }\n\n    return sum;\n}\n\n// Comparator function for sorting\nbool custom_compare(const pair<int, int>& a, const pair<int, int>& b) {\n    int sum_a = sum_of_digits(a.first);\n    int sum_b = sum_of_digits(b.first);\n    \n    if (sum_a == sum_b) {\n        return a.second < b.second; // Maintain original order if sums are equal\n    }\n    return sum_a < sum_b; // Sort by sum of digits\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    vector<pair<int, int>> indexed_nums;\n\n    // Create a vector of pairs (value, original index)\n    for (int i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({nums[i], i});\n    }\n\n    // Sort using the custom comparator\n    sort(indexed_nums.begin(), indexed_nums.end(), custom_compare);\n\n    // Extract the sorted values\n    vector<int> sorted_nums;\n    for (const auto& p : indexed_nums) {\n        sorted_nums.push_back(p.first);\n    }\n\n    return sorted_nums;\n}\n\n// Example usage\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n\n    for (int num : nums) {\n        // Check if the number is greater than 10\n        if (num > 10) {\n            // Convert the number to a string to easily access digits\n            string numStr = to_string(num);\n            // Get the first and last characters (digits)\n            char firstDigit = numStr[0];\n            char lastDigit = numStr[numStr.length() - 1];\n\n            // Check if both first and last digits are odd\n            if ((firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || firstDigit == '7' || firstDigit == '9') &&\n                (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' || lastDigit == '7' || lastDigit == '9')) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Step 1: Calculate the values of a[i]\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1; // a[i] corresponds to a[i-1] in 0-indexed vector\n    }\n    \n    // Step 2: Count occurrences of each modulo 3 value\n    int count[3] = {0, 0, 0};\n    for (int i = 0; i < n; ++i) {\n        count[a[i] % 3]++;\n    }\n    \n    // Step 3: Count valid triples\n    int totalTriples = 0;\n    \n    // Case 1: All three numbers are 0 mod 3\n    if (count[0] >= 3) {\n        totalTriples += (count[0] * (count[0] - 1) * (count[0] - 2)) / 6;\n    }\n    \n    // Case 2: All three numbers are 1 mod 3\n    if (count[1] >= 3) {\n        totalTriples += (count[1] * (count[1] - 1) * (count[1] - 2)) / 6;\n    }\n    \n    // Case 3: All three numbers are 2 mod 3\n    if (count[2] >= 3) {\n        totalTriples += (count[2] * (count[2] - 1) * (count[2] - 2)) / 6;\n    }\n    \n    // Case 4: One from each category (0, 1, 2)\n    totalTriples += count[0] * count[1] * count[2];\n    \n    return totalTriples;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // List of planets in order from the Sun\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Find the indices of the given planets\n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n    \n    // Check if both planets are valid\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {}; // Return empty vector if either planet is invalid\n    }\n    \n    // Get the indices of the planets\n    int index1 = distance(planets.begin(), it1);\n    int index2 = distance(planets.begin(), it2);\n    \n    // Ensure index1 is less than index2\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Collect planets between index1 and index2\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/149", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> vector_sort(vector<string> lst) {\n    // Step 1: Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0; // Keep only even-length strings\n    }), lst.end());\n\n    // Step 2: Sort the remaining strings\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Sort alphabetically if lengths are the same\n        }\n        return a.length() < b.length(); // Sort by length\n    });\n\n    // Step 3: Return the sorted vector\n    return lst;\n}\n\n// Example usage\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false; // Numbers less than or equal to 1 are not prime\n    for (int i = 2; i * i <= n; i++) { // Check for factors up to the square root of n\n        if (n % i == 0) return false; // If n is divisible by i, it's not prime\n    }\n    return true; // If no factors were found, n is prime\n}\n\n// Function to return x if n is prime, otherwise return y\nint x_or_y(int n, int x, int y) {\n    if (isPrime(n)) {\n        return x; // Return x if n is prime\n    } else {\n        return y; // Return y if n is not prime\n    }\n}\n\n// Main function to test the x_or_y function\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for std::floor\n\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0; // Initialize sum to 0\n\n    for (float num : lst) {\n        // Check if the number is a non-negative integer\n        if (num >= 0 && std::floor(num) == num) {\n            int intNum = static_cast<int>(num); // Convert to integer\n            // Check if the number is odd\n            if (intNum % 2 != 0) {\n                sum += intNum * intNum; // Add the square of the odd number\n            }\n        }\n    }\n\n    return sum; // Return the total sum\n}\n\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for abs function\n\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result; // Vector to store the results\n    int n = game.size(); // Get the size of the input vectors\n\n    for (int i = 0; i < n; i++) {\n        // Calculate the absolute difference and add it to the result vector\n        result.push_back(abs(game[i] - guess[i]));\n    }\n\n    return result; // Return the result vector\n}\n\n// Example usage\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = INT_MIN; // Initialize to the smallest integer\n    string strongest_extension = \"\";\n\n    for (const string& extension : extensions) {\n        int CAP = 0;\n        int SM = 0;\n\n        // Calculate CAP and SM\n        for (char c : extension) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n\n        // Calculate strength\n        int strength = CAP - SM;\n\n        // Check if this extension is stronger\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    // Return the result in the specified format\n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // If b is longer than a, it can't be a substring\n    if (b.length() > a.length()) {\n        return false;\n    }\n    \n    // Concatenate b with itself\n    string b_double = b + b;\n    \n    // Check if a contains any substring of b_double of length equal to b\n    return b_double.find(a) != string::npos;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // For abs function\n\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Use absolute value to handle negative numbers\n    num = abs(num);\n    \n    int even_count = 0;\n    int odd_count = 0;\n\n    // Check each digit\n    while (num > 0) {\n        int digit = num % 10; // Get the last digit\n        if (digit % 2 == 0) {\n            even_count++; // Increment even count\n        } else {\n            odd_count++; // Increment odd count\n        }\n        num /= 10; // Remove the last digit\n    }\n\n    // Return the counts as a vector\n    return {even_count, odd_count};\n}\n\n// Example usage\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the Roman numeral symbols and their corresponding integer values\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string result = \"\";\n    \n    // Iterate through the defined Roman numeral pairs\n    for (const auto& pair : roman_numerals) {\n        while (number >= pair.first) {\n            result += pair.second; // Append the Roman numeral symbol\n            number -= pair.first;  // Decrease the number by the corresponding value\n        }\n    }\n    \n    return result; // Return the final Roman numeral string\n}\n\n// Example usage\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to identify the longest side\n    float x, y, z;\n    if (a >= b && a >= c) {\n        x = a; y = b; z = c;\n    } else if (b >= a && b >= c) {\n        x = b; y = a; z = c;\n    } else {\n        x = c; y = a; z = b;\n    }\n\n    // Check the Pythagorean theorem\n    return (fabs(y * y + z * z - x * x) < 1e-6); // Using a small epsilon for floating point comparison\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string max_word;\n    int max_unique_count = 0;\n\n    for (const string& word : words) {\n        // Use a set to count unique characters\n        unordered_set<char> unique_chars(word.begin(), word.end());\n        int unique_count = unique_chars.size();\n\n        // Check if this word has more unique characters or is lexicographically smaller\n        if (unique_count > max_unique_count || \n            (unique_count == max_unique_count && (max_word.empty() || word < max_word))) {\n            max_unique_count = unique_count;\n            max_word = word;\n        }\n    }\n\n    return max_word;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Calculate total carrots needed\n    int totalEaten = number + need;\n    \n    // Check if there are enough remaining carrots\n    if (remaining >= need) {\n        // Eat the needed amount\n        remaining -= need;\n    } else {\n        // Eat all remaining carrots\n        totalEaten += remaining; // Add remaining carrots to total eaten\n        remaining = 0; // No carrots left\n    }\n    \n    // Return the result as a vector\n    return {totalEaten, remaining};\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stdexcept>\n\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    if (operato.size() != operand.size() - 1) {\n        throw invalid_argument(\"The length of operator vector must be one less than the operand vector.\");\n    }\n\n    // Start with the first operand\n    int result = operand[0];\n\n    // Iterate through operators and operands\n    for (size_t i = 0; i < operato.size(); ++i) {\n        string op = operato[i];\n        int next_operand = operand[i + 1];\n\n        if (op == \"+\") {\n            result += next_operand;\n        } else if (op == \"-\") {\n            result -= next_operand;\n        } else if (op == \"*\") {\n            result *= next_operand;\n        } else if (op == \"//\") {\n            if (next_operand == 0) {\n                throw invalid_argument(\"Division by zero is not allowed.\");\n            }\n            result /= next_operand; // Floor division\n        } else if (op == \"**\") {\n            result = pow(result, next_operand);\n        } else {\n            throw invalid_argument(\"Invalid operator: \" + op);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\n#include <algorithm> // For std::reverse\n\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetter = false;\n\n    // Check if the string contains any letters\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    if (hasLetter) {\n        // Reverse case of letters\n        for (char &c : s) {\n            if (isalpha(c)) {\n                if (islower(c)) {\n                    c = toupper(c); // Convert to uppercase\n                } else {\n                    c = tolower(c); // Convert to lowercase\n                }\n            }\n        }\n    } else {\n        // Reverse the entire string\n        reverse(s.begin(), s.end());\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n#include <sstream>\n#include <iomanip>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    // If the input string is empty, return None (represented as an empty string in C++)\n    if (text.empty()) {\n        return \"\";\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    // Convert the MD5 hash to a hexadecimal string\n    stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {\n        ss << hex << setw(2) << setfill('0') << (int)digest[i];\n    }\n\n    return ss.str();\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> result;\n    // Determine the range\n    int start = min(a, b);\n    int end = max(a, b);\n    \n    // Loop through the range\n    for (int i = start; i <= end; i++) {\n        // Check if the number is an even digit\n        if (i >= 0 && i < 10 && i % 2 == 0) {\n            result.push_back(i);\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/0", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n#include <cmath>     // for std::abs\n\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the vector\n    sort(numbers.begin(), numbers.end());\n\n    // Check adjacent elements for closeness\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (fabs(numbers[i + 1] - numbers[i]) < threshold) {\n            return true; // Found two elements closer than the threshold\n        }\n    }\n    \n    return false; // No elements found that are closer than the threshold\n}\n\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype> // for isspace\n\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        // Ignore spaces\n        if (isspace(ch)) {\n            continue;\n        }\n\n        // Add the character to the current group\n        current_group += ch;\n\n        // Update the balance\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n        }\n\n        // If balance is zero, we have a complete group\n        if (balance == 0 && !current_group.empty()) {\n            result.push_back(current_group);\n            current_group.clear(); // Reset for the next group\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat truncate_number(float number) {\n    // Get the integer part of the number\n    int integer_part = floor(number);\n    // Calculate the decimal part\n    float decimal_part = number - integer_part;\n    return decimal_part;\n}\n\n"}
{"task_id": "CPP/3", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with a zero balance\n\n    for (int operation : operations) {\n        balance += operation; // Update the balance with the current operation\n        if (balance < 0) { // Check if the balance falls below zero\n            return true; // Return true if it does\n        }\n    }\n    \n    return false; // Return false if balance never goes below zero\n}\n\n"}
{"task_id": "CPP/4", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for fabs\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Step 1: Calculate the mean\n    float sum = 0.0;\n    int n = numbers.size();\n    \n    for (float num : numbers) {\n        sum += num;\n    }\n    \n    float mean = sum / n;\n\n    // Step 2: Calculate the absolute differences and their average\n    float mad_sum = 0.0;\n    \n    for (float num : numbers) {\n        mad_sum += fabs(num - mean); // fabs for absolute value\n    }\n    \n    float mad = mad_sum / n; // Step 3: Average of absolute differences\n    \n    return mad;\n}\n\n"}
{"task_id": "CPP/5", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimiter) {\n    vector<int> result;\n\n    // Check if the input vector is empty\n    if (numbers.empty()) {\n        return result; // Return an empty vector\n    }\n\n    // Iterate through the input vector\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]); // Add the current element\n\n        // If it's not the last element, add the delimiter\n        if (i < numbers.size() - 1) {\n            result.push_back(delimiter);\n        }\n    }\n\n    return result; // Return the result vector\n}\n\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    stringstream ss(paren_string);\n    string group;\n\n    while (ss >> group) { // Read each group separated by spaces\n        int current_level = 0;\n        int max_level = 0;\n\n        for (char ch : group) {\n            if (ch == '(') {\n                current_level++;\n                if (current_level > max_level) {\n                    max_level = current_level; // Update max level\n                }\n            } else if (ch == ')') {\n                current_level--;\n            }\n        }\n\n        result.push_back(max_level); // Store the max level for the current group\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/7", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_substring(const vector<string>& strings, const string& substring) {\n    vector<string> filtered;\n\n    // Iterate through each string in the input vector\n    for (const string& str : strings) {\n        // Check if the substring is found in the current string\n        if (str.find(substring) != string::npos) {\n            // If found, add to the filtered results\n            filtered.push_back(str);\n        }\n    }\n\n    return filtered;\n}\n\n"}
{"task_id": "CPP/8", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // Check if the vector is empty\n    if (numbers.empty()) {\n        return {sum, product}; // Return (0, 1) for empty vector\n    }\n\n    // Calculate sum and product\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return {sum, product};\n}\n\n"}
{"task_id": "CPP/9", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(const vector<int>& numbers) {\n    vector<int> result; // Vector to store the rolling maximums\n    int current_max = INT_MIN; // Initialize current_max to the smallest possible integer\n\n    for (int num : numbers) {\n        // Update current_max if the current number is greater\n        if (num > current_max) {\n            current_max = num;\n        }\n        // Add the current maximum to the result vector\n        result.push_back(current_max);\n    }\n\n    return result; // Return the vector of rolling maximums\n}\n\n"}
{"task_id": "CPP/10", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(const string& str) {\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(const string& str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n    int n = str.length();\n    \n    // Find the longest palindromic suffix\n    for (int i = n; i >= 0; --i) {\n        if (is_palindrome(str.substr(i))) {\n            // If the suffix from index i to the end is a palindrome\n            // Append the reverse of the prefix (from 0 to i-1)\n            string prefix = str.substr(0, i);\n            string reversed_prefix(prefix.rbegin(), prefix.rend());\n            return str + reversed_prefix;\n        }\n    }\n    \n    // If no palindromic suffix is found, return the original string + its reverse\n    return str + string(str.rbegin(), str.rend());\n}\n\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Ensure both strings are of the same length\n    if (a.length() != b.length()) {\n        throw invalid_argument(\"Strings must be of the same length\");\n    }\n\n    string result = \"\";\n    for (size_t i = 0; i < a.length(); ++i) {\n        // Perform XOR operation\n        if (a[i] == b[i]) {\n            result += '0'; // Same bits yield 0\n        } else {\n            result += '1'; // Different bits yield 1\n        }\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <optional> // For std::optional\n\n// Function prototype for longest\nstd::optional<std::string> longest(const std::vector<std::string>& strings);\n\nstd::optional<std::string> longest(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return std::nullopt; // Return None (or nullopt in C++)\n    }\n\n    std::string longestStr = strings[0]; // Start with the first string\n\n    for (const auto& str : strings) {\n        if (str.length() > longestStr.length()) {\n            longestStr = str; // Update longest string\n        }\n    }\n\n    return longestStr; // Return the longest string found\n}\n\n"}
{"task_id": "CPP/13", "generation": "#include <iostream>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Ensure a and b are non-negative\n    a = abs(a);\n    b = abs(b);\n    \n    // Apply the Euclidean algorithm\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n"}
{"task_id": "CPP/14", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes; // Vector to store the prefixes\n    for (size_t i = 1; i <= str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i)); // Add the prefix from index 0 to i\n    }\n    return prefixes; // Return the vector of prefixes\n}\n\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss; // Create a stringstream to build the output string\n    for (int i = 0; i <= n; ++i) {\n        ss << i; // Add the current number to the stringstream\n        if (i < n) {\n            ss << \" \"; // Add a space if it's not the last number\n        }\n    }\n    return ss.str(); // Convert the stringstream to a string and return it\n}\n\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <unordered_set>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    unordered_set<char> distinct_chars; // Set to store distinct characters\n\n    // Convert each character to lowercase and insert into the set\n    for (char c : str) {\n        distinct_chars.insert(tolower(c)); // Use tolower to ignore case\n    }\n\n    // The size of the set is the number of distinct characters\n    return distinct_chars.size();\n}\n\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    stringstream ss(music_string);\n    string note;\n\n    while (ss >> note) {\n        if (note == \"o\") {\n            beats.push_back(4); // whole note\n        } else if (note == \"o|\") {\n            beats.push_back(2); // half note\n        } else if (note == \".|\") {\n            beats.push_back(1); // quarter note\n        }\n    }\n\n    return beats;\n}\n\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (substring.empty()) {\n        return 0; // If the substring is empty, return 0\n    }\n\n    int count = 0;\n    size_t pos = 0;\n\n    // Loop until we find the substring in the string\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++; // Increment count for each found occurrence\n        pos++;   // Move to the next character to allow overlapping\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Mapping from string to integer\n    map<string, int> num_map = {\n        {\"zero\", 0},\n        {\"one\", 1},\n        {\"two\", 2},\n        {\"three\", 3},\n        {\"four\", 4},\n        {\"five\", 5},\n        {\"six\", 6},\n        {\"seven\", 7},\n        {\"eight\", 8},\n        {\"nine\", 9}\n    };\n\n    // Vector to hold the integer values\n    vector<int> num_values;\n    stringstream ss(numbers);\n    string word;\n\n    // Split the input string and convert to integers\n    while (ss >> word) {\n        if (num_map.find(word) != num_map.end()) {\n            num_values.push_back(num_map[word]);\n        }\n    }\n\n    // Sort the integer values\n    sort(num_values.begin(), num_values.end());\n\n    // Convert sorted integers back to strings\n    vector<string> sorted_words;\n    for (int num : num_values) {\n        for (const auto& pair : num_map) {\n            if (pair.second == num) {\n                sorted_words.push_back(pair.first);\n                break;\n            }\n        }\n    }\n\n    // Join the sorted words into a single string\n    string result;\n    for (size_t i = 0; i < sorted_words.size(); ++i) {\n        result += sorted_words[i];\n        if (i < sorted_words.size() - 1) {\n            result += \" \"; // Add space between words\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/20", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\npair<float, float> find_closest_elements(vector<float> numbers) {\n    // Sort the numbers\n    sort(numbers.begin(), numbers.end());\n\n    // Initialize variables to track the closest pair and the smallest difference\n    float min_diff = numeric_limits<float>::max();\n    pair<float, float> closest_pair;\n\n    // Iterate through the sorted numbers to find the closest pair\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = make_pair(numbers[i], numbers[i + 1]);\n        }\n    }\n\n    return closest_pair;\n}\n\n"}
{"task_id": "CPP/21", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::min_element and std::max_element\n\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    // Find the minimum and maximum values in the vector\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n\n    // Create a new vector to hold the rescaled values\n    vector<float> rescaled;\n\n    // Rescale each number\n    for (float num : numbers) {\n        float rescaled_value = (num - min_val) / (max_val - min_val);\n        rescaled.push_back(rescaled_value);\n    }\n\n    return rescaled;\n}\n\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\n\nstd::vector<int> filter_integers(list_any values) {\n    std::vector<int> result;\n\n    for (const auto& value : values) {\n        try {\n            // Attempt to cast the boost::any to an int\n            int intValue = boost::any_cast<int>(value);\n            result.push_back(intValue);\n        } catch (const boost::bad_any_cast& e) {\n            // If the cast fails, we simply ignore the value\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to return the length of the given string\nint strlen(const string& str) {\n    return str.size(); // or str.length();\n}\n\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    // Start from n-1 and go downwards to find the largest divisor\n    for (int i = n - 1; i > 0; i--) {\n        if (n % i == 0) {\n            return i; // Return the first divisor found\n        }\n    }\n    return 1; // In case n is 1, the largest divisor is 1\n}\n\n"}
{"task_id": "CPP/25", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i * i <= n; i += 2) {\n        // While i divides n, add i and divide n\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(const vector<int>& numbers) {\n    unordered_map<int, int> frequency;\n    \n    // Count the frequency of each number\n    for (int num : numbers) {\n        frequency[num]++;\n    }\n    \n    vector<int> result;\n    \n    // Add elements that occur only once to the result\n    for (int num : numbers) {\n        if (frequency[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/27", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for islower and isupper\n\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) { // Use a reference to modify the original string\n        if (islower(c)) {\n            c = toupper(c); // Convert to uppercase\n        } else if (isupper(c)) {\n            c = tolower(c); // Convert to lowercase\n        }\n    }\n    return str;\n}\n\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result; // Initialize an empty string to hold the concatenated result\n    for (const string& str : strings) { // Iterate through each string in the vector\n        result += str; // Append the current string to the result\n    }\n    return result; // Return the concatenated string\n}\n\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_prefix(const vector<string>& strings, const string& prefix) {\n    vector<string> filtered_strings;\n\n    for (const auto& str : strings) {\n        // Check if the string starts with the given prefix\n        if (str.rfind(prefix, 0) == 0) { // rfind with position 0 checks for prefix\n            filtered_strings.push_back(str);\n        }\n    }\n\n    return filtered_strings;\n}\n\n"}
{"task_id": "CPP/30", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positive_numbers; // Vector to store positive numbers\n    for (float num : l) { // Iterate through each number in the input vector\n        if (num > 0) { // Check if the number is positive\n            positive_numbers.push_back(num); // Add to the positive numbers vector\n        }\n    }\n    return positive_numbers; // Return the vector of positive numbers\n}\n\n"}
{"task_id": "CPP/31", "generation": "#include <stdio.h>\n#include <stdbool.h>\n\nbool is_prime(long long n) {\n    // Handle special cases\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    if (n <= 3) return true;  // 2 and 3 are prime numbers\n\n    // Eliminate even numbers and multiples of 3\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    // Check for factors from 5 to the square root of n\n    for (long long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n"}
{"task_id": "CPP/32", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\ndouble poly(const vector<double>& xs, double x) {\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble poly_derivative(const vector<double>& xs, double x) {\n    double sum = 0;\n    for (int i = 1; i < xs.size(); i++) {\n        sum += i * xs[i] * pow(x, i - 1);\n    }\n    return sum;\n}\n\ndouble find_zero(const vector<double>& xs) {\n    // Initial guess (can be adjusted based on the polynomial)\n    double x0 = 0.0; // A reasonable starting point\n    double tolerance = 1e-7; // Tolerance for convergence\n    int max_iterations = 1000; // Maximum number of iterations\n\n    for (int i = 0; i < max_iterations; i++) {\n        double f_x0 = poly(xs, x0);\n        double f_prime_x0 = poly_derivative(xs, x0);\n\n        if (fabs(f_prime_x0) < tolerance) {\n            // Avoid division by zero\n            cout << \"Derivative too small, stopping.\" << endl;\n            break;\n        }\n\n        double x1 = x0 - f_x0 / f_prime_x0; // Newton-Raphson formula\n\n        if (fabs(x1 - x0) < tolerance) {\n            return x1; // Converged to a root\n        }\n\n        x0 = x1; // Update x0 for the next iteration\n    }\n\n    cout << \"Max iterations reached, returning last estimate.\" << endl;\n    return x0; // Return the last estimate if not converged\n}\n\n"}
{"task_id": "CPP/33", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> indices; // To store the values at indices divisible by 3\n\n    // Collect values at indices divisible by 3\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            indices.push_back(l[i]);\n        }\n    }\n\n    // Sort the collected values\n    sort(indices.begin(), indices.end());\n\n    // Replace the original values at indices divisible by 3 with sorted values\n    size_t j = 0; // Index for sorted values\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            l[i] = indices[j++];\n        }\n    }\n\n    return l;\n}\n\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Use std::unique to remove duplicates\n    auto last = unique(l.begin(), l.end());\n    \n    // Resize the vector to the new size\n    l.erase(last, l.end());\n    \n    return l;\n}\n\n"}
{"task_id": "CPP/35", "generation": "#include <iostream>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\nfloat max_element(const vector<float>& l) {\n    // Check if the vector is empty\n    if (l.empty()) {\n        throw invalid_argument(\"The vector is empty.\");\n    }\n\n    // Initialize max to the smallest possible float value\n    float max_val = numeric_limits<float>::lowest();\n\n    // Iterate through the vector to find the maximum element\n    for (float num : l) {\n        if (num > max_val) {\n            max_val = num;\n        }\n    }\n    \n    return max_val;\n}\n\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\nusing namespace std;\n\nint count_digit_seven(int num) {\n    int count = 0;\n    while (num > 0) {\n        if (num % 10 == 7) {\n            count++;\n        }\n        num /= 10;\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int total_count = 0;\n\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            total_count += count_digit_seven(i);\n        }\n    }\n\n    return total_count;\n}\n\n"}
{"task_id": "CPP/37", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Create a new vector to store the result\n    vector<float> result(l.size());\n\n    // Copy odd indexed values directly\n    for (size_t i = 0; i < l.size(); i++) {\n        if (i % 2 == 1) {\n            result[i] = l[i];\n        }\n    }\n\n    // Extract even indexed values\n    vector<float> even_values;\n    for (size_t i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            even_values.push_back(l[i]);\n        }\n    }\n\n    // Sort the even indexed values\n    sort(even_values.begin(), even_values.end());\n\n    // Place sorted even values back into the result vector\n    size_t even_index = 0;\n    for (size_t i = 0; i < result.size(); i++) {\n        if (i % 2 == 0) {\n            result[i] = even_values[even_index++];\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++) {\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output = output + x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string. \n    */\n    int l = s.length();\n    string output;\n    int i;\n    for (i = 0; i * 3 < l; i++) {\n        // reverse the cycling of elements in each group.\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            // Move the last character to the front\n            x = x[x.length() - 1] + x.substr(0, 2);\n        }\n        output = output + x;\n    }\n    return output;\n}\n\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to return the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    int a = 0, b = 1; // Starting values for Fibonacci\n    int count = 0; // Count of prime Fibonacci numbers\n    int prime_fib_number = 0; // To store the n-th prime Fibonacci number\n\n    while (count < n) {\n        int next_fib = a + b; // Generate next Fibonacci number\n        a = b; // Move to the next Fibonacci number\n        b = next_fib;\n\n        // Check if the Fibonacci number is prime\n        if (is_prime(next_fib)) {\n            count++; // Increment count of prime Fibonacci numbers\n            prime_fib_number = next_fib; // Update the last found prime Fibonacci number\n        }\n    }\n\n    return prime_fib_number; // Return the n-th prime Fibonacci number\n}\n\n// Test the function\n"}
{"task_id": "CPP/40", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Iterate through the vector\n    for (size_t i = 0; i < l.size(); ++i) {\n        // Skip duplicate elements to ensure distinct triplets\n        if (i > 0 && l[i] == l[i - 1]) {\n            continue;\n        }\n        \n        // Set up two pointers\n        int left = i + 1;\n        int right = l.size() - 1;\n        \n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true; // Found a triplet\n            } else if (sum < 0) {\n                left++; // Move left pointer to the right to increase the sum\n            } else {\n                right--; // Move right pointer to the left to decrease the sum\n            }\n        }\n    }\n    \n    return false; // No triplet found\n}\n\n"}
{"task_id": "CPP/41", "generation": "#include <iostream>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Each car moving left to right will collide with each car moving right to left.\n    // Therefore, the total number of collisions is n (left to right) * n (right to left).\n    return n * n;\n}\n\n"}
{"task_id": "CPP/42", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    // Create a new vector to store the incremented values\n    vector<int> incremented_list;\n    \n    // Iterate through each element in the input vector\n    for (int num : l) {\n        // Increment the element by 1 and add it to the new vector\n        incremented_list.push_back(num + 1);\n    }\n    \n    // Return the new vector with incremented values\n    return incremented_list;\n}\n\n"}
{"task_id": "CPP/43", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen; // To store the numbers we have seen\n\n    for (int num : l) {\n        // Check if the negation of the current number exists in the set\n        if (seen.count(-num)) {\n            return true; // Found a pair that sums to zero\n        }\n        seen.insert(num); // Add the current number to the set\n    }\n    \n    return false; // No pairs found that sum to zero\n}\n\n// Test cases\n"}
{"task_id": "CPP/44", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (base < 2 || base >= 10) {\n        return \"\"; // Invalid base\n    }\n    \n    if (x == 0) {\n        return \"0\"; // Special case for zero\n    }\n\n    string result = \"\";\n    \n    // Convert x to the specified base\n    while (x > 0) {\n        int remainder = x % base; // Get the remainder\n        result = to_string(remainder) + result; // Prepend the remainder to the result\n        x /= base; // Divide x by the base\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/45", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h; // Calculate the area using the formula\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <iostream>\nusing namespace std;\n\nint fib4(int n) {\n    // Base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    // Array to store the last four values\n    int fib[4] = {0, 0, 2, 0}; // fib4(0), fib4(1), fib4(2), fib4(3)\n\n    // Compute fib4(n) iteratively\n    for (int i = 4; i <= n; i++) {\n        int next_fib = fib[0] + fib[1] + fib[2] + fib[3]; // fib4(n) = fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n        \n        // Update the array to hold the last four values\n        fib[0] = fib[1];\n        fib[1] = fib[2];\n        fib[2] = fib[3];\n        fib[3] = next_fib; // Store the new computed value\n    }\n\n    return fib[3]; // Return the n-th value\n}\n\n"}
{"task_id": "CPP/47", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Get the size of the vector\n    size_t size = l.size();\n    \n    // Calculate median\n    if (size % 2 == 1) {\n        // If odd, return the middle element\n        return l[size / 2];\n    } else {\n        // If even, return the average of the two middle elements\n        return (l[size / 2 - 1] + l[size / 2]) / 2.0;\n    }\n}\n\n"}
{"task_id": "CPP/48", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Not a palindrome\n        }\n        left++;\n        right--;\n    }\n    return true; // Is a palindrome\n}\n\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\n\nint modp(int n, int p) {\n    if (p == 1) return 0; // Since any number mod 1 is 0\n    if (n == 0) return 1; // 2^0 is 1\n\n    long long result = 1; // Use long long to handle large numbers\n    long long base = 2;   // Base is 2\n\n    // Exponentiation by squaring\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd\n            result = (result * base) % p; // Multiply the result by the base\n        }\n        base = (base * base) % p; // Square the base\n        n /= 2; // Divide n by 2\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/50", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // Returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (char c : s) {\n        if (isalpha(c)) { // Check if the character is an alphabet\n            char base = islower(c) ? 'a' : 'A'; // Determine base for lowercase or uppercase\n            char shifted = (c - base + 5) % 26 + base; // Shift and wrap around\n            out += shifted; // Append shifted character to output\n        } else {\n            out += c; // Non-alphabet characters remain unchanged\n        }\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // Takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (char c : s) {\n        if (isalpha(c)) { // Check if the character is an alphabet\n            char base = islower(c) ? 'a' : 'A'; // Determine base for lowercase or uppercase\n            char shifted = (c - base - 5 + 26) % 26 + base; // Shift back and wrap around\n            out += shifted; // Append shifted character to output\n        } else {\n            out += c; // Non-alphabet characters remain unchanged\n        }\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        // Check if the character is not a vowel\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n            c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            result += c; // Append non-vowel characters to result\n        }\n    }\n    return result; // Return the string without vowels\n}\n\n"}
{"task_id": "CPP/52", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false; // Found a number that is not below the threshold\n        }\n    }\n    return true; // All numbers are below the threshold\n}\n\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to add two numbers\nint add(int x, int y) {\n    return x + y;\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <set>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create sets to store unique characters from each string\n    set<char> chars0(s0.begin(), s0.end());\n    set<char> chars1(s1.begin(), s1.end());\n    \n    // Compare the two sets\n    return chars0 == chars1;\n}\n\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) return 0; // Handle the case for n = 0\n    if (n == 1) return 1; // Base case for n = 1\n\n    int a = 0; // F(0)\n    int b = 1; // F(1)\n    int c; // To store the current Fibonacci number\n\n    for (int i = 2; i <= n; i++) {\n        c = a + b; // F(n) = F(n-1) + F(n-2)\n        a = b;     // Move to the next Fibonacci number\n        b = c;     // Update b to the current Fibonacci number\n    }\n\n    return b; // Return the n-th Fibonacci number\n}\n\n"}
{"task_id": "CPP/56", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int count = 0; // Initialize a counter for opening brackets\n\n    for (char ch : brackets) {\n        if (ch == '<') {\n            count++; // Increment for opening bracket\n        } else if (ch == '>') {\n            count--; // Decrement for closing bracket\n        }\n\n        // If count goes negative, there are unmatched closing brackets\n        if (count < 0) {\n            return false;\n        }\n    }\n\n    // At the end, count should be zero for all brackets to be matched\n    return count == 0;\n}\n\n"}
{"task_id": "CPP/57", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() < 2) {\n        return true; // A single element or empty vector is considered monotonic\n    }\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false; // Found an increasing pair\n        } else if (l[i] < l[i - 1]) {\n            increasing = false; // Found a decreasing pair\n        }\n    }\n\n    return increasing || decreasing; // Return true if either is true\n}\n\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Use a set to store unique elements from both vectors\n    set<int> set1(l1.begin(), l1.end());\n    set<int> set2(l2.begin(), l2.end());\n    \n    // Vector to store the common elements\n    vector<int> result;\n\n    // Use set_intersection to find common elements\n    set_intersection(set1.begin(), set1.end(),\n                     set2.begin(), set2.end(),\n                     back_inserter(result));\n\n    return result; // Return the sorted unique common elements\n}\n\n"}
{"task_id": "CPP/59", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int largest_factor = -1;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        largest_factor = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i * i <= n; i += 2) {\n        // While i divides n, update n and largest_factor\n        while (n % i == 0) {\n            largest_factor = i;\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        largest_factor = n;\n    }\n\n    return largest_factor;\n}\n\n"}
{"task_id": "CPP/60", "generation": "#include <iostream>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2; // Using the formula to calculate the sum\n}\n\n"}
{"task_id": "CPP/61", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // This will keep track of the balance of brackets\n\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++; // Increment for opening bracket\n        } else if (ch == ')') {\n            balance--; // Decrement for closing bracket\n        }\n\n        // If balance goes negative, there are unmatched closing brackets\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // At the end, balance should be zero for all brackets to be matched\n    return balance == 0;\n}\n\n"}
{"task_id": "CPP/62", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<float> derivative(const vector<float>& xs) {\n    vector<float> result;\n    int degree = xs.size(); // The degree of the polynomial is the size of the vector\n\n    // Loop through the coefficients starting from the first term (index 1)\n    for (int i = 1; i < degree; ++i) {\n        // Calculate the derivative coefficient\n        result.push_back(xs[i] * i);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint fibfib(int n) {\n    // Handle base cases\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Create a vector to store the fibfib values\n    vector<int> fibfib_values(n + 1);\n    fibfib_values[0] = 0; // fibfib(0)\n    fibfib_values[1] = 0; // fibfib(1)\n    fibfib_values[2] = 1; // fibfib(2)\n\n    // Compute the values iteratively\n    for (int i = 3; i <= n; ++i) {\n        fibfib_values[i] = fibfib_values[i - 1] + fibfib_values[i - 2] + fibfib_values[i - 3];\n    }\n\n    return fibfib_values[n];\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    int length = s.length();\n\n    for (int i = 0; i < length; i++) {\n        char c = tolower(s[i]); // Convert to lowercase for uniformity\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        } else if (c == 'y' && i == length - 1) { // Check if 'y' is at the end\n            count++;\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/65", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    // Convert the integer to a string\n    string str = to_string(x);\n    int len = str.length();\n\n    // If shift is greater than the number of digits, reverse the string\n    if (shift > len) {\n        reverse(str.begin(), str.end());\n    } else {\n        // Perform the circular shift\n        // Calculate the effective shift (in case shift is equal to len)\n        shift = shift % len;\n        // Create the new shifted string\n        string shifted = str.substr(len - shift) + str.substr(0, len - shift);\n        return shifted;\n    }\n    return str; // Return the reversed string if shift > len\n}\n\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0; // Initialize sum to 0\n    for (char c : s) { // Iterate through each character in the string\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add the ASCII value of the uppercase character to sum\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/67", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0, oranges = 0;\n\n    // Create a string stream from the input string\n    stringstream ss(s);\n    string word;\n\n    // Parse the string to find the numbers of apples and oranges\n    while (ss >> word) {\n        if (word == \"apples\") {\n            ss >> apples; // Get the number before \"apples\"\n        } else if (word == \"oranges\") {\n            ss >> oranges; // Get the number before \"oranges\"\n        }\n    }\n\n    // Calculate the number of mangoes\n    int mangoes = n - apples - oranges;\n    return mangoes;\n}\n\n"}
{"task_id": "CPP/68", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    int smallest_even_value = -1; // Initialize to -1 to indicate no even number found\n    int smallest_index = -1; // Initialize index to -1\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            if (smallest_even_value == -1 || arr[i] < smallest_even_value) {\n                smallest_even_value = arr[i]; // Update smallest even value\n                smallest_index = i; // Update index of the smallest even value\n            }\n        }\n    }\n\n    if (smallest_even_value == -1) {\n        return {}; // Return empty vector if no even number was found\n    } else {\n        return {smallest_even_value, smallest_index}; // Return the result\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/69", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequencyMap;\n\n    // Count the frequency of each integer in the vector\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    int result = -1;\n\n    // Check for the greatest integer that meets the criteria\n    for (const auto& pair : frequencyMap) {\n        int num = pair.first;\n        int freq = pair.second;\n\n        // Check if the frequency is greater than or equal to the number itself\n        if (freq >= num) {\n            result = max(result, num);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/70", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Sort the input list\n    sort(lst.begin(), lst.end());\n    \n    vector<int> result;\n    int left = 0; // Pointer for the minimum values\n    int right = lst.size() - 1; // Pointer for the maximum values\n\n    // Alternate between minimum and maximum values\n    while (left <= right) {\n        if (left == right) {\n            result.push_back(lst[left]); // If both pointers meet, add the last element\n        } else {\n            result.push_back(lst[left]); // Add the minimum\n            result.push_back(lst[right]); // Add the maximum\n        }\n        left++;\n        right--;\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\n\nfloat triangle_area(float a, float b, float c) {\n    // Check for a valid triangle using the triangle inequality theorem\n    if (a + b > c && a + c > b && b + c > a) {\n        // Calculate the semi-perimeter\n        float s = (a + b + c) / 2;\n        \n        // Calculate the area using Heron's formula\n        float area = sqrt(s * (s - a) * (s - b) * (s - c));\n        \n        // Return the area rounded to 2 decimal points\n        return round(area * 100) / 100; // Round to 2 decimal points\n    } else {\n        // Return -1 if the sides do not form a valid triangle\n        return -1;\n    }\n}\n\n"}
{"task_id": "CPP/72", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool is_palindromic(const vector<int>& q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false; // Not a palindrome\n        }\n    }\n    return true; // It's a palindrome\n}\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is palindromic\n    if (!is_palindromic(q)) {\n        return false;\n    }\n    \n    // Calculate the sum of the elements\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    \n    // Check if the sum is less than or equal to the maximum weight\n    return sum <= w;\n}\n\n// Example usage\n"}
{"task_id": "CPP/73", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    // Compare elements from the start and end moving towards the center\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    // Function to calculate the total number of characters in a vector of strings\n    auto total_chars = [](const vector<string>& lst) {\n        int total = 0;\n        for (const string& str : lst) {\n            total += str.size();\n        }\n        return total;\n    };\n\n    // Calculate total characters for both vectors\n    int total1 = total_chars(lst1);\n    int total2 = total_chars(lst2);\n\n    // Compare totals and return the appropriate vector\n    if (total1 < total2) {\n        return lst1;\n    } else {\n        return lst2; // This includes the case where totals are equal\n    }\n}\n\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to generate a list of prime numbers less than 100\nvector<int> generate_primes() {\n    vector<int> primes;\n    for (int i = 2; i < 100; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n\n// Function to check if a number is the product of three prime numbers\nbool is_multiply_prime(int a) {\n    vector<int> primes = generate_primes();\n    int size = primes.size();\n\n    // Check all combinations of three primes\n    for (int i = 0; i < size; i++) {\n        for (int j = 0; j < size; j++) {\n            for (int k = 0; k < size; k++) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n"}
{"task_id": "CPP/76", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    // Handle edge cases\n    if (n <= 1) {\n        return (n == 1 && x == 1); // 1^k = 1 for any k, and 0^k is not defined for k > 0\n    }\n    if (x < 1) {\n        return false; // x must be a positive integer\n    }\n\n    int power = 1; // Start with n^0\n    while (power < x) {\n        power *= n; // Multiply by n to get the next power\n    }\n\n    return power == x; // Check if we have reached x\n}\n\n"}
{"task_id": "CPP/77", "generation": "#include <iostream>\n#include <cmath>\n\nbool iscube(int a) {\n    // Calculate the cube root of the absolute value of a\n    int cubeRoot = round(cbrt(a));\n    \n    // Check if the cube of the calculated root equals a\n    return (cubeRoot * cubeRoot * cubeRoot == a);\n}\n\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint hex_key(string num) {\n    // Set of prime hexadecimal digits\n    const string prime_hex_digits = \"2357BD\";\n    int count = 0;\n\n    // Iterate through each character in the input string\n    for (char c : num) {\n        // Check if the character is in the set of prime hexadecimal digits\n        if (prime_hex_digits.find(c) != string::npos) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n// Example usage\n"}
{"task_id": "CPP/79", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Handle the case for 0 explicitly\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    string binary = \"\";\n    \n    // Convert decimal to binary\n    while (decimal > 0) {\n        // Prepend the remainder (0 or 1) to the binary string\n        binary = to_string(decimal % 2) + binary;\n        decimal /= 2; // Divide the number by 2\n    }\n\n    // Add \"db\" at the beginning and end\n    return \"db\" + binary + \"db\";\n}\n\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is at least 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string and check every 3 consecutive characters\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        // Check if the three characters are distinct\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false; // Found a group of 3 that are not distinct\n        }\n    }\n\n    return true; // All groups of 3 are distinct\n}\n\n"}
{"task_id": "CPP/81", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letter_grades;\n\n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n\n    return letter_grades;\n}\n\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) { // Check for factors up to the square root of n\n        if (n % i == 0) return false; // If n is divisible by i, it's not prime\n    }\n    return true; // If no factors were found, n is prime\n}\n\nbool prime_length(string str) {\n    int length = str.length(); // Get the length of the string\n    return is_prime(length); // Check if the length is prime\n}\n\n"}
{"task_id": "CPP/83", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        // For n = 1, the only number is '1'\n        return 1;\n    }\n    \n    // Count of n-digit numbers starting with '1'\n    long long count_starting_with_1 = pow(10, n - 1);\n    \n    // Count of n-digit numbers ending with '1'\n    long long count_ending_with_1 = 9 * pow(10, n - 2);\n    \n    // Count of n-digit numbers starting and ending with '1'\n    long long count_both = pow(10, n - 2);\n    \n    // Total count\n    long long total_count = count_starting_with_1 + count_ending_with_1 - count_both;\n    \n    return total_count;\n}\n\n"}
{"task_id": "CPP/84", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n\n    // Calculate the sum of the digits\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to sum\n        N /= 10;       // Remove the last digit\n    }\n\n    // Convert the sum to binary\n    string binary = \"\";\n    if (sum == 0) {\n        return \"0\"; // Special case for sum = 0\n    }\n\n    while (sum > 0) {\n        binary = to_string(sum % 2) + binary; // Prepend the binary digit\n        sum /= 2; // Divide by 2 to shift right\n    }\n\n    return binary; // Return the binary representation\n}\n\n"}
{"task_id": "CPP/85", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add(const vector<int>& lst) {\n    int sum = 0; // Initialize sum to 0\n    // Iterate through the vector\n    for (size_t i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2 to get odd indices\n        if (lst[i] % 2 == 0) { // Check if the element at the odd index is even\n            sum += lst[i]; // Add to sum if it is even\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    stringstream ss(s);\n    string word;\n    vector<string> words;\n\n    // Split the string into words while preserving spaces\n    while (ss >> word) {\n        // Sort the characters of the word\n        sort(word.begin(), word.end());\n        words.push_back(word);\n    }\n\n    // Reconstruct the string with sorted words and original spaces\n    string result;\n    size_t lastPos = 0;\n    for (const auto& w : words) {\n        // Find the position of the next word in the original string\n        size_t pos = s.find(w, lastPos);\n        \n        // Append the spaces between the last word and the current word\n        result += s.substr(lastPos, pos - lastPos);\n        \n        // Append the sorted word\n        result += w;\n        \n        // Update the last position\n        lastPos = pos + w.length();\n    }\n    \n    // Append any remaining spaces or characters after the last word\n    result += s.substr(lastPos);\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/87", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result;\n\n    // Iterate through each row\n    for (int i = 0; i < lst.size(); ++i) {\n        // Iterate through each column in the current row\n        for (int j = 0; j < lst[i].size(); ++j) {\n            // Check if the current element matches x\n            if (lst[i][j] == x) {\n                // Store the coordinates {row, column}\n                result.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort the result first by row (ascending) and then by column (descending)\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort by column descending if rows are equal\n        }\n        return a[0] < b[0]; // Sort by row ascending\n    });\n\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/88", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> sort_array(const vector<int>& array) {\n    // Create a copy of the original array\n    vector<int> sorted_array = array;\n\n    // Check if the array is empty or has only one element\n    if (sorted_array.size() <= 1) {\n        return sorted_array; // Return the copy as is\n    }\n\n    // Calculate the sum of the first and last elements\n    int sum = sorted_array.front() + sorted_array.back();\n\n    // Sort the array based on the sum being odd or even\n    if (sum % 2 == 0) {\n        // Even sum: sort in descending order\n        sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n    } else {\n        // Odd sum: sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    return sorted_array; // Return the sorted copy\n}\n\n// Example usage\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string encrypted = \"\";\n    \n    for (char c : s) {\n        // Check if the character is a lowercase letter\n        if (c >= 'a' && c <= 'z') {\n            // Rotate the character by 4 positions\n            char newChar = c + 4;\n            // Wrap around if it goes past 'z'\n            if (newChar > 'z') {\n                newChar -= 26; // Wrap around\n            }\n            encrypted += newChar;\n        }\n        // If you want to handle uppercase letters, you can add similar logic here\n        else if (c >= 'A' && c <= 'Z') {\n            char newChar = c + 4;\n            if (newChar > 'Z') {\n                newChar -= 26; // Wrap around\n            }\n            encrypted += newChar;\n        } else {\n            // If the character is not a letter, you can choose to keep it unchanged\n            encrypted += c;\n        }\n    }\n    \n    return encrypted;\n}\n\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    // Use a set to store unique elements\n    set<int> unique_elements(lst.begin(), lst.end());\n    \n    // If there are less than 2 unique elements, return None (or -1)\n    if (unique_elements.size() < 2) {\n        return -1; // or you can use another value to indicate \"None\"\n    }\n    \n    // Convert the set back to a vector to access the second smallest element\n    vector<int> sorted_unique(unique_elements.begin(), unique_elements.end());\n    \n    // Return the second smallest element\n    return sorted_unique[1];\n}\n\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int boredom_count = 0;\n    stringstream ss(S);\n    string sentence;\n\n    // Split the string into sentences based on delimiters\n    while (getline(ss, sentence, '.')) {\n        if (sentence.empty()) continue; // Skip empty sentences\n        // Check for '?' and '!' as well\n        size_t pos = sentence.find_first_of(\"!?\");\n        if (pos != string::npos) {\n            sentence = sentence.substr(0, pos); // Get the part before the delimiter\n        }\n\n        // Trim leading whitespace\n        size_t start = sentence.find_first_not_of(\" \\t\");\n        if (start != string::npos) {\n            sentence = sentence.substr(start);\n        }\n\n        // Check if the sentence starts with \"I\"\n        if (sentence.rfind(\"I \", 0) == 0 || sentence == \"I\") {\n            boredom_count++;\n        }\n    }\n\n    return boredom_count;\n}\n\n"}
{"task_id": "CPP/92", "generation": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n\n    // Convert to integers\n    int int_a = static_cast<int>(a);\n    int int_b = static_cast<int>(b);\n    int int_c = static_cast<int>(c);\n\n    // Check if one number is equal to the sum of the other two\n    return (int_a == int_b + int_c) || (int_b == int_a + int_c) || (int_c == int_a + int_b);\n}\n\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstring encode(string message) {\n    string encodedMessage = \"\";\n\n    for (char ch : message) {\n        // Swap case\n        if (isupper(ch)) {\n            ch = tolower(ch);\n        } else if (islower(ch)) {\n            ch = toupper(ch);\n        }\n\n        // Replace vowels\n        switch (ch) {\n            case 'a':\n                ch = 'c'; // 'a' -> 'c'\n                break;\n            case 'e':\n                ch = 'g'; // 'e' -> 'g'\n                break;\n            case 'i':\n                ch = 'k'; // 'i' -> 'k'\n                break;\n            case 'o':\n                ch = 'q'; // 'o' -> 'q'\n                break;\n            case 'u':\n                ch = 'w'; // 'u' -> 'w'\n                break;\n            case 'A':\n                ch = 'C'; // 'A' -> 'C'\n                break;\n            case 'E':\n                ch = 'G'; // 'E' -> 'G'\n                break;\n            case 'I':\n                ch = 'K'; // 'I' -> 'K'\n                break;\n            case 'O':\n                ch = 'Q'; // 'O' -> 'Q'\n                break;\n            case 'U':\n                ch = 'W'; // 'U' -> 'W'\n                break;\n            default:\n                break; // Non-vowel characters remain unchanged\n        }\n\n        encodedMessage += ch; // Append the modified character to the result\n    }\n\n    return encodedMessage;\n}\n\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10; // Add the last digit to sum\n        num /= 10; // Remove the last digit\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and return the sum of its digits\nint largestPrimeDigitSum(const vector<int>& lst) {\n    int largestPrime = -1; // Initialize to -1 to indicate no prime found\n\n    // Iterate through the list to find the largest prime\n    for (int num : lst) {\n        if (isPrime(num) && num > largestPrime) {\n            largestPrime = num; // Update largest prime found\n        }\n    }\n\n    // If no prime was found, return 0 or handle as needed\n    if (largestPrime == -1) return 0;\n\n    // Calculate and return the sum of digits of the largest prime\n    return sumOfDigits(largestPrime);\n}\n\n// Main function\n"}
{"task_id": "CPP/95", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <cctype> // for islower and isupper\n\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    // Iterate through each key in the map\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        // Check if the key is a string (it is, since we're using map<string, string>)\n        // Check if the key is lower case or upper case\n        if (islower(key[0])) {\n            all_upper = false; // If any key is lower case, set all_upper to false\n        } else if (isupper(key[0])) {\n            all_lower = false; // If any key is upper case, set all_lower to false\n        } else {\n            return false; // If the key is neither lower nor upper case, return false\n        }\n\n        // Check the rest of the characters in the key\n        for (size_t i = 1; i < key.length(); ++i) {\n            if (islower(key[i])) {\n                all_upper = false; // If any character is lower case, set all_upper to false\n            } else if (isupper(key[i])) {\n                all_lower = false; // If any character is upper case, set all_lower to false\n            } else {\n                return false; // If the character is neither lower nor upper case, return false\n            }\n        }\n    }\n\n    // Return true if all keys are either all lower case or all upper case\n    return all_lower || all_upper;\n}\n\n// Example usage\n"}
{"task_id": "CPP/96", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) { // Check divisibility from 2 to sqrt(num)\n        if (num % i == 0) return false; // If divisible, not prime\n    }\n    return true; // If no divisors found, it's prime\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes; // Vector to store prime numbers\n    for (int i = 2; i < n; i++) { // Iterate from 2 to n-1\n        if (is_prime(i)) { // Check if i is prime\n            primes.push_back(i); // Add prime number to the vector\n        }\n    }\n    return primes; // Return the vector of prime numbers\n}\n\n// Example usage\n"}
{"task_id": "CPP/97", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the unit digits of both numbers\n    int unitDigitA = abs(a) % 10; // Use abs to handle negative numbers\n    int unitDigitB = abs(b) % 10; // Use abs to handle negative numbers\n    \n    // Calculate the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n\n// Example usage\n"}
{"task_id": "CPP/98", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0; // Initialize counter for uppercase vowels\n    // Define a string containing uppercase vowels for easy checking\n    string vowels = \"AEIOU\";\n\n    // Loop through the string, checking only even indices\n    for (int i = 0; i < s.length(); i += 2) {\n        // Check if the character is an uppercase vowel\n        if (vowels.find(s[i]) != string::npos) {\n            count++; // Increment counter if it's an uppercase vowel\n        }\n    }\n\n    return count; // Return the final count\n}\n\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Convert the string to a double\n    double num = stod(value);\n    \n    // Get the floor and ceil values to check for equidistance\n    int lower = floor(num);\n    int upper = ceil(num);\n    \n    // Check if the number is equidistant\n    if (num - lower == 0.5) {\n        return upper; // Round away from zero\n    } else if (num - lower == -0.5) {\n        return lower; // Round away from zero\n    } else {\n        return round(num); // Regular rounding\n    }\n}\n\n"}
{"task_id": "CPP/100", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    int current_stones = n; // Start with n stones for the first level\n\n    for (int i = 0; i < n; i++) {\n        stones.push_back(current_stones); // Add the current level's stones to the vector\n        // Determine the next number of stones based on whether n is odd or even\n        if (n % 2 == 0) {\n            current_stones += 2; // Next even number\n        } else {\n            current_stones += 2; // Next odd number\n        }\n    }\n\n    return stones;\n}\n\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    stringstream ss(s);\n    string word;\n\n    // Use a while loop to extract words separated by spaces or commas\n    while (getline(ss, word, ',')) { // First split by comma\n        stringstream wordStream(word);\n        while (wordStream >> word) { // Then split by spaces\n            words.push_back(word);\n        }\n    }\n\n    return words;\n}\n\n"}
{"task_id": "CPP/102", "generation": "#include <iostream>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1; // Return -1 if the range is invalid\n    }\n\n    // Start from y and check for the largest even number\n    for (int i = y; i >= x; --i) {\n        if (i % 2 == 0) { // Check if the number is even\n            return i; // Return the largest even number found\n        }\n    }\n\n    return -1; // Return -1 if no even number is found\n}\n\n"}
{"task_id": "CPP/103", "generation": "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m\n    int count = m - n + 1; // Number of integers from n to m\n    int sum = (n + m) * count / 2; // Sum of the arithmetic series\n    int average = sum / count; // Average\n\n    // Round down the average\n    int rounded_average = floor(average);\n\n    // Convert the rounded average to binary\n    string binary = \"\";\n    if (rounded_average == 0) {\n        binary = \"0\";\n    } else {\n        while (rounded_average > 0) {\n            binary = to_string(rounded_average % 2) + binary;\n            rounded_average /= 2;\n        }\n    }\n\n    return binary;\n}\n\n"}
{"task_id": "CPP/104", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool has_even_digit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true; // Found an even digit\n        }\n        num /= 10;\n    }\n    return false; // No even digits found\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        if (!has_even_digit(num)) {\n            result.push_back(num); // Add to result if no even digits\n        }\n    }\n\n    sort(result.begin(), result.end()); // Sort the result vector\n    return result;\n}\n\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Step 1: Filter the vector to keep only numbers between 1 and 9\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Step 2: Sort the filtered vector\n    sort(filtered.begin(), filtered.end());\n\n    // Step 3: Reverse the sorted vector\n    reverse(filtered.begin(), filtered.end());\n\n    // Step 4: Map each number to its corresponding name\n    vector<string> names;\n    vector<string> numberNames = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    \n    for (int num : filtered) {\n        names.push_back(numberNames[num]);\n    }\n\n    // Step 5: Return the resulting vector of names\n    return names;\n}\n\n// Example usage\n"}
{"task_id": "CPP/106", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n); // Create a vector of size n\n\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            // Calculate factorial for even indices\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial; // Store the factorial in the vector\n        } else {\n            // Calculate sum from 1 to i for odd indices\n            result[i - 1] = (i * (i + 1)) / 2; // Using the formula for the sum of the first i natural numbers\n        }\n    }\n\n    return result; // Return the populated vector\n}\n\n"}
{"task_id": "CPP/107", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is a palindrome\nbool isPalindrome(int num) {\n    string str = to_string(num);\n    string revStr = string(str.rbegin(), str.rend());\n    return str == revStr;\n}\n\n// Function to count even and odd palindromes\nvector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n\n    return {evenCount, oddCount};\n}\n\n// Example usage\n"}
{"task_id": "CPP/108", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n// Function to calculate the sum of digits of a number\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0; // Check if the number is negative\n    num = abs(num); // Work with the absolute value for digit extraction\n\n    // Extract digits and calculate the sum\n    while (num > 0) {\n        sum += num % 10; // Add the last digit to the sum\n        num /= 10; // Remove the last digit\n    }\n\n    // If the original number was negative, subtract twice the first digit\n    if (is_negative) {\n        // The first digit of the original number\n        int first_digit = abs(num);\n        while (first_digit >= 10) {\n            first_digit /= 10; // Get the first digit\n        }\n        sum -= 2 * first_digit; // Adjust the sum for the negative first digit\n    }\n\n    return sum;\n}\n\n// Function to count numbers with a sum of digits greater than 0\nint count_nums(vector<int> n) {\n    int count = 0;\n\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++; // Increment count if the sum of digits is greater than 0\n        }\n    }\n\n    return count;\n}\n\n// Example usage\n"}
{"task_id": "CPP/109", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    // If the array is empty, return true\n    if (arr.empty()) return true;\n\n    int count = 0;\n    int n = arr.size();\n\n    // Loop through the array to count the number of breaks\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            count++;\n        }\n    }\n\n    // If there is more than one break, return false\n    return count <= 1;\n}\n\n// Example usage\n"}
{"task_id": "CPP/110", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount = 0;\n    int evenCountInLst2 = 0;\n\n    // Count odd numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount++;\n        }\n    }\n\n    // Count even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCountInLst2++;\n        }\n    }\n\n    // If we have enough even numbers in lst2 to replace all odd numbers in lst1\n    if (evenCountInLst2 >= oddCount) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nmap<string, int> histogram(string test) {\n    map<char, int> countMap;\n    map<string, int> resultMap;\n    \n    // Split the string into characters\n    stringstream ss(test);\n    string token;\n    \n    while (ss >> token) {\n        for (char c : token) {\n            countMap[c]++;\n        }\n    }\n    \n    // Find the maximum occurrence\n    int maxCount = 0;\n    for (const auto& pair : countMap) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n    \n    // Collect all characters with the maximum count\n    for (const auto& pair : countMap) {\n        if (pair.second == maxCount) {\n            resultMap[string(1, pair.first)] = pair.second;\n        }\n    }\n    \n    return resultMap;\n}\n\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Create a set of characters to delete\n    unordered_set<char> charsToDelete(c.begin(), c.end());\n    \n    // Build the result string by excluding characters in charsToDelete\n    string result;\n    for (char ch : s) {\n        if (charsToDelete.find(ch) == charsToDelete.end()) {\n            result += ch;\n        }\n    }\n    \n    // Check if the result string is a palindrome\n    string reversedResult = result;\n    reverse(reversedResult.begin(), reversedResult.end());\n    bool isPalindrome = (result == reversedResult);\n    \n    // Prepare the output\n    vector<string> output;\n    output.push_back(result);\n    output.push_back(isPalindrome ? \"True\" : \"False\");\n    \n    return output;\n}\n\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n\n    for (int i = 0; i < lst.size(); ++i) {\n        string str = lst[i];\n        int odd_count = 0;\n\n        // Count odd digits in the current string\n        for (char c : str) {\n            if (c % 2 != 0) { // Check if the digit is odd\n                odd_count++;\n            }\n        }\n\n        // Create the output string with the count of odd digits\n        string output = \"the number of odd elements \" + to_string(odd_count) +\n                        \"n the str\" + to_string(i + 1) + \"ng \" + to_string(i + 1) +\n                        \" of the \" + to_string(i + 1) + \"nput.\";\n        \n        result.push_back(output);\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/114", "generation": "#include <iostream>\n#include <vector>\n#include <limits.h> // For INT_MAX\n\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long min_sum = LLONG_MAX; // Initialize to maximum possible value\n    long long current_sum = 0; // To keep track of the current subarray sum\n\n    for (size_t i = 0; i < nums.size(); ++i) {\n        current_sum += nums[i]; // Add current element to the current subarray sum\n        if (current_sum < min_sum) {\n            min_sum = current_sum; // Update min_sum if current_sum is smaller\n        }\n        if (current_sum > 0) {\n            current_sum = 0; // Reset current_sum if it becomes positive\n        }\n    }\n\n    return min_sum; // Return the minimum subarray sum found\n}\n\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_lowerings = 0;\n\n    // Iterate through each well (row)\n    for (const auto& well : grid) {\n        int water_units = 0;\n\n        // Count the number of 1's in the current well (row)\n        for (int water : well) {\n            water_units += water; // Increment count for each unit of water\n        }\n\n        // Calculate the number of times we need to lower the bucket\n        if (water_units > 0) {\n            total_lowerings += (water_units / capacity); // Full buckets\n            if (water_units % capacity != 0) {\n                total_lowerings += 1; // Additional lowering for remaining water\n            }\n        }\n    }\n\n    return total_lowerings;\n}\n\n"}
{"task_id": "CPP/116", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to count the number of 1s in the binary representation of an integer\nint countOnes(int n) {\n    int count = 0;\n    while (n) {\n        count += n & 1; // Increment count if the last bit is 1\n        n >>= 1;        // Right shift to check the next bit\n    }\n    return count;\n}\n\n// Custom comparator for sorting\nbool customComparator(int a, int b) {\n    int onesA = countOnes(a);\n    int onesB = countOnes(b);\n    // First compare by number of ones, then by value\n    if (onesA == onesB) {\n        return a < b; // If same number of ones, sort by value\n    }\n    return onesA < onesB; // Sort by number of ones\n}\n\nvector<int> sort_array(vector<int> arr) {\n    // Sort using the custom comparator\n    sort(arr.begin(), arr.end(), customComparator);\n    return arr;\n}\n\n// Example usage\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nbool is_consonant(char c) {\n    // Check if the character is a consonant\n    c = tolower(c); // Convert to lowercase for uniformity\n    return isalpha(c) && !strchr(\"aeiou\", c);\n}\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    stringstream ss(s);\n    string word;\n\n    // Split the string into words\n    while (ss >> word) {\n        int consonant_count = 0;\n\n        // Count consonants in the word\n        for (char c : word) {\n            if (is_consonant(c)) {\n                consonant_count++;\n            }\n        }\n\n        // If the count of consonants matches n, add to result\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/118", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    // Define a string containing all vowels for easy checking\n    string vowels = \"aeiouAEIOU\";\n    \n    // Start from the end of the string\n    for (int i = word.length() - 1; i > 0; --i) {\n        // Check if the current character is a vowel\n        if (vowels.find(word[i]) != string::npos) {\n            // Now we need to check for consonants before this vowel\n            for (int j = i - 1; j >= 0; --j) {\n                // Check if the character is a consonant\n                if (isalpha(word[j]) && vowels.find(word[j]) == string::npos) {\n                    // If we found a consonant before the vowel, return the vowel\n                    return string(1, word[i]);\n                }\n                // If we hit another vowel, we can stop checking\n                if (vowels.find(word[j]) != string::npos) {\n                    break;\n                }\n            }\n        }\n    }\n    \n    // If no valid vowel was found, return an empty string\n    return \"\";\n}\n\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0];\n    string s2 = lst[1];\n\n    // Function to calculate the balance of a string\n    auto get_balance_info = [](const string& s) {\n        int balance = 0;\n        int min_balance = 0; // Minimum balance encountered\n        for (char c : s) {\n            if (c == '(') {\n                balance++;\n            } else {\n                balance--;\n            }\n            min_balance = min(min_balance, balance);\n        }\n        return make_pair(balance, min_balance);\n    };\n\n    // Get balance info for both strings\n    auto [balance1, min_balance1] = get_balance_info(s1);\n    auto [balance2, min_balance2] = get_balance_info(s2);\n\n    // Check if s1 + s2 is balanced\n    if (balance1 + balance2 == 0 && min_balance1 + balance2 >= 0) {\n        return \"Yes\";\n    }\n\n    // Check if s2 + s1 is balanced\n    if (balance2 + balance1 == 0 && min_balance2 + balance1 >= 0) {\n        return \"Yes\";\n    }\n\n    return \"No\";\n}\n\n"}
{"task_id": "CPP/120", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 1: Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Step 2: Select the first k elements\n    vector<int> max_k_elements(arr.begin(), arr.begin() + k);\n    \n    // Step 3: Sort the selected k elements in ascending order\n    sort(max_k_elements.begin(), max_k_elements.end());\n    \n    return max_k_elements;\n}\n\n"}
{"task_id": "CPP/121", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0; // Initialize sum to 0\n    for (size_t i = 0; i < lst.size(); i++) {\n        // Check if the index is even and the element is odd\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i]; // Add the element to sum\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/122", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0; // Initialize sum to 0\n    // Iterate through the first k elements of arr\n    for (int i = 0; i < k; i++) {\n        // Check if the current element has at most two digits\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i]; // Add to sum if condition is met\n        }\n    }\n    return sum; // Return the final sum\n}\n\n"}
{"task_id": "CPP/123", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers; // Vector to store odd numbers\n    while (n != 1) {\n        if (n % 2 != 0) { // Check if n is odd\n            odd_numbers.push_back(n); // Add to vector if odd\n        }\n        // Generate the next term in the Collatz sequence\n        if (n % 2 == 0) {\n            n = n / 2; // If even, divide by 2\n        } else {\n            n = 3 * n + 1; // If odd, apply 3n + 1\n        }\n    }\n    // Include 1 in the sequence as it is odd\n    odd_numbers.push_back(1);\n    \n    // Sort the vector of odd numbers\n    sort(odd_numbers.begin(), odd_numbers.end());\n    \n    return odd_numbers; // Return the sorted vector\n}\n\n// Example usage\n"}
{"task_id": "CPP/124", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) {\n        return false;\n    }\n\n    // Check if the date is in the format mm-dd-yyyy\n    if (date.size() != 10 || date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n\n    // Extract month, day, and year from the date string\n    int month, day, year;\n    stringstream ss(date);\n    string monthStr, dayStr, yearStr;\n\n    getline(ss, monthStr, '-');\n    getline(ss, dayStr, '-');\n    getline(ss, yearStr);\n\n    // Convert strings to integers\n    month = stoi(monthStr);\n    day = stoi(dayStr);\n    year = stoi(yearStr);\n\n    // Validate month\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    // Validate day based on month\n    if (day < 1) {\n        return false;\n    }\n    \n    if (month == 2) {\n        // February: check for leap year\n        if (day > 29) {\n            return false;\n        }\n        if (day == 29 && (year % 4 != 0 || (year % 100 == 0 && year % 400 != 0))) {\n            return false; // Not a leap year\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        // Months with 30 days\n        if (day > 30) {\n            return false;\n        }\n    } else {\n        // Months with 31 days\n        if (day > 31) {\n            return false;\n        }\n    }\n\n    return true; // All checks passed, the date is valid\n}\n\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    \n    // Check for whitespace\n    size_t pos = txt.find_first_of(\" \\t\\n\");\n    if (pos != string::npos) {\n        // Split by whitespace\n        istringstream iss(txt);\n        string word;\n        while (iss >> word) {\n            result.push_back(word);\n        }\n        return result;\n    }\n\n    // Check for commas\n    pos = txt.find(',');\n    if (pos != string::npos) {\n        // Split by commas\n        stringstream ss(txt);\n        string word;\n        while (getline(ss, word, ',')) {\n            result.push_back(word);\n        }\n        return result;\n    }\n\n    // If no whitespace or commas, count lowercase letters with odd order\n    int count = 0;\n    for (char c : txt) {\n        if (islower(c)) {\n            int index = c - 'a'; // Get the index of the letter\n            if (index % 2 == 1) { // Check if the index is odd\n                count++;\n            }\n        }\n    }\n    \n    result.push_back(to_string(count)); // Convert count to string and add to result\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/126", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Check for the sorted condition and count occurrences\n    unordered_map<int, int> countMap;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Count occurrences of each number\n        countMap[lst[i]]++;\n        \n        // If any number appears more than twice, return false\n        if (countMap[lst[i]] > 2) {\n            return false;\n        }\n        \n        // Check if the current number is less than the previous number\n        if (i > 0 && lst[i] < lst[i - 1]) {\n            return false;\n        }\n    }\n    \n    // If we pass both checks, return true\n    return true;\n}\n\n"}
{"task_id": "CPP/127", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it is prime\n}\n\n// Function to find the intersection of two intervals and check if its length is prime\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    // Calculate the start and end of the intersection\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n\n    // Check if there is an intersection\n    if (start > end) {\n        return \"NO\"; // No intersection\n    }\n\n    // Calculate the length of the intersection\n    int length = end - start + 1; // +1 because both ends are inclusive\n\n    // Check if the length is prime\n    if (isPrime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n// Example usage\n"}
{"task_id": "CPP/128", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768; // Return -32768 for empty array\n    }\n\n    int sum_magnitudes = 0;\n    int sign_product = 1; // Start with a neutral sign product\n    int negative_count = 0; // Count of negative numbers\n\n    for (int num : arr) {\n        if (num > 0) {\n            sum_magnitudes += num; // Add magnitude\n        } else if (num < 0) {\n            sum_magnitudes += -num; // Add magnitude\n            negative_count++; // Count negative numbers\n        } else {\n            // If we encounter a zero, the product of signs becomes zero\n            return 0;\n        }\n    }\n\n    // Determine the product of signs\n    if (negative_count % 2 == 0) {\n        sign_product = 1; // Even number of negatives\n    } else {\n        sign_product = -1; // Odd number of negatives\n    }\n\n    return sum_magnitudes * sign_product; // Return the final result\n}\n\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid dfs(const vector<vector<int>>& grid, int x, int y, int k, vector<int>& currentPath, vector<int>& bestPath) {\n    // If we have reached the desired path length\n    if (currentPath.size() == k) {\n        // Compare with the best path found so far\n        if (bestPath.empty() || currentPath < bestPath) {\n            bestPath = currentPath; // Update the best path\n        }\n        return;\n    }\n\n    // Directions for moving in the grid (up, down, left, right)\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    \n    // Explore all possible directions\n    for (const auto& dir : directions) {\n        int newX = x + dir.first;\n        int newY = y + dir.second;\n\n        // Check if the new position is within the grid bounds\n        if (newX >= 0 && newX < grid.size() && newY >= 0 && newY < grid[0].size()) {\n            // Add the value at the new position to the current path\n            currentPath.push_back(grid[newX][newY]);\n            // Continue the search from the new position\n            dfs(grid, newX, newY, k, currentPath, bestPath);\n            // Backtrack: remove the last added value\n            currentPath.pop_back();\n        }\n    }\n}\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    vector<int> bestPath; // To store the best path found\n    int n = grid.size();\n\n    // Start DFS from each cell in the grid\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            vector<int> currentPath; // To store the current path\n            currentPath.push_back(grid[i][j]); // Start the path with the current cell\n            dfs(grid, i, j, k, currentPath, bestPath); // Perform DFS\n            currentPath.pop_back(); // Backtrack\n        }\n    }\n\n    return bestPath; // Return the best path found\n}\n\n"}
{"task_id": "CPP/130", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> result(n + 1);\n    \n    // Base case\n    if (n >= 0) result[0] = 1; // tri(0) = 1\n    if (n >= 1) result[1] = 3; // tri(1) = 3\n    \n    // Fill the vector based on the rules\n    for (int i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result[i] = 1 + i / 2; // Even case\n        } else {\n            // Odd case: tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1)\n            // We need to ensure we have computed tri(n + 1) before using it\n            if (i + 1 <= n) {\n                result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n            } else {\n                result[i] = result[i - 1] + result[i - 2]; // If n + 1 is out of bounds\n            }\n        }\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/131", "generation": "#include <iostream>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOdd = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply it to the product\n            hasOdd = true; // Mark that we found an odd digit\n        }\n        n /= 10; // Remove the last digit\n    }\n\n    return hasOdd ? product : 0; // Return product if odd digits found, else return 0\n}\n\n"}
{"task_id": "CPP/132", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int open_count = 0; // Count of opening brackets\n    int nested_count = 0; // Count of nested brackets\n\n    for (char ch : str) {\n        if (ch == '[') {\n            open_count++; // Increment count for opening bracket\n        } else if (ch == ']') {\n            if (open_count > 0) {\n                open_count--; // Match with an opening bracket\n                if (open_count > 0) {\n                    nested_count++; // Found a nested pair\n                }\n            } else {\n                // More closing brackets than opening brackets\n                return false;\n            }\n        }\n    }\n\n    // We need at least one nested pair\n    return nested_count > 0;\n}\n\n"}
{"task_id": "CPP/133", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int total_sum = 0; // Initialize the sum to 0\n    for (float num : lst) {\n        int rounded_value = ceil(num); // Round up to the nearest integer\n        total_sum += rounded_value * rounded_value; // Square and add to total sum\n    }\n    return total_sum; // Return the total sum\n}\n\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\n#include <cctype> // for isalpha function\n\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Trim trailing spaces\n    size_t end = txt.find_last_not_of(' ');\n    if (end == string::npos) {\n        // The string is empty or contains only spaces\n        return false;\n    }\n\n    // Get the last character\n    char lastChar = txt[end];\n\n    // Check if the last character is an alphabetical character\n    if (isalpha(lastChar)) {\n        // Check if it is not part of a word\n        if (end == 0 || txt[end - 1] == ' ') {\n            return true; // Last character is a letter and not part of a word\n        }\n    }\n\n    return false; // Last character is not a letter or is part of a word\n}\n\n"}
{"task_id": "CPP/135", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int n = arr.size();\n    int largestIndex = -1; // Initialize to -1, which will be returned if no such element is found\n\n    // Iterate through the array starting from the second element\n    for (int i = 1; i < n; i++) {\n        // Check if the current element is less than the previous element\n        if (arr[i] < arr[i - 1]) {\n            largestIndex = i; // Update the largest index\n        }\n    }\n\n    return largestIndex; // Return the largest index found, or -1 if none was found\n}\n\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = numeric_limits<int>::min(); // Start with the smallest possible integer\n    int smallest_positive = numeric_limits<int>::max(); // Start with the largest possible integer\n\n    bool found_negative = false;\n    bool found_positive = false;\n\n    for (int num : lst) {\n        if (num < 0) {\n            found_negative = true;\n            if (num > largest_negative) {\n                largest_negative = num; // Update largest negative\n            }\n        } else if (num > 0) {\n            found_positive = true;\n            if (num < smallest_positive) {\n                smallest_positive = num; // Update smallest positive\n            }\n        }\n    }\n\n    // If no negative numbers were found, set largest_negative to 0\n    if (!found_negative) {\n        largest_negative = 0;\n    }\n    \n    // If no positive numbers were found, set smallest_positive to 0\n    if (!found_positive) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <boost/any.hpp>\n#include <sstream>\n#include <iomanip>\n\nusing namespace std;\n\n// Function to convert a string to a float, handling both '.' and ',' as decimal points\nfloat string_to_float(const string& str) {\n    string sanitized = str;\n    // Replace ',' with '.' for conversion\n    replace(sanitized.begin(), sanitized.end(), ',', '.');\n    return stof(sanitized);\n}\n\n// Function to compare two boost::any values\nboost::any compare_one(boost::any a, boost::any b) {\n    // Check if both are of the same type\n    if (a.type() == b.type()) {\n        if (a.type() == typeid(int)) {\n            int int_a = boost::any_cast<int>(a);\n            int int_b = boost::any_cast<int>(b);\n            if (int_a == int_b) return \"None\";\n            return (int_a > int_b) ? a : b;\n        } else if (a.type() == typeid(float)) {\n            float float_a = boost::any_cast<float>(a);\n            float float_b = boost::any_cast<float>(b);\n            if (float_a == float_b) return \"None\";\n            return (float_a > float_b) ? a : b;\n        } else if (a.type() == typeid(string)) {\n            string str_a = boost::any_cast<string>(a);\n            string str_b = boost::any_cast<string>(b);\n            float float_a = string_to_float(str_a);\n            float float_b = string_to_float(str_b);\n            if (float_a == float_b) return \"None\";\n            return (float_a > float_b) ? a : b;\n        }\n    } else {\n        // If types are different, we need to convert to a common type for comparison\n        float float_a, float_b;\n\n        // Convert a to float\n        if (a.type() == typeid(int)) {\n            float_a = boost::any_cast<int>(a);\n        } else if (a.type() == typeid(float)) {\n            float_a = boost::any_cast<float>(a);\n        } else if (a.type() == typeid(string)) {\n            float_a = string_to_float(boost::any_cast<string>(a));\n        }\n\n        // Convert b to float\n        if (b.type() == typeid(int)) {\n            float_b = boost::any_cast<int>(b);\n        } else if (b.type() == typeid(float)) {\n            float_b = boost::any_cast<float>(b);\n        } else if (b.type() == typeid(string)) {\n            float_b = string_to_float(boost::any_cast<string>(b));\n        }\n\n        if (float_a == float_b) return \"None\";\n        return (float_a > float_b) ? a : b;\n    }\n\n    return \"None\"; // Fallback\n}\n\n"}
{"task_id": "CPP/138", "generation": "#include <iostream>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is less than 8 or if n is odd\n    if (n < 8 || n % 2 != 0) {\n        return false;\n    }\n    return true; // n is even and >= 8\n}\n\n"}
{"task_id": "CPP/139", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to calculate factorial of a number\nlong long factorial(int num) {\n    long long result = 1;\n    for (int i = 1; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Function to calculate the Brazilian factorial\nlong long special_factorial(int n) {\n    long long result = 1; // Initialize result to 1\n    for (int i = 1; i <= n; ++i) {\n        result *= factorial(i); // Multiply by the factorial of i\n    }\n    return result;\n}\n\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int space_count = 0; // To count consecutive spaces\n\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++; // Increment space count\n        } else {\n            // If we have counted spaces, we need to process them\n            if (space_count > 0) {\n                if (space_count == 1) {\n                    result += '_'; // Replace single space with underscore\n                } else {\n                    result += '-'; // Replace more than one space with a hyphen\n                }\n                space_count = 0; // Reset space count\n            }\n            result += c; // Add the current character to the result\n        }\n    }\n\n    // Handle any trailing spaces at the end of the string\n    if (space_count > 0) {\n        if (space_count == 1) {\n            result += '_'; // Replace single space with underscore\n        } else {\n            result += '-'; // Replace more than one space with a hyphen\n        }\n    }\n\n    return result;\n}\n\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check for exactly one dot\n    size_t dot_pos = file_name.find('.');\n    if (dot_pos == string::npos || file_name.find('.', dot_pos + 1) != string::npos) {\n        return \"No\";\n    }\n\n    // Split the file name into name and extension\n    string name_part = file_name.substr(0, dot_pos);\n    string ext_part = file_name.substr(dot_pos + 1);\n\n    // Check if the name part is not empty and starts with a letter\n    if (name_part.empty() || !isalpha(name_part[0])) {\n        return \"No\";\n    }\n\n    // Check for the valid extensions\n    if (ext_part != \"txt\" && ext_part != \"exe\" && ext_part != \"dll\") {\n        return \"No\";\n    }\n\n    // Count the number of digits in the file name\n    int digit_count = 0;\n    for (char c : file_name) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n    }\n\n    // Check if there are more than three digits\n    if (digit_count > 3) {\n        return \"No\";\n    }\n\n    // If all conditions are met, return \"Yes\"\n    return \"Yes\";\n}\n\n// Example usage\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int total_sum = 0; // Initialize the sum to 0\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            // Index is a multiple of 3, square the entry\n            total_sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            // Index is a multiple of 4 but not a multiple of 3, cube the entry\n            total_sum += lst[i] * lst[i] * lst[i];\n        } else {\n            // Index is neither a multiple of 3 nor 4, keep the entry as is\n            total_sum += lst[i];\n        }\n    }\n\n    return total_sum; // Return the total sum\n}\n\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Function to extract words with prime lengths\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    vector<string> result;\n\n    // Split the sentence into words\n    while (ss >> word) {\n        // Check if the length of the word is prime\n        if (is_prime(word.length())) {\n            result.push_back(word); // Add to result if prime\n        }\n    }\n\n    // Join the result words into a single string\n    string output;\n    for (size_t i = 0; i < result.size(); i++) {\n        output += result[i];\n        if (i < result.size() - 1) {\n            output += \" \"; // Add space between words\n        }\n    }\n\n    return output;\n}\n\n// Example usage\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Split the first fraction x\n    size_t pos = x.find('/');\n    int numerator_x = stoi(x.substr(0, pos));\n    int denominator_x = stoi(x.substr(pos + 1));\n    \n    // Split the second fraction n\n    pos = n.find('/');\n    int numerator_n = stoi(n.substr(0, pos));\n    int denominator_n = stoi(n.substr(pos + 1));\n    \n    // Calculate the product of the fractions\n    int numerator_product = numerator_x * numerator_n;\n    int denominator_product = denominator_x * denominator_n;\n    \n    // Check if the product is a whole number\n    return (numerator_product % denominator_product == 0);\n}\n\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n// Helper function to calculate the sum of digits\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    int original_num = abs(num); // Store the absolute value for later use\n\n    while (original_num > 0) {\n        sum += original_num % 10;\n        original_num /= 10;\n    }\n\n    // If the number was negative, we subtract twice the first digit\n    if (is_negative) {\n        // Calculate the first digit of the original number\n        int first_digit = abs(num) / pow(10, (int)log10(abs(num)));\n        sum -= 2 * first_digit; // Subtract twice the first digit\n    }\n\n    return sum;\n}\n\n// Function to sort the vector based on the sum of digits\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of pairs to store the original index and the number\n    vector<pair<int, int>> indexed_nums;\n\n    for (int i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({sum_of_digits(nums[i]), i});\n    }\n\n    // Sort based on the sum of digits and then by original index\n    sort(indexed_nums.begin(), indexed_nums.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        if (a.first == b.first) {\n            return a.second < b.second; // Sort by index if sums are equal\n        }\n        return a.first < b.first; // Sort by sum of digits\n    });\n\n    // Extract the sorted numbers based on the sorted indices\n    vector<int> sorted_nums;\n    for (const auto& p : indexed_nums) {\n        sorted_nums.push_back(nums[p.second]);\n    }\n\n    return sorted_nums;\n}\n\n// Example usage\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n\n    for (int num : nums) {\n        // Check if the number is greater than 10\n        if (num > 10) {\n            // Convert the number to a string to easily access first and last digits\n            string numStr = to_string(num);\n            char firstDigit = numStr[0];\n            char lastDigit = numStr[numStr.length() - 1];\n\n            // Check if both first and last digits are odd\n            if ((firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || firstDigit == '7' || firstDigit == '9') &&\n                (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' || lastDigit == '7' || lastDigit == '9')) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    // Step 1: Generate the vector a\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1; // a[i] corresponds to a[i-1] in 0-indexed\n    }\n\n    // Step 2: Count occurrences of each residue class modulo 3\n    int count[3] = {0, 0, 0};\n    for (int i = 0; i < n; ++i) {\n        count[a[i] % 3]++;\n    }\n\n    // Step 3: Count valid triples\n    int total_triples = 0;\n\n    // Case 1: All three numbers have the same residue\n    for (int i = 0; i < 3; ++i) {\n        if (count[i] >= 3) {\n            total_triples += (count[i] * (count[i] - 1) * (count[i] - 2)) / 6; // nC3\n        }\n    }\n\n    // Case 2: One from each residue class\n    total_triples += count[0] * count[1] * count[2];\n\n    return total_triples;\n}\n\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    // List of planets in order from the Sun\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Find the indices of the given planets\n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n    \n    // Check if both planets are valid\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {}; // Return empty vector if either planet is invalid\n    }\n    \n    // Get the indices of the planets\n    int index1 = distance(planets.begin(), it1);\n    int index2 = distance(planets.begin(), it2);\n    \n    // Ensure index1 is less than index2\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Collect planets between the two indices\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n\n"}
{"task_id": "CPP/149", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> vector_sort(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0; // Keep only even length strings\n    }), lst.end());\n\n    // Sort the remaining strings by length and then alphabetically\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Sort alphabetically if lengths are equal\n        }\n        return a.length() < b.length(); // Sort by length\n    });\n\n    return lst;\n}\n\n"}
{"task_id": "CPP/150", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it is prime\n}\n\n// Function to return x if n is prime, otherwise return y\nint x_or_y(int n, int x, int y) {\n    if (isPrime(n)) {\n        return x; // n is prime\n    } else {\n        return y; // n is not prime\n    }\n}\n\n"}
{"task_id": "CPP/151", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum_of_squares = 0;\n\n    for (float num : lst) {\n        // Check if the number is an integer and non-negative\n        if (num >= 0 && floor(num) == num) {\n            int int_num = static_cast<int>(num);\n            // Check if the number is odd\n            if (int_num % 2 != 0) {\n                sum_of_squares += int_num * int_num; // Add the square of the odd number\n            }\n        }\n    }\n\n    return sum_of_squares;\n}\n\n"}
{"task_id": "CPP/152", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for std::abs\n\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result; // Vector to store the results\n    int n = game.size(); // Get the size of the vectors\n\n    // Iterate through each match\n    for (int i = 0; i < n; ++i) {\n        // Calculate the absolute difference and add to the result vector\n        result.push_back(abs(game[i] - guess[i]));\n    }\n\n    return result; // Return the result vector\n}\n\n"}
{"task_id": "CPP/153", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = -1; // Initialize to a value lower than any possible strength\n    string strongest_extension = \"\";\n\n    for (const string& ext : extensions) {\n        int CAP = 0; // Count of uppercase letters\n        int SM = 0;  // Count of lowercase letters\n\n        // Calculate CAP and SM\n        for (char c : ext) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n\n        // Calculate strength\n        int strength = CAP - SM;\n\n        // Update the strongest extension if this one is stronger\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    // Return the result in the required format\n    return class_name + \".\" + strongest_extension;\n}\n\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Concatenate b with itself to get all rotations\n    string b_rotations = b + b;\n    \n    // Check if a contains any substring of b_rotations that is of length equal to b\n    return b_rotations.find(a) != string::npos;\n}\n\n"}
{"task_id": "CPP/155", "generation": "#include <iostream>\n#include <vector>\n#include <cmath> // for abs\n\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Initialize counts for even and odd digits\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Work with the absolute value of the number\n    num = abs(num);\n\n    // Check if the number is zero\n    if (num == 0) {\n        even_count = 1; // 0 is considered an even digit\n        return {even_count, odd_count};\n    }\n\n    // Iterate through each digit\n    while (num > 0) {\n        int digit = num % 10; // Get the last digit\n        if (digit % 2 == 0) {\n            even_count++; // Increment even count\n        } else {\n            odd_count++; // Increment odd count\n        }\n        num /= 10; // Remove the last digit\n    }\n\n    // Return the counts in a vector\n    return {even_count, odd_count};\n}\n\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the Roman numeral symbols and their corresponding values\n    vector<pair<int, string>> roman_numerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string result = \"\";\n    \n    // Iterate through the roman_numerals vector\n    for (const auto& pair : roman_numerals) {\n        while (number >= pair.first) {\n            result += pair.second; // Append the Roman numeral\n            number -= pair.first;  // Decrease the number\n        }\n    }\n    \n    return result; // Return the final Roman numeral string\n}\n\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to identify the longest side\n    float x = fmax(a, fmax(b, c)); // longest side\n    float y, z;\n\n    if (x == a) {\n        y = b;\n        z = c;\n    } else if (x == b) {\n        y = a;\n        z = c;\n    } else {\n        y = a;\n        z = b;\n    }\n\n    // Check if the Pythagorean theorem holds\n    return (y * y + z * z) == (x * x);\n}\n\n"}
{"task_id": "CPP/158", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string max_word;\n    int max_unique_count = 0;\n\n    for (const string& word : words) {\n        // Use a set to find unique characters\n        set<char> unique_chars(word.begin(), word.end());\n        int unique_count = unique_chars.size();\n\n        // Check if we found a new maximum or if we need to update for lexicographical order\n        if (unique_count > max_unique_count || \n            (unique_count == max_unique_count && (max_word.empty() || word < max_word))) {\n            max_unique_count = unique_count;\n            max_word = word;\n        }\n    }\n\n    return max_word;\n}\n\n"}
{"task_id": "CPP/159", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    // Total carrots to be eaten\n    int totalEaten = number + need;\n    \n    // Check if we can eat all the needed carrots\n    if (remaining >= need) {\n        // We can eat all needed carrots\n        remaining -= need;\n    } else {\n        // We eat all remaining carrots\n        totalEaten += remaining; // Add remaining to total eaten\n        remaining = 0; // No carrots left\n    }\n    \n    // Return the result as a vector\n    return {totalEaten, remaining};\n}\n\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stdexcept>\n\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    if (operato.size() != operand.size() - 1) {\n        throw invalid_argument(\"The length of operator vector must be one less than the operand vector.\");\n    }\n\n    // Step 1: Handle multiplication, division, and exponentiation first\n    vector<int> temp_operand = operand;\n    vector<string> temp_operator = operato;\n\n    for (size_t i = 0; i < temp_operator.size(); ++i) {\n        if (temp_operator[i] == \"*\" || temp_operator[i] == \"//\" || temp_operator[i] == \"**\") {\n            int result = 0;\n            if (temp_operator[i] == \"*\") {\n                result = temp_operand[i] * temp_operand[i + 1];\n            } else if (temp_operator[i] == \"//\") {\n                if (temp_operand[i + 1] == 0) {\n                    throw invalid_argument(\"Division by zero is not allowed.\");\n                }\n                result = temp_operand[i] / temp_operand[i + 1];\n            } else if (temp_operator[i] == \"**\") {\n                result = pow(temp_operand[i], temp_operand[i + 1]);\n            }\n\n            // Replace the current operand and operator with the result\n            temp_operand[i] = result;\n            temp_operand.erase(temp_operand.begin() + i + 1);\n            temp_operator.erase(temp_operator.begin() + i);\n            i--; // Adjust index after removal\n        }\n    }\n\n    // Step 2: Handle addition and subtraction\n    int final_result = temp_operand[0];\n    for (size_t i = 0; i < temp_operator.size(); ++i) {\n        if (temp_operator[i] == \"+\") {\n            final_result += temp_operand[i + 1];\n        } else if (temp_operator[i] == \"-\") {\n            final_result -= temp_operand[i + 1];\n        }\n    }\n\n    return final_result;\n}\n\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetter = false;\n\n    // Check if the string contains any letters\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    if (hasLetter) {\n        // Reverse case of letters\n        for (char &c : s) {\n            if (isalpha(c)) {\n                if (islower(c)) {\n                    c = toupper(c);\n                } else {\n                    c = tolower(c);\n                }\n            }\n        }\n    } else {\n        // Reverse the entire string\n        reverse(s.begin(), s.end());\n    }\n\n    return s;\n}\n\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\"; // Return an empty string if input is empty\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    // Convert the unsigned char array to a hex string\n    char md5String[33]; // MD5 produces a 32-character hex string\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        sprintf(&md5String[i * 2], \"%02x\", (unsigned int)digest[i]);\n    }\n    md5String[32] = '\\0'; // Null-terminate the string\n\n    return string(md5String);\n}\n\n"}
{"task_id": "CPP/163", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm> // for std::sort\n\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> even_digits;\n    \n    // Determine the range\n    int start = min(a, b);\n    int end = max(a, b);\n    \n    // Loop through the range\n    for (int i = start; i <= end; ++i) {\n        // Check if the number is a single digit and even\n        if (i >= 0 && i < 10 && i % 2 == 0) {\n            even_digits.push_back(i);\n        }\n    }\n    \n    // Sort the vector (though it should already be in order due to the loop)\n    sort(even_digits.begin(), even_digits.end());\n    \n    return even_digits;\n}\n\n"}
