{"task_id": "CPP/4", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Step 1: Calculate the mean\n    float sum = 0.0;\n    int n = numbers.size();\n    \n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / n;\n\n    // Step 2: Calculate the sum of absolute differences\n    float absolute_difference_sum = 0.0;\n    \n    for (float num : numbers) {\n        absolute_difference_sum += fabs(num - mean);\n    }\n\n    // Step 3: Calculate Mean Absolute Deviation\n    float mad = absolute_difference_sum / n;\n\n    // Step 4: Return the result\n    return mad;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(mean_absolute_deviation({1.0, 2.0, 3.0}) - 2.0/3.0) < 1e-4);\n    assert (abs(mean_absolute_deviation({1.0, 2.0, 3.0, 4.0}) - 1.0) < 1e-4);\n    assert (abs(mean_absolute_deviation({1.0, 2.0, 3.0, 4.0, 5.0}) - 6.0/5.0) < 1e-4);\n}", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/11", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Step 1: Input validation\n    if (a.length() != b.length()) {\n        return \"Error: Strings must be of equal length.\";\n    }\n    for (char c : a) {\n        if (c != '0' && c != '1') {\n            return \"Error: String a contains invalid characters.\";\n        }\n    }\n    for (char c : b) {\n        if (c != '0' && c != '1') {\n            return \"Error: String b contains invalid characters.\";\n        }\n    }\n\n    // Step 2: Initialize result string\n    string result = \"\";\n\n    // Step 3: Iterate and compute XOR\n    for (size_t i = 0; i < a.length(); ++i) {\n        if (a[i] == b[i]) {\n            result += '0'; // Both are the same\n        } else {\n            result += '1'; // Different\n        }\n    }\n\n    // Step 4: Return the result\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (string_xor(\"111000\", \"101010\") == \"010010\");\n     assert (string_xor(\"1\", \"1\") == \"0\");\n    assert (string_xor(\"0101\", \"0000\") == \"0101\");\n\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/3", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Initialize balance\n\n    // Loop through each operation\n    for (int operation : operations) {\n        balance += operation; // Update balance\n\n        // Check if balance is below zero\n        if (balance < 0) {\n            return true; // Return true if balance is negative\n        }\n    }\n\n    return false; // Return false if balance never went below zero\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (below_zero({}) == false);\n    assert (below_zero({1, 2, -3, 1, 2, -3}) == false);\n    assert (below_zero({1, 2, -4, 5, 6}) == true);\n    assert (below_zero({1, -1, 2, -2, 5, -5, 4, -4}) == false);\n    assert (below_zero({1, -1, 2, -2, 5, -5, 4, -5}) == true);\n    assert (below_zero({1, -2, 2, -2, 5, -5, 4, -4}) == true);\n}", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/2", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat truncate_number(float number) {\n    // Input validation\n    if (number <= 0) {\n        return 0; // or handle error\n    }\n\n    // Extract Integer Part\n    int integerPart = floor(number);\n\n    // Calculate Decimal Part\n    float decimalPart = number - integerPart;\n\n    // Return the Decimal Part\n    return decimalPart;\n}\n\n// Example usage\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n assert (truncate_number(3.5) == 0.5); \n assert (abs(truncate_number(1.33) - 0.33) < 1e-4);\n  assert (abs(truncate_number(123.456) - 0.456) < 1e-4);\n}", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/8", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    // Check for empty vector\n    if (numbers.empty()) {\n        return {0, 1}; // Return (0, 1) for empty input\n    }\n\n    // Initialize sum and product\n    int sum = 0;\n    int product = 1;\n\n    // Iterate through the vector\n    for (int number : numbers) {\n        sum += number;      // Calculate sum\n        product *= number;  // Calculate product\n    }\n\n    // Return the result\n    return {sum, product}; // Return the sum and product as a vector\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sum_product({}) ,{0, 1}));\n    assert (issame(sum_product({1, 1, 1}), {3, 1}));\n    assert (issame(sum_product({100, 0}),{100, 0}));\n     assert (issame(sum_product({3, 5, 7}) , {3 + 5 + 7, 3 * 5 * 7}));\n      assert (issame(sum_product({10}) ,{10, 10}));\n}\n\n\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/7", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    // Step 1: Initialize an empty result vector\n    vector<string> result;\n\n    // Step 2: Handle edge cases\n    if (strings.empty() || substring.empty()) {\n        return result; // Return empty vector if input vector or substring is empty\n    }\n\n    // Step 3: Iterate through each string in the input vector\n    for (const string& str : strings) {\n        // Step 4: Check if the substring is found in the current string\n        if (str.find(substring) != string::npos) {\n            // Step 5: If found, add the string to the result vector\n            result.push_back(str);\n        }\n    }\n\n    // Step 6: Return the filtered result vector\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_by_substring({}, \"john\"),{}));\n     assert (issame(filter_by_substring({\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\"), {\"xxx\", \"xxxAAA\", \"xxx\"}));\n    assert (issame(filter_by_substring({\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xx\"),{\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"}));\n     assert (issame(filter_by_substring({\"grunt\", \"trumpet\", \"prune\", \"gruesome\"}, \"run\") ,{\"grunt\", \"prune\"}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/0", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\n#include <math.h>\n#include <algorithm> // For std::sort\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Step 1: Input validation (optional)\n    if (numbers.size() < 2) {\n        return false; // No pairs to compare\n    }\n\n    // Step 2: Sort the vector\n    sort(numbers.begin(), numbers.end());\n\n    // Step 3: Compare adjacent elements\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (fabs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true; // Found close elements\n        }\n    }\n\n    // Step 4: No close elements found\n    return false;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    vector<float> a={1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert (has_close_elements(a, 0.3)==true);\n    assert (has_close_elements(a, 0.05) == false);\n\n    assert (has_close_elements({1.0, 2.0, 5.9, 4.0, 5.0}, 0.95) == true);\n    assert (has_close_elements({1.0, 2.0, 5.9, 4.0, 5.0}, 0.8) ==false);\n    assert (has_close_elements({1.0, 2.0, 3.0, 4.0, 5.0}, 2.0) == true);\n    assert (has_close_elements({1.1, 2.2, 3.1, 4.1, 5.1}, 1.0) == true);\n    assert (has_close_elements({1.1, 2.2, 3.1, 4.1, 5.1}, 0.5) == false);\n    \n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/1", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    // Step 2: Input Cleaning\n    string cleaned;\n    for (char c : paren_string) {\n        if (c != ' ') {\n            cleaned += c;\n        }\n    }\n\n    // Step 3: Initialize Variables\n    vector<string> groups;\n    int balance = 0;\n    string temp;\n\n    // Step 4: Traverse the Cleaned String\n    for (char c : cleaned) {\n        temp += c; // Add current character to the temporary string\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n        }\n\n        // If balance is zero, we have a complete group\n        if (balance == 0) {\n            groups.push_back(temp); // Store the complete group\n            temp.clear(); // Clear temporary string for the next group\n        }\n    }\n\n    // Step 5: Return Result\n    return groups;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){  \n    assert (issame(separate_paren_groups(\"(()()) ((())) () ((())()())\"),{\"(()())\", \"((()))\", \"()\", \"((())()())\"}));\n    assert (issame(separate_paren_groups(\"() (()) ((())) (((())))\"), {\"()\", \"(())\", \"((()))\", \"(((())))\" }));\n    assert (issame(separate_paren_groups(\"(()(())((())))\") ,{ \"(()(())((())))\" }));\n    assert (issame(separate_paren_groups(\"( ) (( )) (( )( ))\") ,{\"()\", \"(())\", \"(()())\"}));\n}", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/6", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> results;\n    stringstream ss(paren_string);\n    string group;\n\n    while (ss >> group) {\n        int current_depth = 0;\n        int max_depth = 0;\n\n        for (char ch : group) {\n            if (ch == '(') {\n                current_depth++;\n                if (current_depth > max_depth) {\n                    max_depth = current_depth;\n                }\n            } else if (ch == ')') {\n                current_depth--;\n            }\n        }\n\n        results.push_back(max_depth);\n    }\n\n    return results;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(parse_nested_parens(\"(()()) ((())) () ((())()())\"),{2, 3, 1, 3}));\n     assert (issame(parse_nested_parens(\"() (()) ((())) (((())))\") , {1, 2, 3, 4}));\n    assert (issame(parse_nested_parens(\"(()(())((())))\") ,{4}));\n}", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/5", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) { \n    // Check for edge cases\n    if (numbers.empty()) {\n        return {};\n    }\n    if (numbers.size() == 1) {\n        return numbers;\n    }\n\n    // Initialize the output vector\n    vector<int> result;\n\n    // Iterate through the input vector\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        // Add the current element to the result\n        result.push_back(numbers[i]);\n\n        // Add delimeter if not the last element\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    // Return the output vector\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(intersperse({}, 7), {}));\n    \n    assert (issame(intersperse({5, 6, 3, 2}, 8),{5, 8, 6, 8, 3, 8, 2}));\n    assert (issame(intersperse({2, 2, 2}, 2),{2, 2, 2, 2, 2}));\n}", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/9", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    // Step 1: Check for empty input\n    if (numbers.empty()) {\n        return {};\n    }\n\n    // Step 2: Initialize result vector and current maximum\n    vector<int> result;\n    int current_max = numbers[0]; // Start with the first element\n\n    // Step 3: Iterate through the input vector\n    for (int num : numbers) {\n        // Step 4: Update current maximum if necessary\n        if (num > current_max) {\n            current_max = num;\n        }\n        // Step 5: Append current maximum to result\n        result.push_back(current_max);\n    }\n\n    // Step 6: Return the result vector\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n     assert (issame(rolling_max({}),{}));\n    assert (issame(rolling_max({1, 2, 3, 4}) , {1, 2, 3, 4}));\n     assert (issame(rolling_max({4, 3, 2, 1}),{4, 4, 4, 4}));\n      assert (issame(rolling_max({3, 2, 3, 100, 3}) ,{3, 3, 3, 100, 100}));\n}", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/12", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"None\"; // Return \"None\" for empty input\n    }\n\n    string longestString = \"\";\n    size_t maxLength = 0;\n\n    for (const string& str : strings) {\n        if (str.length() > maxLength) {\n            longestString = str;\n            maxLength = str.length();\n        }\n    }\n\n    return longestString;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (longest({}) == \"\");\n    assert (longest({\"x\", \"y\", \"z\"}) == \"x\");\n    assert (longest({\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"}) == \"zzzz\");\n}\n", "result": "failed: a.out: test.cpp:41: int main(): Assertion `longest({}) == \"\"' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/10", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring longest_palindromic_suffix(string str) {\n    for (int i = str.length(); i >= 0; --i) {\n        if (is_palindrome(str.substr(i))) {\n            return str.substr(i);\n        }\n    }\n    return \"\"; // In case no palindromic suffix is found\n}\n\nstring make_palindrome(string str) {\n    string suffix = longest_palindromic_suffix(str);\n    string prefix = str.substr(0, str.length() - suffix.length());\n    string reversed_prefix(prefix.rbegin(), prefix.rend());\n    return str + reversed_prefix; // Construct the palindrome\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (make_palindrome(\"\") == \"\");\n    assert (make_palindrome(\"x\") == \"x\");\n     assert (make_palindrome(\"xyz\") == \"xyzyx\");\n     assert (make_palindrome(\"xyx\") == \"xyx\") ;\n     assert (make_palindrome(\"jerry\") == \"jerryrrej\");\n}\n\n\n", "result": "failed: a.out: test.cpp:46: int main(): Assertion `make_palindrome(\"x\") == \"x\"' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/14", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    if (str.empty()) {\n        return {};\n    }\n    \n    vector<string> prefixes;\n    \n    for (size_t i = 0; i < str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i + 1));\n    }\n    \n    return prefixes;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(all_prefixes(\"\"),{}));\n    assert (issame(all_prefixes(\"asdfgh\") ,{\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"}));\n     assert (issame(all_prefixes(\"WWW\") ,{\"W\", \"WW\", \"WWW\"}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/13", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Input validation\n    if (a == 0 && b == 0) {\n        return 0; // GCD is undefined for both zero\n    }\n\n    // Euclidean algorithm\n    while (b != 0) {\n        int temp = b;\n        b = a % b; // Remainder\n        a = temp;  // Update a\n    }\n\n    return abs(a); // Return the absolute value of GCD\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (greatest_common_divisor(3, 7) == 1);\n     assert (greatest_common_divisor(10, 15) == 5);\n      assert (greatest_common_divisor(49, 14) == 7);\n     assert (greatest_common_divisor(144, 60) == 12);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/15", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    if (n < 0) {\n        return \"\"; // Handle negative input\n    }\n    \n    string result = \"\";\n    for (int i = 0; i <= n; i++) {\n        result += to_string(i); // Convert number to string\n        if (i < n) {\n            result += \" \"; // Add space if not the last number\n        }\n    }\n    \n    return result; // Return the final string\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (string_sequence(0) == \"0\");\n    assert (string_sequence(3) == \"0 1 2 3\");\n     assert (string_sequence(10) == \"0 1 2 3 4 5 6 7 8 9 10\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/18", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    // Input Validation\n    if (substring.empty()) return 0;\n    if (str.empty()) return 0;\n\n    // Initialize Variables\n    int count = 0;\n    size_t position = 0;\n\n    // Search Loop\n    while ((position = str.find(substring, position)) != string::npos) {\n        count++; // Increment count for each found occurrence\n        position++; // Move to the next position for overlapping\n    }\n\n    // Return the Count\n    return count;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (how_many_times(\"\", \"x\") == 0);\n    assert (how_many_times(\"xyxyxyx\", \"x\") == 4);\n     assert (how_many_times(\"cacacacac\", \"cac\") == 4);\n    assert (how_many_times(\"john doe\", \"john\") == 1);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/16", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <set>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint count_distinct_characters(string str) { \n    // Normalize case\n    for (char &c : str) {\n        c = tolower(c); // Convert to lowercase\n    }\n    \n    // Use a set to track distinct characters\n    set<char> distinct_chars;\n    \n    // Insert characters into the set\n    for (char c : str) {\n        distinct_chars.insert(c); // Insert character into the set\n    }\n    \n    // Return the count of distinct characters\n    return distinct_chars.size(); // Size of the set is the count of distinct characters\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (count_distinct_characters(\"\") == 0);\n    assert (count_distinct_characters(\"abcde\") == 5);\n    assert (count_distinct_characters(\"abcdecadeCADE\") == 5);\n    assert (count_distinct_characters(\"aaaaAAAAaaaa\") == 1);\n    assert (count_distinct_characters(\"Jerry jERRY JeRRRY\") == 5);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/24", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    // Step 2: Input Validation\n    if (n <= 1) {\n        // Handle error case\n        return -1; // or print an error message\n    }\n\n    // Step 3: Iterate to find the largest divisor\n    for (int d = n - 1; d >= 1; d--) {\n        if (n % d == 0) {\n            return d; // Step 4: Return the largest divisor\n        }\n    }\n\n    // If no divisor found (should not happen for n > 1)\n    return -1; // or an appropriate value\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (largest_divisor(3) == 1);\n    assert (largest_divisor(7) == 1);\n    assert (largest_divisor(10) == 5);\n    assert (largest_divisor(100) == 50);\n    assert (largest_divisor(49) == 7);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/23", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint strlen(string str) {\n    int length = 0; // Initialize length counter\n\n    // Iterate through the string\n    for (char c : str) {\n        length++; // Increment length for each character\n    }\n\n    // Return the length\n    return length;\n}\n\n// Testing the function\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (strlen(\"\") == 0);\n    assert (strlen(\"x\") == 1);\n     assert (strlen(\"asdasnakj\") == 9);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/17", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    // Step 2: Input Validation\n    if (music_string.empty()) {\n        return {};\n    }\n\n    // Step 3: String Splitting\n    istringstream iss(music_string);\n    string note;\n    vector<int> beats;\n\n    // Step 4: Mapping Notes to Beats\n    unordered_map<string, int> note_to_beats = {\n        {\"o\", 4},\n        {\"o|\", 2},\n        {\".|\", 1}\n    };\n\n    // Step 5: Beat Calculation\n    while (iss >> note) {\n        if (note_to_beats.find(note) != note_to_beats.end()) {\n            beats.push_back(note_to_beats[note]);\n        }\n    }\n\n    // Step 6: Output Construction\n    return beats;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(parse_music(\"\") , {}));\n     assert (issame(parse_music(\"o o o o\") ,{4, 4, 4, 4}));\n      assert (issame(parse_music(\".| .| .| .|\") , {1, 1, 1, 1}));\n assert (issame(parse_music(\"o| o| .| .| o o o o\") , {2, 2, 1, 1, 4, 4, 4, 4}));\n  assert (issame(parse_music(\"o| .| o| .| o o| o o|\") , {2, 1, 2, 1, 4, 2, 4, 2}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/27", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <string>\n#include <cctype> // For toupper and tolower\n\nusing namespace std;\n\nstring flip_case(string str) {\n    string result; // Initialize an output string\n\n    // Iterate through each character\n    for (char c : str) {\n        // Check character case\n        if (islower(c)) {\n            result += toupper(c); // Flip to uppercase\n        } else if (isupper(c)) {\n            result += tolower(c); // Flip to lowercase\n        } else {\n            result += c; // Leave unchanged\n        }\n    }\n\n    // Return the result\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (flip_case(\"\") == \"\");\n    assert (flip_case(\"Hello!\") == \"hELLO!\");\n    assert (flip_case(\"These violent delights have violent ends\") == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/20", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm> // For std::sort\n#include <limits>    // For std::numeric_limits\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Input Validation\n    if (numbers.size() < 2) {\n        return {}; // or handle error\n    }\n\n    // Sorting\n    sort(numbers.begin(), numbers.end());\n\n    // Initialize Variables\n    float min_diff = numeric_limits<float>::max(); // Initialize to maximum float value\n    int closest_index1 = 0, closest_index2 = 1;\n\n    // Iterate Through the Sorted Vector\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_index1 = i;\n            closest_index2 = i + 1;\n        }\n    }\n\n    // Prepare the Result\n    vector<float> result = {numbers[closest_index1], numbers[closest_index2]};\n\n    // Return the Result\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(find_closest_elements({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}) , {3.9, 4.0}));\n    assert (issame(find_closest_elements({1.0, 2.0, 5.9, 4.0, 5.0}) , {5.0, 5.9} ));\n    assert (issame(find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2}) ,{2.0, 2.2}));\n     assert (issame(find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0}) ,{2.0, 2.0}));\n      assert (issame(find_closest_elements({1.1, 2.2, 3.1, 4.1, 5.1}) , {2.2, 3.1}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/21", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) { \n    // Step 1: Check input validity\n    if (numbers.size() < 2) {\n        return {}; // or handle error\n    }\n\n    // Step 2: Find min and max\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n    for (float num : numbers) {\n        if (num < min_val) min_val = num;\n        if (num > max_val) max_val = num;\n    }\n\n    // Step 3: Calculate range\n    float range = max_val - min_val;\n\n    // Step 4: Rescale the vector\n    vector<float> rescaled;\n    for (float num : numbers) {\n        if (range == 0) {\n            rescaled.push_back(0.0); // All elements are the same\n        } else {\n            rescaled.push_back((num - min_val) / range);\n        }\n    }\n\n    // Step 5: Return the rescaled vector\n    return rescaled;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(rescale_to_unit({2.0, 49.9}) , {0.0, 1.0}));\n     assert (issame(rescale_to_unit({100.0, 49.9}) ,{1.0, 0.0})); \n     assert (issame(rescale_to_unit({1.0, 2.0, 3.0, 4.0, 5.0}) , {0.0, 0.25, 0.5, 0.75, 1.0}));\n    assert (issame(rescale_to_unit({2.0, 1.0, 5.0, 3.0, 4.0}) , {0.25, 0.0, 1.0, 0.5, 0.75}));\n     assert (issame(rescale_to_unit({12.0, 11.0, 15.0, 13.0, 14.0}) ,{0.25, 0.0, 1.0, 0.5, 0.75}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/25", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n\n    // Input validation\n    if (n <= 1) {\n        return factors; // Return empty vector for invalid input\n    }\n\n    // Factorization logic\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // Check for odd factors from 3 to sqrt(n)\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // If n is still greater than 2, then n is prime\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors; // Return the vector of prime factors\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(factorize(2) , {2}));\n    assert (issame(factorize(4) , {2, 2}));\n    assert (issame(factorize(8) , {2, 2, 2}));\n     assert (issame(factorize(3 * 19) , {3, 19}));\n    assert (issame(factorize(3 * 19 * 3 * 19) , {3, 3, 19, 19})); \n    assert (issame(factorize(3 * 19 * 3 * 19 * 3 * 19) , {3, 3, 3, 19, 19, 19})); \n    assert (issame(factorize(3 * 19 * 19 * 19) , {3, 19, 19, 19})); \n    assert (issame(factorize(3 * 2 * 3) , {2, 3, 3}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/22", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result; // Initialize result vector\n\n    // Iterate over input list\n    for (const auto& value : values) {\n        try {\n            // Type Checking\n            int integer_value = boost::any_cast<int>(value); // Attempt to cast\n            result.push_back(integer_value); // If successful, add to result\n        } catch (const boost::bad_any_cast&) {\n            // If cast fails, do nothing and continue\n        }\n    }\n\n    // Return the result\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_integers({}),{}));\n\n    assert (issame(filter_integers({4,  {},23.2, 9, string(\"adasd\")}) ,{4, 9}));\n    assert (issame(filter_integers({3, 'c', 3, 3, 'a', 'b'}) ,{3, 3, 3}));\n}", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/26", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> count_map; // Step 1: Initialize count map\n    vector<int> result; // Step 1: Initialize result vector\n\n    // Step 2: Count occurrences\n    for (int num : numbers) {\n        count_map[num]++;\n    }\n\n    // Step 3: Filter unique elements\n    for (int num : numbers) {\n        if (count_map[num] == 1) { // Check if the element is unique\n            result.push_back(num); // Add to result\n        }\n    }\n\n    // Step 4: Return result\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(remove_duplicates({}) , {}));\n     assert (issame(remove_duplicates({1, 2, 3, 4}) , {1, 2, 3, 4}));\n      assert (issame(remove_duplicates({1, 2, 3, 2, 4, 3, 5}) , {1, 4, 5}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/19", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Define the mappings\n    map<string, int> numToInt = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, \n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, \n        {\"eight\", 8}, {\"nine\", 9}\n    };\n    \n    map<int, string> intToNum = {\n        {0, \"zero\"}, {1, \"one\"}, {2, \"two\"}, {3, \"three\"}, \n        {4, \"four\"}, {5, \"five\"}, {6, \"six\"}, {7, \"seven\"}, \n        {8, \"eight\"}, {9, \"nine\"}\n    };\n\n    // Input handling: trim leading/trailing spaces and split into words\n    stringstream ss(numbers);\n    string word;\n    vector<int> numValues;\n\n    while (ss >> word) {\n        if (numToInt.find(word) != numToInt.end()) {\n            numValues.push_back(numToInt[word]);\n        }\n    }\n\n    // Sort the integer values\n    sort(numValues.begin(), numValues.end());\n\n    // Convert back to string\n    vector<string> sortedWords;\n    for (int num : numValues) {\n        sortedWords.push_back(intToNum[num]);\n    }\n\n    // Join the sorted words into a single space-delimited string\n    string result;\n    for (size_t i = 0; i < sortedWords.size(); ++i) {\n        result += sortedWords[i];\n        if (i < sortedWords.size() - 1) {\n            result += \" \";\n        }\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sort_numbers(\"\") == \"\");\n    assert (sort_numbers(\"three\") == \"three\");\n    assert (sort_numbers(\"three five nine\") == \"three five nine\");\n     assert (sort_numbers(\"five zero four seven nine eight\") == \"zero four five seven eight nine\");\n      assert (sort_numbers(\"six five four three two one zero\") == \"zero one two three four five six\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/28", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result; // Initialize result string\n\n    // Iterate over the vector\n    for (const string& str : strings) {\n        result += str; // Append each string to result\n    }\n\n    // Return the concatenated result\n    return result;\n}\n\n// Testing the function\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (concatenate({}) == \"\");\n     assert (concatenate({\"x\", \"y\", \"z\"}) == \"xyz\");\n    assert (concatenate({\"x\", \"y\", \"z\", \"w\", \"k\"}) == \"xyzwk\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/29", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> result; // Initialize output vector\n\n    // Iterate over input vector\n    for (const string& str : strings) {\n        // Check if the string starts with the prefix\n        if (str.substr(0, prefix.size()) == prefix) {\n            // Store matches\n            result.push_back(str);\n        }\n    }\n\n    // Return result\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_by_prefix({}, \"john\") , {}));\n    assert (issame(filter_by_prefix({\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\") , {\"xxx\", \"xxxAAA\", \"xxx\"}));\n\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/30", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positive_numbers; // Initialize output vector\n\n    // Iterate through input vector\n    for (float num : l) {\n        // Check if the number is positive\n        if (num > 0) {\n            positive_numbers.push_back(num); // Add to output vector\n        }\n    }\n\n    // Return the output vector\n    return positive_numbers;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(get_positive({-1, -2, 4, 5, 6}) , {4, 5, 6} ));\n    assert (issame(get_positive({5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}) , {5, 3, 2, 3, 3, 9, 123, 1}));\n     assert (issame(get_positive({-1, -2}) , {} ));\n     assert (issame(get_positive({}) , {}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/31", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Input Validation\n    if (n <= 1) return false; // Not prime\n    if (n == 2) return true;  // 2 is prime\n    if (n % 2 == 0) return false; // Even numbers greater than 2 are not prime\n\n    // Check for divisibility\n    for (long long i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) {\n            return false; // Found a divisor\n        }\n    }\n    \n    // Return true if no divisors found\n    return true;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_prime(6) == false);\n    assert (is_prime(101) == true);\n    assert (is_prime(11) == true);\n    assert (is_prime(13441) == true);\n    assert (is_prime(61) == true);\n    assert (is_prime(4) == false);\n    assert (is_prime(1) == false);\n    assert (is_prime(5) == true);\n    assert (is_prime(11) == true);\n    assert (is_prime(17) == true);\n    assert (is_prime(5 * 17) == false);\n    assert (is_prime(11 * 7) == false);\n    assert (is_prime(13441 * 19) == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/32", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <stdexcept>\n\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    /* \n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n \n    */\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    /*\n    xs are coefficients of a polynomial. find_zero find x such that poly(x) = 0. find_zero returns only one zero point, even if there are many. \n    Moreover, find_zero only takes list xs having even number of coefficients and largest non zero coefficient as it guarantees a solution.\n    */\n    if (xs.size() % 2 != 0) {\n        throw invalid_argument(\"The number of coefficients must be even.\");\n    }\n\n    double lower_bound = -1000; // Arbitrary lower bound\n    double upper_bound = 1000;  // Arbitrary upper bound\n    double mid;\n\n    while (upper_bound - lower_bound > 1e-7) { // Precision threshold\n        mid = (lower_bound + upper_bound) / 2.0;\n        if (poly(xs, mid) == 0) {\n            return mid; // Found exact zero\n        } else if (poly(xs, mid) * poly(xs, lower_bound) < 0) {\n            upper_bound = mid; // Zero is in the left half\n        } else {\n            lower_bound = mid; // Zero is in the right half\n        }\n    }\n    return mid; // Return the approximate zero\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n   \n    double solution;\n    int ncoeff;\n    for (int i=0;i<100;i++)\n    {\n        ncoeff = 2 * (1+rand()%4);\n        vector<double> coeffs = {};\n        for (int j=0;j<ncoeff;j++)\n        {\n            double coeff = -10+rand()%21;\n            if (coeff == 0) coeff = 1;\n            coeffs.push_back(coeff);\n        }\n        \n        solution = find_zero(coeffs);\n        assert (abs(poly(coeffs, solution))< 1e-3);\n    }\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/34", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Step 1: Use a set to remove duplicates\n    set<int> uniqueSet(l.begin(), l.end());\n    \n    // Step 2: Convert the set back to a vector\n    vector<int> uniqueVector(uniqueSet.begin(), uniqueSet.end());\n    \n    // Step 3: Return the result\n    return uniqueVector;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(unique({5, 3, 5, 2, 3, 3, 9, 0, 123}) , {0, 2, 3, 5, 9, 123}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/35", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    // Step 1: Input Validation\n    if (l.empty()) {\n        return NAN; // Return NAN for empty vector\n    }\n\n    // Step 2: Initialize Maximum Value\n    float maxValue = l[0];\n\n    // Step 3: Iterate Through the Vector\n    for (size_t i = 1; i < l.size(); i++) {\n        if (l[i] > maxValue) {\n            maxValue = l[i]; // Update maxValue\n        }\n    }\n\n    // Step 4: Return the Result\n    return maxValue;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(max_element({1, 2, 3})- 3)<1e-4);\n    assert (abs(max_element({5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10})- 124)<1e-4);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/33", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> valuesAtDivisibleByThree;\n\n    // Extract values at indices divisible by three\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            valuesAtDivisibleByThree.push_back(l[i]);\n        }\n    }\n\n    // Sort the extracted values\n    sort(valuesAtDivisibleByThree.begin(), valuesAtDivisibleByThree.end());\n\n    // Rebuild the output vector\n    vector<int> result = l; // Copy original vector\n    int sortedIndex = 0;\n    for (int i = 0; i < result.size(); i++) {\n        if (i % 3 == 0) {\n            result[i] = valuesAtDivisibleByThree[sortedIndex++];\n        }\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_third({1, 2, 3}) , sort_third({1, 2, 3})));\n    assert (issame(sort_third({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}) , sort_third({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})));\n    assert (issame(sort_third({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}) , sort_third({5, 8, -12, 4, 23, 2, 3, 11, 12, -10})));\n    assert (issame(sort_third({5, 6, 3, 4, 8, 9, 2}) , {2, 6, 3, 4, 8, 9, 5}));\n    assert (issame(sort_third({5, 8, 3, 4, 6, 9, 2}) , {2, 8, 3, 4, 6, 9, 5}));\n    assert (issame(sort_third({5, 6, 9, 4, 8, 3, 2}) , {2, 6, 9, 4, 8, 3, 5}));\n    assert (issame(sort_third({5, 6, 3, 4, 8, 9, 2, 1}) , {2, 6, 3, 4, 8, 9, 5, 1}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/38", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l = s.length();\n    string output;\n    for (int i = 0; i < l; i += 3) {\n        string x = s.substr(i, 3);\n        if (x.length() == 3) {\n            x = x.substr(1) + x[0]; // Cycle left\n        }\n        output += x; // Append modified group to output\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string. \n    */\n    int l = s.length();\n    string output;\n    for (int i = 0; i < l; i += 3) {\n        string x = s.substr(i, 3);\n        if (x.length() == 3) {\n            x = x[x.length() - 1] + x.substr(0, 2); // Reverse cycle\n        }\n        output += x; // Append modified group to output\n    }\n    return output;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    \n    for (int i=0;i<100;i++)\n    {\n        int l=10+rand()%11;\n        string str=\"\";\n        for (int j=0;j<l;j++)\n        {\n            char chr=97+rand()%26;\n            str+=chr;\n        }\n\n        string encoded_str = encode_cyclic(str);\n        assert (decode_cyclic(encoded_str) == str);\n    }\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/36", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint count_sevens(int number) {\n    int count = 0;\n    string num_str = to_string(number);\n    for (char c : num_str) {\n        if (c == '7') {\n            count++;\n        }\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int total_count = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            total_count += count_sevens(i);\n        }\n    }\n    return total_count;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fizz_buzz(50) == 0);\n    assert (fizz_buzz(78) == 2);\n    assert (fizz_buzz(79) == 3);\n    assert (fizz_buzz(100) == 3);\n    assert (fizz_buzz(200) == 6);\n    assert (fizz_buzz(4000) == 192);\n    assert (fizz_buzz(10000) == 639);\n    assert (fizz_buzz(100000) == 8026);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/39", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num < 2) return false;\n    for (int i = 2; i <= sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> fibonacci_generator() {\n    vector<int> fibs;\n    int a = 0, b = 1;\n    while (true) {\n        fibs.push_back(b);\n        int next = a + b;\n        a = b;\n        b = next;\n        if (fibs.size() > 100) break; // Limit to avoid infinite loop in this example\n    }\n    return fibs;\n}\n\nint prime_fib(int n) {\n    vector<int> fibs = fibonacci_generator();\n    int count = 0;\n\n    for (int fib : fibs) {\n        if (is_prime(fib)) {\n            count++;\n            if (count == n) {\n                return fib;\n            }\n        }\n    }\n    return -1; // In case n is out of bounds\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (prime_fib(1) == 2);\n    assert (prime_fib(2) == 3);\n    assert (prime_fib(3) == 5);\n    assert (prime_fib(4) == 13);\n    assert (prime_fib(5) == 89);\n    assert (prime_fib(6) == 233);\n    assert (prime_fib(7) == 1597);\n    assert (prime_fib(8) == 28657);\n    assert (prime_fib(9) == 514229);\n    assert (prime_fib(10) == 433494437);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/37", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> even_values; // Initialize even values vector\n    vector<float> result(l.size()); // Initialize result vector\n\n    // Loop through input vector\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) { // Even index\n            even_values.push_back(l[i]); // Store even indexed value\n        } else { // Odd index\n            result[i] = l[i]; // Copy odd indexed value\n        }\n    }\n\n    // Sort the even indexed values\n    sort(even_values.begin(), even_values.end());\n\n    // Reinsert sorted values into result vector\n    for (int i = 0, j = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            result[i] = even_values[j++]; // Replace with sorted value\n        }\n    }\n\n    // Return the result vector\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_even({1, 2, 3}), {1, 2, 3}));\n    assert (issame(sort_even({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}) , {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123}));\n    assert (issame(sort_even({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}) , {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/41", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Input validation (optional)\n    if (n < 0) {\n        return 0; // or handle error\n    }\n    \n    // Calculate total collisions\n    return n * n; // Each car from left collides with each car from right\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (car_race_collision(2) == 4);\n    assert (car_race_collision(3) == 9);\n    assert (car_race_collision(4) == 16);\n    assert (car_race_collision(8) == 64);\n    assert (car_race_collision(10) == 100);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/42", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_vector(vector<int> l) {\n    // Step 2: Input Validation\n    if (l.empty()) {\n        return {}; // Return an empty vector if input is empty\n    }\n\n    // Step 3: Create Output Vector\n    vector<int> incremented_vector;\n\n    // Step 4: Iterate and Increment\n    for (int i = 0; i < l.size(); i++) {\n        incremented_vector.push_back(l[i] + 1); // Increment and add to output vector\n    }\n\n    // Step 5: Return Output\n    return incremented_vector;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(incr_list({}) , {}));\n    assert (issame(incr_list({3, 2, 1}) , {4, 3, 2}));\n    assert (issame(incr_list({5, 2, 5, 2, 3, 3, 9, 0, 123}) , {6, 3, 6, 3, 4, 4, 10, 1, 124}));\n}\n", "result": "failed: compilation error: In file included from test.cpp:39:\ntest.cpp: In function \u2018int main()\u2019:\ntest.cpp:49:20: error: \u2018incr_list\u2019 was not declared in this scope\n   49 |     assert (issame(incr_list({}) , {}));\n      |                    ^~~~~~~~~\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/40", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Step 2: Input Validation\n    if (l.size() < 3) return false;\n\n    // Step 3: Sort the Vector\n    sort(l.begin(), l.end());\n\n    // Step 4: Iterate Through the Vector\n    for (int i = 0; i < l.size() - 2; i++) {\n        // Skip duplicates\n        if (i > 0 && l[i] == l[i - 1]) continue;\n\n        // Step 5: Two-Pointer Technique\n        int left = i + 1;\n        int right = l.size() - 1;\n\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true; // Triplet found\n            } else if (sum < 0) {\n                left++; // Increase sum\n            } else {\n                right--; // Decrease sum\n            }\n        }\n    }\n\n    // Step 6: Return False\n    return false;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (triples_sum_to_zero({1, 3, 5, 0}) == false);\n    assert (triples_sum_to_zero({1, 3, 5, -1}) == false);\n    assert (triples_sum_to_zero({1, 3, -2, 1}) == true);\n    assert (triples_sum_to_zero({1, 2, 3, 7}) == false);\n    assert (triples_sum_to_zero({1, 2, 5, 7}) == false);\n    assert (triples_sum_to_zero({2, 4, -5, 3, 9, 7}) == true);\n    assert (triples_sum_to_zero({1}) == false);\n    assert (triples_sum_to_zero({1, 3, 5, -100}) == false);\n    assert (triples_sum_to_zero({100, 3, 5, -100}) == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/44", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    // Step 2: Input Validation\n    if (x < 0) {\n        return \"Error: Negative input not allowed.\";\n    }\n    if (base < 2 || base >= 10) {\n        return \"Error: Base must be between 2 and 9.\";\n    }\n\n    // Step 3: Initialize Result String\n    string result = \"\";\n\n    // Step 4: Conversion Logic\n    if (x == 0) {\n        return \"0\"; // Handle edge case for zero\n    }\n    \n    while (x > 0) {\n        int remainder = x % base; // Get remainder\n        result = to_string(remainder) + result; // Prepend to result\n        x = x / base; // Update x\n    }\n\n    // Step 6: Return the Result\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (change_base(8, 3) == \"22\");\n    assert (change_base(9, 3) == \"100\");\n    assert (change_base(234, 2) == \"11101010\");\n    assert (change_base(16, 2) == \"10000\");\n    assert (change_base(8, 2) == \"1000\");\n    assert (change_base(7, 2) == \"111\");\n    for (int x=2;x<8;x++)\n        assert (change_base(x, x + 1) == to_string(x));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/45", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h; // Area calculation\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(triangle_area(5, 3) - 7.5)<1e-4);\n    assert (abs(triangle_area(2, 2) - 2.0)<1e-4);\n    assert (abs(triangle_area(10, 8) - 40.0)<1e-4);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/43", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\n#include <unordered_set> // Include for using unordered_set\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    // Step 2: Input Validation\n    if (l.size() < 2) return false;\n\n    // Step 3: Initialize Data Structure\n    unordered_set<int> seen;\n\n    // Step 4: Loop Through Each Element\n    for (int num : l) {\n        // Calculate negation\n        int neg_num = -num;\n\n        // Step 4.1: Check for Pairs\n        if (seen.find(neg_num) != seen.end()) {\n            return true; // Found a pair\n        }\n\n        // Step 4.2: Add current number to the set\n        seen.insert(num);\n    }\n\n    // Step 5: Final Check\n    return false; // No pairs found\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (pairs_sum_to_zero({1, 3, 5, 0}) == false);\n    assert (pairs_sum_to_zero({1, 3, -2, 1}) == false);\n    assert (pairs_sum_to_zero({1, 2, 3, 7}) == false);\n    assert (pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) == true);\n    assert (pairs_sum_to_zero({1}) == false);\n    assert (pairs_sum_to_zero({-3, 9, -1, 3, 2, 30}) == true);\n    assert (pairs_sum_to_zero({-3, 9, -1, 3, 2, 31}) == true);\n    assert (pairs_sum_to_zero({-3, 9, -1, 4, 2, 30}) == false);\n    assert (pairs_sum_to_zero({-3, 9, -1, 4, 2, 31}) == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/46", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    // Step 2: Input validation\n    if (n < 0) return -1; // or handle error appropriately\n\n    // Step 3: Base cases handling\n    int fib4[100]; // Assuming n will not exceed 99 for simplicity\n    fib4[0] = 0;\n    fib4[1] = 0;\n    fib4[2] = 2;\n    fib4[3] = 0;\n\n    // Step 4: Iterative calculation\n    for (int i = 4; i <= n; i++) {\n        fib4[i] = fib4[i-1] + fib4[i-2] + fib4[i-3] + fib4[i-4];\n    }\n\n    // Step 5: Return the result\n    return fib4[n];\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fib4(5) == 4);\n    assert (fib4(8) == 28);\n    assert (fib4(10) == 104);\n    assert (fib4(12) == 386);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/48", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    // Step 2: Input Validation\n    if (text.empty()) {\n        return true; // An empty string is a palindrome\n    }\n\n    // Step 3: Initialize Pointers\n    int left = 0;\n    int right = text.length() - 1;\n\n    // Step 4: Character Comparison Loop\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Mismatch found\n        }\n        left++;\n        right--;\n    }\n\n    // Step 5: Completion Check\n    return true; // No mismatches found, it's a palindrome\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_palindrome(\"\") == true);\n    assert (is_palindrome(\"aba\") == true);\n    assert (is_palindrome(\"aaaaa\") == true);\n    assert (is_palindrome(\"zbcd\") == false);\n    assert (is_palindrome(\"xywyx\") == true);\n    assert (is_palindrome(\"xywyz\") == false);\n    assert (is_palindrome(\"xywzx\") == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/47", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Step 2: Input Validation\n    if (l.empty()) {\n        // Handle empty vector case (e.g., return 0 or throw an error)\n        return 0; // or throw an exception\n    }\n\n    // Step 3: Sorting the Vector\n    sort(l.begin(), l.end());\n\n    // Step 4: Calculate the Median\n    int n = l.size();\n    if (n % 2 == 1) {\n        // Odd number of elements\n        return l[n / 2];\n    } else {\n        // Even number of elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    }\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(median({3, 1, 2, 4, 5}) - 3)<1e-4);\n    assert (abs(median({-10, 4, 6, 1000, 10, 20}) -8.0)<1e-4);\n    assert (abs(median({5}) - 5)<1e-4);\n    assert (abs(median({6, 5}) - 5.5)<1e-4);\n    assert (abs(median({8, 1, 3, 9, 9, 2, 7}) - 7)<1e-4 );\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/49", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    // Handle edge cases\n    if (n < 0) return 1; // Assuming 2^n for negative n returns 1\n    if (p <= 1) return 1; // Any number mod 1 is 0, but we return 1 for n = 0\n\n    long long result = 1; // Use long long to avoid overflow\n    long long base = 2;   // Base is 2\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd\n            result = (result * base) % p; // Multiply result by base and take mod p\n        }\n        base = (base * base) % p; // Square the base and take mod p\n        n /= 2; // Divide n by 2\n    }\n\n    return result; // Return the final result\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (modp(3, 5) == 3);\n    assert (modp(1101, 101) == 2);\n    assert (modp(0, 101) == 1);\n    assert (modp(3, 11) == 8);\n    assert (modp(100, 101) == 1);\n    assert (modp(30, 5) == 4);\n    assert (modp(31, 5) == 3);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/50", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            char shifted = (c - 'a' + 5) % 26 + 'a';\n            out += shifted;\n        } else {\n            out += c; // Non-alphabetic characters remain unchanged\n        }\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            char shifted = (c - 'a' - 5 + 26) % 26 + 'a'; // Adding 26 to handle negative values\n            out += shifted;\n        } else {\n            out += c; // Non-alphabetic characters remain unchanged\n        }\n    }\n    return out;\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    \n    for (int i=0;i<100;i++)\n    {\n        int l=10+rand()%11;\n        string str=\"\";\n        for (int j=0;j<l;j++)\n        {\n            char chr=97+rand()%26;\n            str+=chr;\n        }\n\n        string encoded_str = encode_shift(str);\n        assert (decode_shift(encoded_str) == str);\n    }\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/52", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    // Step 2: Input Validation\n    if (l.empty()) {\n        return true; // No elements to check\n    }\n\n    // Step 3: Iterate Through the Vector\n    for (int num : l) {\n        // Step 4: Condition Checking\n        if (num >= t) {\n            return false; // Found an element not below the threshold\n        }\n    }\n\n    // Step 5: Return Result\n    return true; // All elements are below the threshold\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (below_threshold({1, 2, 4, 10}, 100));\n    assert (not(below_threshold({1, 20, 4, 10}, 5)));\n    assert (below_threshold({1, 20, 4, 10}, 21));\n    assert (below_threshold({1, 20, 4, 10}, 22));\n    assert (below_threshold({1, 8, 4, 10}, 11));\n    assert (not(below_threshold({1, 8, 4, 10}, 10)));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/53", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\nusing namespace std;\n\n// Function to add two integers\nint add(int x, int y) {\n    return x + y; // Addition logic\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (add(0, 1) == 1);\n    assert (add(1, 0) == 1);\n    assert (add(2, 3) == 5);\n    assert (add(5, 7) == 12);\n    assert (add(7, 5) == 12);\n    for (int i=0;i<100;i+=1)\n    {\n        int x=rand()%1000;\n        int y=rand()%1000;\n        assert (add(x, y) == x + y);\n    }\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/51", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    // Define the set of vowels\n    string vowels = \"aeiouAEIOU\";\n    \n    // Initialize the result string\n    string result = \"\";\n    \n    // Loop through each character in the input string\n    for (char c : text) {\n        // Check if the character is not a vowel\n        if (vowels.find(c) == string::npos) {\n            // Append non-vowel characters to the result\n            result += c;\n        }\n    }\n    \n    // Return the result string\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (remove_vowels(\"\") == \"\");\n    assert (remove_vowels(\"abcdef\\nghijklm\") == \"bcdf\\nghjklm\");\n    assert (remove_vowels(\"fedcba\") == \"fdcb\");\n    assert (remove_vowels(\"eeeee\") == \"\");\n    assert (remove_vowels(\"acBAA\") == \"cB\");\n    assert (remove_vowels(\"EcBOO\") == \"cB\");\n    assert (remove_vowels(\"ybcd\") == \"ybcd\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/55", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\nusing namespace std;\n\nint fib(int n) {\n    // Input validation\n    if (n < 0) {\n        throw invalid_argument(\"Input must be a non-negative integer.\");\n    }\n\n    // Base case handling\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n\n    // Iterative calculation for better performance\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; ++i) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fib(10) == 55);\n    assert (fib(1) == 1);\n    assert (fib(8) == 21);\n    assert (fib(11) == 89);\n    assert (fib(12) == 144);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/56", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // Initialize counter\n\n    // Iterate through the string\n    for (char ch : brackets) {\n        if (ch == '<') {\n            balance++; // Increment for opening bracket\n        } else if (ch == '>') {\n            balance--; // Decrement for closing bracket\n        }\n\n        // Check for negative balance\n        if (balance < 0) {\n            return false; // Unmatched closing bracket\n        }\n    }\n\n    // Final balance check\n    return balance == 0; // Return true if balanced\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (correct_bracketing(\"<>\"));\n    assert (correct_bracketing(\"<<><>>\"));\n    assert (correct_bracketing(\"<><><<><>><>\"));\n    assert (correct_bracketing(\"<><><<<><><>><>><<><><<>>>\"));\n    assert (not (correct_bracketing(\"<<<><>>>>\")));\n    assert (not (correct_bracketing(\"><<>\")));\n    assert (not (correct_bracketing(\"<\")));\n    assert (not (correct_bracketing(\"<<<<\")));\n    assert (not (correct_bracketing(\">\")));\n    assert (not (correct_bracketing(\"<<>\")));\n    assert (not (correct_bracketing(\"<><><<><>><>><<>\")));\n    assert (not (correct_bracketing(\"<><><<><>><>>><>\")));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/54", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <string>\n#include <set>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Step 1: Create sets for unique characters\n    set<char> chars1;\n    set<char> chars2;\n\n    // Step 2: Populate the first set with unique characters from s0\n    for (char c : s0) {\n        chars1.insert(c);\n    }\n\n    // Step 3: Populate the second set with unique characters from s1\n    for (char c : s1) {\n        chars2.insert(c);\n    }\n\n    // Step 4: Compare the two sets\n    return chars1 == chars2;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert (same_chars(\"abcd\", \"dddddddabc\") == true);\n    assert (same_chars(\"dddddddabc\", \"abcd\") == true);\n    assert (same_chars(\"eabcd\", \"dddddddabc\") == false);\n    assert (same_chars(\"abcd\", \"dddddddabcf\") == false);\n    assert (same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert (same_chars(\"aabb\", \"aaccc\") == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/57", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    // Edge case: empty or single element vector\n    if (l.size() <= 1) return true;\n\n    bool isIncreasing = true;\n    bool isDecreasing = true;\n\n    for (size_t i = 0; i < l.size() - 1; ++i) {\n        if (l[i] > l[i + 1]) {\n            isIncreasing = false;\n        }\n        if (l[i] < l[i + 1]) {\n            isDecreasing = false;\n        }\n    }\n\n    return isIncreasing || isDecreasing;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (monotonic({1, 2, 4, 10}) == true);\n    assert (monotonic({1, 2, 4, 20}) == true);\n    assert (monotonic({1, 20, 4, 10}) == false);\n    assert (monotonic({4, 1, 0, -10}) == true);\n    assert (monotonic({4, 1, 1, 0}) == true);\n    assert (monotonic({1, 2, 3, 2, 5, 60}) == false);\n    assert (monotonic({1, 2, 3, 4, 5, 60}) == true);\n    assert (monotonic({9, 9, 9, 9}) == true);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/59", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int largest_factor = 0;\n\n    // Check for factor 2\n    while (n % 2 == 0) {\n        largest_factor = 2;\n        n /= 2;\n    }\n\n    // Check for odd factors from 3 to sqrt(n)\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest_factor = i;\n            n /= i;\n        }\n    }\n\n    // If n is still greater than 2, then n itself is prime\n    if (n > 2) {\n        largest_factor = n;\n    }\n\n    return largest_factor;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (largest_prime_factor(15) == 5);\n    assert (largest_prime_factor(27) == 3);\n    assert (largest_prime_factor(63) == 7);\n    assert (largest_prime_factor(330) == 11);\n    assert (largest_prime_factor(13195) == 29);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/60", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    // Input validation\n    if (n < 0) {\n        // Handle error for negative input\n        return 0; // or some error code\n    }\n    \n    // Summation logic (using formula)\n    int sum = n * (n + 1) / 2;\n    \n    // Return the result\n    return sum;\n}\n\n// Main function for testing\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sum_to_n(1) == 1);\n    assert (sum_to_n(6) == 21);\n    assert (sum_to_n(11) == 66);\n    assert (sum_to_n(30) == 465);\n    assert (sum_to_n(100) == 5050);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/61", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // Step 2: Initialization\n\n    // Step 3: Loop through the string\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++; // Increment for opening bracket\n        } else if (ch == ')') {\n            if (balance == 0) {\n                return false; // Invalid case: more closing than opening\n            }\n            balance--; // Decrement for closing bracket\n        }\n    }\n\n    // Step 4: Final Check\n    return balance == 0; // Return true if balanced\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (correct_bracketing(\"()\"));\n    assert (correct_bracketing(\"(()())\"));\n    assert (correct_bracketing(\"()()(()())()\"));\n    assert (correct_bracketing(\"()()((()()())())(()()(()))\"));\n    assert (not (correct_bracketing(\"((()())))\")));\n    assert (not (correct_bracketing(\")(()\")));\n    assert (not (correct_bracketing(\"(\")));\n    assert (not (correct_bracketing(\"((((\")));\n    assert (not (correct_bracketing(\")\")));\n    assert (not (correct_bracketing(\"(()\")));\n    assert (not (correct_bracketing(\"()()(()())())(()\")));\n    assert (not (correct_bracketing(\"()()(()())()))()\")));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/58", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    set<int> set1(l1.begin(), l1.end());\n    set<int> commonSet;\n\n    for (int num : l2) {\n        if (set1.find(num) != set1.end()) {\n            commonSet.insert(num);\n        }\n    }\n\n    vector<int> result(commonSet.begin(), commonSet.end());\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121}) , {1, 5, 653}));\n    assert (issame(common({5, 3, 2, 8}, {3, 2}) , {2, 3}));\n    assert (issame(common({4, 3, 2, 8}, {3, 2, 4}) , {2, 3, 4}));\n    assert (issame(common({4, 3, 2, 8}, {}) , {}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/62", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    // Step 2: Input Validation\n    if (xs.empty()) {\n        return {}; // Return empty vector for empty input\n    }\n\n    // Step 3: Initialize Output Vector\n    vector<float> result;\n\n    // Step 4: Iterate Over Coefficients\n    for (size_t i = 1; i < xs.size(); ++i) {\n        // Calculate the derivative coefficient\n        result.push_back(i * xs[i]);\n    }\n\n    // Step 5: Return the Result\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<float> a,vector<float>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (abs(a[i]-b[i])>1e-4) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(derivative({3, 1, 2, 4, 5}) , {1, 4, 12, 20}));\n    assert (issame(derivative({1, 2, 3}) , {2, 6}));\n    assert (issame(derivative({3, 2, 1}) , {2, 2}));\n    assert (issame(derivative({3, 2, 1, 0, 4}) , {2, 2, 0, 16}));\n    assert (issame(derivative({1}) , {}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/63", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint fibfib(int n) {\n    // Handle edge cases\n    if (n < 0) return -1; // Return -1 for negative inputs\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Use an array to store computed values for optimization\n    vector<int> fibfib_values(n + 1);\n    fibfib_values[0] = 0;\n    fibfib_values[1] = 0;\n    fibfib_values[2] = 1;\n\n    // Compute the fibfib sequence iteratively\n    for (int i = 3; i <= n; ++i) {\n        fibfib_values[i] = fibfib_values[i - 1] + fibfib_values[i - 2] + fibfib_values[i - 3];\n    }\n\n    return fibfib_values[n];\n}\n\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fibfib(2) == 1);\n    assert (fibfib(1) == 0);\n    assert (fibfib(5) == 4);\n    assert (fibfib(8) == 24);\n    assert (fibfib(10) == 81);\n    assert (fibfib(12) == 274);\n    assert (fibfib(14) == 927);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/65", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <string>\n#include <algorithm> // for std::reverse\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string str = to_string(x);\n    int num_digits = str.length();\n\n    if (shift > num_digits) {\n        reverse(str.begin(), str.end());\n        return str;\n    }\n\n    // Calculate effective shift\n    shift = shift % num_digits;\n\n    // Perform circular shift\n    string result = str.substr(num_digits - shift) + str.substr(0, num_digits - shift);\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (circular_shift(100, 2) == \"001\");\n    assert (circular_shift(12, 2) == \"12\");\n    assert (circular_shift(97, 8) == \"79\");\n    assert (circular_shift(12, 1) == \"21\");\n    assert (circular_shift(11, 101) == \"11\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/64", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0; // Initialize counter\n\n    // Iterate through each character in the string\n    for (size_t i = 0; i < s.length(); i++) {\n        char c = tolower(s[i]); // Convert to lowercase for uniformity\n\n        // Check for vowels\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++; // Increment count for standard vowels\n        } else if (c == 'y' && i == s.length() - 1) {\n            count++; // Increment count if 'y' is at the end\n        }\n    }\n\n    // Return the total count of vowels\n    return count;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (vowels_count(\"abcde\") == 2);\n    assert (vowels_count(\"Alone\") == 3);\n    assert (vowels_count(\"key\") == 2);\n    assert (vowels_count(\"bye\") == 1);\n    assert (vowels_count(\"keY\") == 2);\n    assert (vowels_count(\"bYe\") == 1);\n    assert (vowels_count(\"ACEDY\") == 3);\n   \n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/66", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0; // Initialize sum\n\n    // Iterate through the string\n    for (char c : s) {\n        // Check if the character is uppercase\n        if (c >= 'A' && c <= 'Z') {\n            // Calculate ASCII value and add to sum\n            sum += static_cast<int>(c);\n        }\n    }\n\n    // Return the sum\n    return sum;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (digitSum(\"\") == 0);\n    assert (digitSum(\"abAB\") == 131);\n    assert (digitSum(\"abcCd\") == 67);\n    assert (digitSum(\"helloE\") == 69);\n    assert (digitSum(\"woArBld\") == 131);\n    assert (digitSum(\"aAaaaXa\") == 153);\n    assert (digitSum(\" How are yOu?\") == 151);\n    assert (digitSum(\"You arE Very Smart\") == 327);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/68", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <limits.h> // for INT_MAX\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    // Check for empty input\n    if (arr.empty()) {\n        return {};\n    }\n\n    // Initialize variables\n    int smallest_even = INT_MAX;\n    int index_of_smallest_even = -1;\n\n    // Iterate through the vector\n    for (int i = 0; i < arr.size(); i++) {\n        // Check if the number is even\n        if (arr[i] % 2 == 0) {\n            // Update smallest even value and index\n            if (arr[i] < smallest_even) {\n                smallest_even = arr[i];\n                index_of_smallest_even = i;\n            }\n        }\n    }\n\n    // Check and return result\n    if (index_of_smallest_even == -1) {\n        return {};\n    } else {\n        return {smallest_even, index_of_smallest_even};\n    }\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(pluck({4,2,3}) , {2, 1}));\n    assert (issame(pluck({1,2,3}) , {2, 1}));\n    assert (issame(pluck({}) , {}));\n    assert (issame(pluck({5, 0, 3, 0, 4, 2}) , {0, 1}));\n    assert (issame(pluck({1, 2, 3, 0, 5, 3}) , {0, 3}));\n    assert (issame(pluck({5, 4, 8, 4 ,8}) , {4, 1}));\n    assert (issame(pluck({7, 6, 7, 1}) , {6, 1}));\n    assert (issame(pluck({7, 9, 7, 1}) , {}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/67", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <iostream>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0, oranges = 0;\n\n    // Step 3: Parse the input string\n    size_t apple_pos = s.find(\"apples\");\n    size_t orange_pos = s.find(\"oranges\");\n\n    // Step 4: Extract and convert the numbers\n    if (apple_pos != string::npos) {\n        stringstream ss(s.substr(0, apple_pos));\n        ss >> apples; // Extract number of apples\n    }\n    \n    if (orange_pos != string::npos) {\n        stringstream ss(s.substr(apple_pos + 7, orange_pos - (apple_pos + 7)));\n        ss >> oranges; // Extract number of oranges\n    }\n\n    // Step 5: Calculate the number of mangoes\n    int mango_count = n - (apples + oranges);\n\n    // Step 6: Return the result\n    return mango_count;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fruit_distribution(\"5 apples and 6 oranges\",19) == 8);\n    assert (fruit_distribution(\"5 apples and 6 oranges\",21) == 10);\n    assert (fruit_distribution(\"0 apples and 1 oranges\",3) == 2);\n    assert (fruit_distribution(\"1 apples and 0 oranges\",3) == 2);\n    assert (fruit_distribution(\"2 apples and 3 oranges\",100) == 95);\n    assert (fruit_distribution(\"2 apples and 3 oranges\",5) == 0);\n    assert (fruit_distribution(\"1 apples and 100 oranges\",120) == 19);\n}\n", "result": "failed: a.out: test.cpp:50: int main(): Assertion `fruit_distribution(\"5 apples and 6 oranges\",19) == 8' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/71", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the triangle is valid\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1; // Invalid triangle\n    }\n\n    // Calculate semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the area to 2 decimal points\n    return round(area * 100) / 100; // Rounding to 2 decimal points\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(triangle_area(3, 4, 5)-6.00)<0.01);\n    assert (abs(triangle_area(1, 2, 10) +1)<0.01);\n    assert (abs(triangle_area(4, 8, 5) -8.18)<0.01);\n    assert (abs(triangle_area(2, 2, 2) -1.73)<0.01);\n    assert (abs(triangle_area(1, 2, 3) +1)<0.01);\n    assert (abs(triangle_area(10, 5, 7) - 16.25)<0.01);\n    assert (abs(triangle_area(2, 6, 3) +1)<0.01);\n    assert (abs(triangle_area(1, 1, 1) -0.43)<0.01);\n    assert (abs(triangle_area(2, 2, 10) +1)<0.01);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/69", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequencyMap;\n\n    // Count frequencies\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    // Find the greatest integer that meets the criteria\n    int greatest = -1;\n    for (const auto& pair : frequencyMap) {\n        int value = pair.first;\n        int frequency = pair.second;\n        if (frequency >= value) {\n            greatest = max(greatest, value);\n        }\n    }\n\n    return greatest;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (search({5, 5, 5, 5, 1}) == 1);\n    assert (search({4, 1, 4, 1, 4, 4}) == 4);\n    assert (search({3, 3}) == -1);\n    assert (search({8, 8, 8, 8, 8, 8, 8, 8}) == 8);\n    assert (search({2, 3, 3, 2, 2}) == 2);\n    assert (search({2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}) == 1);\n    assert (search({3, 2, 8, 2}) == 2);\n    assert (search({6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}) == 1);\n    assert (search({8, 8, 3, 6, 5, 6, 4}) == -1);\n    assert (search({6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}) == 1);\n    assert (search({1, 9, 10, 1, 3}) == 1);\n    assert (search({6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}) == 5);\n    assert (search({1}) == 1);\n    assert (search({8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}) == 4);\n    assert (search({2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}) == 2);\n    assert (search({1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}) == 1);\n    assert (search({9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}) == 4);\n    assert (search({2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}) == 4);\n    assert (search({9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}) == 2);\n    assert (search({5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}) == -1);\n    assert (search({10}) == -1);\n    assert (search({9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}) == 2);\n    assert (search({5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}) == 1);\n    assert (search({7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}) == 1);\n    assert (search({3, 10, 10, 9, 2}) == -1);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/70", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Step 2: Input Validation\n    if (lst.empty()) {\n        return {};\n    }\n\n    // Step 3: Sorting\n    vector<int> sorted_lst = lst; // Copy the input\n    sort(sorted_lst.begin(), sorted_lst.end());\n\n    // Step 4: Initialize Pointers\n    vector<int> result;\n    int left = 0;\n    int right = sorted_lst.size() - 1;\n\n    // Step 5: Alternating Selection\n    while (left <= right) {\n        // Add minimum\n        result.push_back(sorted_lst[left]);\n        left++;\n        \n        // Add maximum if there's still an element\n        if (left <= right) {\n            result.push_back(sorted_lst[right]);\n            right--;\n        }\n    }\n\n    // Step 6: Return the Result\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(strange_sort_list({1, 2, 3, 4}) , {1, 4, 2, 3}));\n    assert (issame(strange_sort_list({5, 6, 7, 8, 9}) , {5, 9, 6, 8, 7}));\n    assert (issame(strange_sort_list({1, 2, 3, 4, 5}) , {1, 5, 2, 4, 3}));\n    assert (issame(strange_sort_list({5, 6, 7, 8, 9, 1}) , {1, 9, 5, 8, 6, 7}));\n    assert (issame(strange_sort_list({5, 5, 5, 5}) , {5, 5, 5, 5}));\n    assert (issame(strange_sort_list({}) , {}));\n    assert (issame(strange_sort_list({1,2,3,4,5,6,7,8}) , {1, 8, 2, 7, 3, 6, 4, 5}));\n    assert (issame(strange_sort_list({0,2,2,2,5,5,-5,-5}) , {-5, 5, -5, 5, 0, 2, 2, 2}));\n    assert (issame(strange_sort_list({111111}) , {111111}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/72", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a vector is a palindrome\nbool is_palindrome(const vector<int>& q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Helper function to calculate the sum of elements in the vector\nint calculate_sum(const vector<int>& q) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    return sum;\n}\n\n// Main function to determine if the object will fly\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is balanced (palindromic)\n    bool balanced = is_palindrome(q);\n    \n    // Calculate the sum of the elements\n    int total_weight = calculate_sum(q);\n    \n    // Return true if balanced and total weight is less than or equal to w\n    return balanced && (total_weight <= w);\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (will_it_fly({3, 2, 3}, 9)==true);\n    assert (will_it_fly({1, 2}, 5) == false);\n    assert (will_it_fly({3}, 5) == true);\n    assert (will_it_fly({3, 2, 3}, 1) == false);\n    assert (will_it_fly({1, 2, 3}, 6) ==false);\n    assert (will_it_fly({5}, 5) == true);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/73", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int change_count = 0;\n    int n = arr.size();\n    \n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            change_count++;\n        }\n    }\n    \n    return change_count;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (smallest_change({1,2,3,5,4,7,9,6}) == 4);\n    assert (smallest_change({1, 2, 3, 4, 3, 2, 2}) == 1);\n    assert (smallest_change({1, 4, 2}) == 1);\n    assert (smallest_change({1, 4, 4, 2}) == 1);\n    assert (smallest_change({1, 2, 3, 2, 1}) == 0);\n    assert (smallest_change({3, 1, 1, 3}) == 0);\n    assert (smallest_change({1}) == 0);\n    assert (smallest_change({0, 1}) == 1);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/74", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint calculate_total_chars(const vector<string>& lst) {\n    int total = 0;\n    for (const string& str : lst) {\n        total += str.length();\n    }\n    return total;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int total_chars1 = calculate_total_chars(lst1);\n    int total_chars2 = calculate_total_chars(lst2);\n\n    if (total_chars1 < total_chars2) {\n        return lst1;\n    } else if (total_chars1 > total_chars2) {\n        return lst2;\n    } else {\n        return lst1; // If equal\n    }\n}\n\n// Example test cases\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(total_match({}, {}) , {}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\"}) , {\"hi\", \"hi\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) , {\"hi\", \"admin\"}));\n    assert (issame(total_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) , {\"4\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) , {\"hI\", \"Hi\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) , {\"hI\", \"hi\", \"hi\"}));\n    assert (issame(total_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hii\"}) , {\"hi\", \"admin\"}));\n    assert (issame(total_match({}, {\"this\"}) , {}));\n    assert (issame(total_match({\"this\"}, {}) , {}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/75", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to generate prime numbers less than 100\nvoid generate_primes(vector<int>& primes) {\n    bool is_prime[100];\n    fill(begin(is_prime), end(is_prime), true);\n    is_prime[0] = is_prime[1] = false; // 0 and 1 are not prime numbers\n\n    for (int i = 2; i * i < 100; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < 100; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    for (int i = 2; i < 100; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n}\n\n// Function to check if a number is the product of three primes\nbool is_multiply_prime(int a) {\n    vector<int> primes;\n    generate_primes(primes); // Generate primes less than 100\n\n    // Iterate over all combinations of three primes\n    for (int i = 0; i < primes.size(); i++) {\n        for (int j = 0; j < primes.size(); j++) {\n            for (int k = 0; k < primes.size(); k++) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true; // Found a valid combination\n                }\n            }\n        }\n    }\n    return false; // No valid combination found\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_multiply_prime(5) == false);\n    assert (is_multiply_prime(30) == true);\n    assert (is_multiply_prime(8) == true);\n    assert (is_multiply_prime(10) == false);\n    assert (is_multiply_prime(125) == true);\n    assert (is_multiply_prime(3 * 5 * 7) == true);\n    assert (is_multiply_prime(3 * 6 * 7) == false);\n    assert (is_multiply_prime(9 * 9 * 9) == false);\n    assert (is_multiply_prime(11 * 9 * 9) == false);\n    assert (is_multiply_prime(11 * 13 * 7) == true);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/76", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    // Step 2: Input Validation\n    if (n <= 1) return false; // n must be greater than 1\n    if (x < 0) return false; // x must be non-negative\n\n    // Step 3: Initialize Variables\n    int power = 1; // This represents n^0\n\n    // Step 4: Loop to Calculate Powers\n    while (power < x) {\n        power *= n; // Calculate the next power of n\n        if (power == x) {\n            return true; // Found a match\n        }\n    }\n\n    // Step 5: Final Check\n    return false; // No match found\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_simple_power(1, 4)== true);\n    assert (is_simple_power(2, 2)==true);\n    assert (is_simple_power(8, 2)==true);\n    assert (is_simple_power(3, 2)==false);\n    assert (is_simple_power(3, 1)==false);\n    assert (is_simple_power(5, 3)==false);\n    assert (is_simple_power(16, 2)== true);\n    assert (is_simple_power(143214, 16)== false);\n    assert (is_simple_power(4, 2)==true);\n    assert (is_simple_power(9, 3)==true);\n    assert (is_simple_power(16, 4)==true);\n    assert (is_simple_power(24, 2)==false);\n    assert (is_simple_power(128, 4)==false);\n    assert (is_simple_power(12, 6)==false);\n    assert (is_simple_power(1, 1)==true);\n    assert (is_simple_power(1, 12)==true);\n}\n", "result": "failed: a.out: test.cpp:43: int main(): Assertion `is_simple_power(1, 4)== true' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/77", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <cmath>\n\nusing namespace std;\n\nbool iscube(int a) {\n    // Handle the special case for zero\n    if (a == 0) return true;\n\n    // Calculate the cube root\n    double root = cbrt(a);\n    int roundedRoot = round(root);\n\n    // Check if the rounded cube root cubed equals a\n    if (roundedRoot * roundedRoot * roundedRoot == a) {\n        return true;\n    }\n\n    // Check the neighboring integers to account for rounding issues\n    if ((roundedRoot - 1) * (roundedRoot - 1) * (roundedRoot - 1) == a ||\n        (roundedRoot + 1) * (roundedRoot + 1) * (roundedRoot + 1) == a) {\n        return true;\n    }\n\n    // If none of the checks passed, return false\n    return false;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (iscube(1) == true);\n    assert (iscube(2) == false);\n    assert (iscube(-1) == true);\n    assert (iscube(64) == true);\n    assert (iscube(180) == false);\n    assert (iscube(1000) == true);\n    assert (iscube(0) == true);\n    assert (iscube(1729) == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/79", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <string>\n#include <algorithm> // for std::reverse\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Handle edge case for zero\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    // Convert decimal to binary\n    string binary = \"\";\n    while (decimal > 0) {\n        // Append remainder (0 or 1)\n        binary += (decimal % 2) ? '1' : '0';\n        decimal /= 2; // Update decimal to quotient\n    }\n\n    // Reverse the binary string to get the correct order\n    reverse(binary.begin(), binary.end());\n\n    // Format the result\n    return \"db\" + binary + \"db\";\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (decimal_to_binary(0) == \"db0db\");\n    assert (decimal_to_binary(32) == \"db100000db\");\n    assert (decimal_to_binary(103) == \"db1100111db\");\n    assert (decimal_to_binary(15) == \"db1111db\");\n\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/78", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <string>\n#include <unordered_set>\n\nusing namespace std;\n\nint hex_key(string num) {\n    // Initialize variables\n    int count = 0;\n    unordered_set<char> prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'};\n\n    // Iterate through input string\n    for (char digit : num) {\n        // Count matches\n        if (prime_hex_digits.find(digit) != prime_hex_digits.end()) {\n            count++;\n        }\n    }\n\n    // Return the result\n    return count;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (hex_key(\"AB\") == 1      );\n    assert (hex_key(\"1077E\") == 2 );\n    assert (hex_key(\"ABED1A33\") == 4     );\n    assert (hex_key(\"2020\") == 2 );\n    assert (hex_key(\"123456789ABCDEF0\") == 6      );\n    assert (hex_key(\"112233445566778899AABBCCDDEEFF00\") == 12 );\n    assert (hex_key(\"\") == 0);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/80", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check length\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Loop through the string\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        // Check distinct characters\n        unordered_set<char> charSet;\n        charSet.insert(s[i]);\n        charSet.insert(s[i + 1]);\n        charSet.insert(s[i + 2]);\n\n        // If the size of the set is not 3, we have duplicates\n        if (charSet.size() != 3) {\n            return false;\n        }\n    }\n\n    // All groups of three characters are distinct\n    return true;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_happy(\"a\") == false );\n    assert (is_happy(\"aa\") == false );\n    assert (is_happy(\"abcd\") == true );\n    assert (is_happy(\"aabb\") == false );\n    assert (is_happy(\"adb\") == true );\n    assert (is_happy(\"xyy\") == false );\n    assert (is_happy(\"iopaxpoi\") == true );\n    assert (is_happy(\"iopaxioi\") == false );\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/82", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <string>\n#include <cmath> // For sqrt function\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n < 2) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to check if string length is prime\nbool prime_length(string str) {\n    int length = str.length();\n    return is_prime(length);\n}\n\n// Example usage\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (prime_length(\"Hello\") == true);\n    assert (prime_length(\"abcdcba\") == true);\n    assert (prime_length(\"kittens\") == true);\n    assert (prime_length(\"orange\") == false);\n    assert (prime_length(\"wow\") == true);\n    assert (prime_length(\"world\") == true);\n    assert (prime_length(\"MadaM\") == true);\n    assert (prime_length(\"Wow\") == true);\n    assert (prime_length(\"\") == false);\n    assert (prime_length(\"HI\") == true);\n    assert (prime_length(\"go\") == true);\n    assert (prime_length(\"gogo\") == false);\n    assert (prime_length(\"aaaaaaaaaaaaaaa\") == false);\n    assert (prime_length(\"Madam\") == true);\n    assert (prime_length(\"M\") == false);\n    assert (prime_length(\"0\") == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/81", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letterGrades;\n\n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letterGrades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letterGrades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letterGrades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letterGrades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letterGrades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letterGrades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letterGrades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letterGrades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letterGrades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letterGrades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letterGrades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letterGrades.push_back(\"D-\");\n        } else {\n            letterGrades.push_back(\"E\");\n        }\n    }\n\n    return letterGrades;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(numerical_letter_grade({4.0, 3, 1.7, 2, 3.5}) , {\"A+\", \"B\", \"C-\", \"C\", \"A-\"}));\n    assert (issame(numerical_letter_grade({1.2}) , {\"D+\"}));\n    assert (issame(numerical_letter_grade({0.5}) , {\"D-\"}));\n    assert (issame(numerical_letter_grade({0.0}) , {\"E\"}));\n    assert (issame(numerical_letter_grade({1, 0.3, 1.5, 2.8, 3.3}) , {\"D\", \"D-\", \"C-\", \"B\", \"B+\"}));\n    assert (issame(numerical_letter_grade({0, 0.7}) , {\"E\", \"D-\"}));\n    \n}\n", "result": "failed: a.out: test.cpp:67: int main(): Assertion `issame(numerical_letter_grade({4.0, 3, 1.7, 2, 3.5}) , {\"A+\", \"B\", \"C-\", \"C\", \"A-\"})' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/84", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    // Step 1: Input Validation\n    if (N < 0 || N > 10000) {\n        return \"\"; // or handle error\n    }\n    if (N == 0) {\n        return \"0\";\n    }\n\n    // Step 2: Digit Extraction and Summation\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10; // Add last digit to sum\n        N /= 10;       // Remove last digit\n    }\n\n    // Step 3: Binary Conversion\n    string binary = \"\";\n    while (sum > 0) {\n        binary = to_string(sum % 2) + binary; // Prepend the remainder\n        sum /= 2; // Divide sum by 2\n    }\n\n    // Step 4: Return the Result\n    return binary.empty() ? \"0\" : binary; // Handle case where sum is 0\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (solve(1000) == \"1\");\n    assert (solve(150) == \"110\");\n    assert (solve(147) == \"1100\");\n    assert (solve(333) == \"1001\");\n    assert (solve(963) == \"10010\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/83", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n/*\nGiven a positive integer n, return the count of the numbers of n-digit\npositive integers that start or end with 1.\n*/\n#include <stdio.h>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1; // Only the number 1\n    }\n\n    // Count of n-digit numbers starting with 1\n    int count_starting_with_1 = 1 * (1 * 10^(n - 1)); // 10^(n-1)\n\n    // Count of n-digit numbers ending with 1\n    int count_ending_with_1 = 9 * (1 * 10^(n - 2)); // 9 * 10^(n-2)\n\n    // Count of n-digit numbers starting and ending with 1\n    int count_both_starting_and_ending_with_1 = 1 * (1 * 10^(n - 2)); // 10^(n-2)\n\n    // Total count using inclusion-exclusion principle\n    return count_starting_with_1 + count_ending_with_1 - count_both_starting_and_ending_with_1;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (starts_one_ends(1) == 1);\n    assert (starts_one_ends(2) == 18);\n    assert (starts_one_ends(3) == 180);\n    assert (starts_one_ends(4) == 1800);\n    assert (starts_one_ends(5) == 18000);\n}\n", "result": "failed: a.out: test.cpp:46: int main(): Assertion `starts_one_ends(2) == 18' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/85", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0; // Initialize sum variable\n\n    // Iterate through the vector at odd indices\n    for (int i = 1; i < lst.size(); i += 2) {\n        // Check if the element is even\n        if (lst[i] % 2 == 0) {\n            // Update the sum\n            sum += lst[i];\n        }\n    }\n\n    // Return the result\n    return sum;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (add({4, 88}) == 88);\n    assert (add({4, 5, 6, 7, 2, 122}) == 122);\n    assert (add({4, 0, 6, 7}) == 0);\n    assert (add({4, 4, 6, 8}) == 12);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/86", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result = \"\";\n    string currentWord = \"\";\n\n    for (char c : s) {\n        if (c == ' ') {\n            // Sort and append the current word if it's not empty\n            if (!currentWord.empty()) {\n                sort(currentWord.begin(), currentWord.end());\n                result += currentWord;\n                currentWord = \"\"; // Reset for the next word\n            }\n            result += ' '; // Append the space\n        } else {\n            currentWord += c; // Build the current word\n        }\n    }\n\n    // Handle the last word if there is one\n    if (!currentWord.empty()) {\n        sort(currentWord.begin(), currentWord.end());\n        result += currentWord;\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (anti_shuffle(\"Hi\") == \"Hi\");\n    assert (anti_shuffle(\"hello\") == \"ehllo\");\n    assert (anti_shuffle(\"number\") == \"bemnru\");\n    assert (anti_shuffle(\"abcd\") == \"abcd\");\n    assert (anti_shuffle(\"Hello World!!!\") == \"Hello !!!Wdlor\");\n    assert (anti_shuffle(\"\") == \"\");\n    assert (anti_shuffle(\"Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/87", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result; // Initialize result vector\n\n    // Loop through each row\n    for (int i = 0; i < lst.size(); i++) {\n        // Loop through each element in the row\n        for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) { // Check for matches\n                result.push_back({i, j}); // Store coordinates\n            }\n        }\n    }\n\n    // Sort the result vector\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort by column index descending\n        }\n        return a[0] < b[0]; // Sort by row index ascending\n    });\n\n    // Return the result\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<vector<int>> a,vector<vector<int>> b){\n    if (a.size()!=b.size()) return false;\n\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i].size()!=b[i].size()) return false;\n        for (int j=0;j<a[i].size();j++)\n            if (a[i][j]!=b[i][j]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(get_row({\n        {1,2,3,4,5,6},\n        {1,2,3,4,1,6},\n        {1,2,3,4,5,1}}, 1) , {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}));\n    assert (issame(get_row({\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6}}, 2) , {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}}));\n    assert (issame(get_row({\n        {1,2,3,4,5,6},\n        {1,2,3,4,5,6},\n        {1,1,3,4,5,6},\n        {1,2,1,4,5,6},\n        {1,2,3,1,5,6},\n        {1,2,3,4,1,6},\n        {1,2,3,4,5,1}\n    }, 1) , {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}}));\n    assert (issame(get_row({}, 1) , {}));\n    assert (issame(get_row({{1}}, 2) , {}));\n    assert (issame(get_row({{}, {1}, {1, 2, 3}}, 3) , {{2, 2}}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/89", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string result; // Initialize an empty result string\n\n    for (char c : s) { // Loop through each character\n        if (c >= 'a' && c <= 'z') { // Check if character is lowercase\n            char newChar = (c - 'a' + 4) % 26 + 'a'; // Shift by 4 and wrap around\n            result += newChar; // Append new character to result\n        } else {\n            result += c; // Append unchanged character (if needed)\n        }\n    }\n\n    return result; // Return the encrypted string\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (encrypt(\"hi\") == \"lm\");\n    assert (encrypt(\"asdfghjkl\") == \"ewhjklnop\");\n    assert (encrypt(\"gf\") == \"kj\");\n    assert (encrypt(\"et\") == \"ix\");\n    assert (encrypt(\"faewfawefaewg\")==\"jeiajeaijeiak\");\n    assert (encrypt(\"hellomyfriend\")==\"lippsqcjvmirh\");\n    assert (encrypt(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")==\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\");\n    assert (encrypt(\"a\")==\"e\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/90", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    // Step 2: Check for empty vector\n    if (lst.empty()) {\n        return -1; // Return -1 to indicate None\n    }\n\n    // Step 3: Extract unique elements\n    set<int> unique_elements(lst.begin(), lst.end());\n\n    // Step 4: Check for unique element count\n    if (unique_elements.size() < 2) {\n        return -1; // Return -1 to indicate None\n    }\n\n    // Step 5: Convert set to vector and sort (set is already sorted)\n    vector<int> sorted_unique(unique_elements.begin(), unique_elements.end());\n\n    // Step 6: Return the second smallest element\n    return sorted_unique[1];\n}\n\n// Test cases\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (next_smallest({1, 2, 3, 4, 5}) == 2);\n    assert (next_smallest({5, 1, 4, 3, 2}) == 2);\n    assert (next_smallest({}) == -1);\n    assert (next_smallest({1, 1}) == -1);\n    assert (next_smallest({1,1,1,1,0}) == 1);\n    assert (next_smallest({-35, 34, 12, -45}) == -35);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/88", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Step 2: Input Validation\n    if (array.empty()) {\n        return {}; // Return empty vector if input is empty\n    }\n\n    // Step 3: Calculate the Sum\n    int first = array.front();\n    int last = array.back();\n    int sum = first + last;\n\n    // Step 4: Determine Sorting Order\n    vector<int> sorted_array = array; // Create a copy of the original array\n    if (sum % 2 == 0) {\n        // Step 5: Sort in descending order\n        sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n    } else {\n        // Step 5: Sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    // Step 6: Return the Result\n    return sorted_array;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_array({}) , {}));\n    assert (issame(sort_array({5}) , {5}));\n    assert (issame(sort_array({2, 4, 3, 0, 1, 5}) , {0, 1, 2, 3, 4, 5}));\n    assert (issame(sort_array({2, 4, 3, 0, 1, 5, 6}) , {6, 5, 4, 3, 2, 1, 0}));\n    assert (issame(sort_array({2, 1}) , {1, 2}));\n    assert (issame(sort_array({15, 42, 87, 32 ,11, 0}) , {0, 11, 15, 32, 42, 87}));\n    assert (issame(sort_array({21, 14, 23, 11}) , {23, 21, 14, 11}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/91", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int boredom_count = 0;\n    string sentence;\n    stringstream ss(S);\n    \n    // Loop through the string and extract sentences\n    while (getline(ss, sentence, '.')) {\n        // Check for other delimiters\n        if (sentence.back() == '?' || sentence.back() == '!') {\n            sentence.pop_back(); // Remove the delimiter\n        }\n        \n        // Trim leading whitespace\n        size_t start = sentence.find_first_not_of(\" \\n\\r\\t\");\n        if (start != string::npos) {\n            sentence = sentence.substr(start);\n        }\n        \n        // Check if the sentence starts with \"I\"\n        if (sentence.rfind(\"I \", 0) == 0 || sentence == \"I\") { // Check if it starts with \"I \"\n            boredom_count++;\n        }\n    }\n    \n    return boredom_count;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_bored(\"Hello world\") == 0);\n    assert (is_bored(\"Is the sky blue?\") == 0);\n    assert (is_bored(\"I love It !\") == 1);\n    assert (is_bored(\"bIt\") == 0);\n    assert (is_bored(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert (is_bored(\"You and I are going for a walk\") == 0);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/92", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#include <stdio.h>\n#include <math.h>\n\nbool any_int(float a, float b, float c) {\n    // Input validation: Check if all inputs are integers\n    if (a != floor(a) || b != floor(b) || c != floor(c)) {\n        return false;\n    }\n\n    // Check if any number is equal to the sum of the other two\n    if (a == b + c || b == a + c || c == a + b) {\n        return true;\n    }\n\n    // If none of the conditions are satisfied, return false\n    return false;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (any_int(2, 3, 1)==true);\n    assert (any_int(2.5, 2, 3)==false);\n    assert (any_int(1.5, 5, 3.5)==false);\n    assert (any_int(2, 6, 2)==false);\n    assert (any_int(4, 2, 2)==true);\n    assert (any_int(2.2, 2.2, 2.2)==false);\n    assert (any_int(-4, 6, 2)==true);\n    assert (any_int(2,1,1)==true);\n    assert (any_int(3,4,7)==true);\n    assert (any_int(3.01,4,7)==false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/93", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode(string message) {\n    string encodedMessage = \"\"; // Initialize the result string\n    for (char c : message) { // Iterate through each character\n        // Swap case\n        if (isalpha(c)) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n            // Check for vowels and replace\n            switch (c) {\n                case 'A': c = 'C'; break;\n                case 'E': c = 'G'; break;\n                case 'I': c = 'K'; break;\n                case 'O': c = 'Q'; break;\n                case 'U': c = 'W'; break;\n                case 'a': c = 'c'; break;\n                case 'e': c = 'g'; break;\n                case 'i': c = 'k'; break;\n                case 'o': c = 'q'; break;\n                case 'u': c = 'w'; break;\n                default: break; // Non-vowel letters remain unchanged\n            }\n        }\n        // Build the encoded message\n        encodedMessage += c;\n    }\n    // Return the result\n    return encodedMessage;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (encode(\"TEST\") == \"tgst\");\n    assert (encode(\"Mudasir\") == \"mWDCSKR\");\n    assert (encode(\"YES\") == \"ygs\");\n    assert (encode(\"This is a message\") == \"tHKS KS C MGSSCGG\");\n    assert (encode(\"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/94", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and return the sum of its digits\nint skjkasdkd(vector<int> lst) {\n    vector<int> primes;\n    \n    // Collect prime numbers\n    for (int num : lst) {\n        if (isPrime(num)) {\n            primes.push_back(num);\n        }\n    }\n    \n    // Find the largest prime\n    if (primes.empty()) return 0; // No prime found\n    int largestPrime = primes[0];\n    for (int prime : primes) {\n        if (prime > largestPrime) {\n            largestPrime = prime;\n        }\n    }\n    \n    // Return the sum of digits of the largest prime\n    return sumOfDigits(largestPrime);\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (skjkasdkd({0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3}) == 10);\n    assert (skjkasdkd({1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1}) == 25);\n    assert (skjkasdkd({1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3}) == 13);\n    assert (skjkasdkd({0,724,32,71,99,32,6,0,5,91,83,0,5,6}) == 11);\n    assert (skjkasdkd({0,81,12,3,1,21}) == 3);\n    assert (skjkasdkd({0,8,1,2,1,7}) == 7);\n    assert (skjkasdkd({8191}) == 19);\n    assert (skjkasdkd({8191, 123456, 127, 7}) == 19);\n    assert (skjkasdkd({127, 97, 8192}) == 10);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/97", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract unit digits\n    int unit_digit_a = abs(a) % 10; // Get unit digit of a\n    int unit_digit_b = abs(b) % 10; // Get unit digit of b\n    \n    // Multiply unit digits\n    int product = unit_digit_a * unit_digit_b;\n    \n    // Return the result\n    return product;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (multiply(148, 412) == 16                   );\n    assert (multiply(19, 28) == 72       );\n    assert (multiply(2020, 1851) == 0);\n    assert (multiply(14,-15) == 20   );\n    assert (multiply(76, 67) == 42    );\n    assert (multiply(17, 27) == 49    );\n    assert (multiply(0, 1) == 0);\n    assert (multiply(0, 0) == 0);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/96", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\n#include <cmath> // For sqrt function\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num < 2) return false;\n    for (int i = 2; i <= sqrt(num); i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to count primes up to n\nvector<int> count_up_to(int n) {\n    vector<int> primes; // Vector to store prime numbers\n\n    // Input validation\n    if (n < 0) return primes; // Return empty vector for negative input\n\n    // Loop through numbers from 2 to n-1\n    for (int i = 2; i < n; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i); // Add prime number to vector\n        }\n    }\n\n    return primes; // Return the vector of prime numbers\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(count_up_to(5) , {2,3}));\n    assert (issame(count_up_to(6) , {2,3,5}));\n    assert (issame(count_up_to(7) , {2,3,5}));\n    assert (issame(count_up_to(10) , {2,3,5,7}));\n    assert (issame(count_up_to(0) , {}));\n    assert (issame(count_up_to(22) , {2,3,5,7,11,13,17,19}));\n    assert (issame(count_up_to(1) , {}));\n    assert (issame(count_up_to(18) , {2,3,5,7,11,13,17}));\n    assert (issame(count_up_to(47) , {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}));\n    assert (issame(count_up_to(101) , {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/98", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0; // Initialize counter\n\n    // Iterate through the string\n    for (int i = 0; i < s.length(); i++) {\n        if (i % 2 == 0) { // Check for even index\n            char c = s[i];\n            // Check if the character is an uppercase vowel\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                count++; // Increment counter\n            }\n        }\n    }\n\n    return count; // Return the count\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (count_upper(\"aBCdEf\")  == 1);\n    assert (count_upper(\"abcdefg\") == 0);\n    assert (count_upper(\"dBBE\") == 0);\n    assert (count_upper(\"B\")  == 0);\n    assert (count_upper(\"U\")  == 1);\n    assert (count_upper(\"\") == 0);\n    assert (count_upper(\"EEEE\") == 2);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/99", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <stdexcept>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Step 1: Convert string to float\n    double num;\n    try {\n        num = stod(value);\n    } catch (invalid_argument&) {\n        throw runtime_error(\"Invalid input: not a number\");\n    }\n\n    // Step 2: Calculate closest integers\n    int lower_integer = static_cast<int>(floor(num));\n    int upper_integer = static_cast<int>(ceil(num));\n\n    // Step 3: Determine distances\n    double distance_to_lower = num - lower_integer;\n    double distance_to_upper = upper_integer - num;\n\n    // Step 4: Apply rounding logic\n    if (distance_to_lower < distance_to_upper) {\n        return lower_integer;\n    } else if (distance_to_upper < distance_to_lower) {\n        return upper_integer;\n    } else {\n        // Equidistant case\n        return (num >= 0) ? upper_integer : lower_integer;\n    }\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (closest_integer(\"10\") == 10);\n    assert (closest_integer(\"14.5\") == 15);\n    assert (closest_integer(\"-15.5\") == -16);\n    assert (closest_integer(\"15.3\") == 15);\n    assert (closest_integer(\"0\") == 0);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/95", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <string>\n#include <map>\n#include <cctype> // For islower and isupper functions\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check for empty map\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Initialize case type\n    bool isLowerCase = islower(dict.begin()->first[0]);\n    bool isUpperCase = isupper(dict.begin()->first[0]);\n\n    // Iterate through the map\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        // Check if key is alphabetic and matches case\n        if (!isalpha(key[0]) || (isLowerCase && !islower(key[0])) || (isUpperCase && !isupper(key[0]))) {\n            return false;\n        }\n    }\n\n    // Return true if all checks passed\n    return true;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (check_dict_case({{\"p\",\"pineapple\"}, {\"b\",\"banana\"}}) == true);\n    assert (check_dict_case({{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}}) == false);\n    assert (check_dict_case({{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}}) == false);\n    assert (check_dict_case({{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}}) == false);\n    assert (check_dict_case({{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"} }) == true  );\n    assert (check_dict_case({{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"} }) == true  );\n    assert (check_dict_case({}) == false);\n}\n", "result": "failed: a.out: test.cpp:52: int main(): Assertion `check_dict_case({{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}}) == false' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/100", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    // Input Validation\n    if (n <= 0) {\n        return {}; // Return an empty vector for non-positive input\n    }\n\n    // Initialize Variables\n    vector<int> stones;\n    int current_stones;\n\n    // Calculate Stones for Each Level\n    for (int i = 0; i < n; ++i) {\n        if (i == 0) {\n            current_stones = n; // First level has n stones\n        } else {\n            // Determine the next odd or even number\n            if (n % 2 == 0) { // n is even\n                current_stones += 2; // Next even number\n            } else { // n is odd\n                current_stones += 2; // Next odd number\n            }\n        }\n        stones.push_back(current_stones); // Append to the vector\n    }\n\n    // Return the Result\n    return stones;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(make_a_pile(3) , {3, 5, 7}));\n    assert (issame(make_a_pile(4) , {4,6,8,10}));\n    assert (issame(make_a_pile(5) , {5, 7, 9, 11, 13}));\n    assert (issame(make_a_pile(6) , {6, 8, 10, 12, 14, 16}));\n    assert (issame(make_a_pile(8) , {8, 10, 12, 14, 16, 18, 20, 22}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/101", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    string temp;\n\n    // Check for empty input\n    if (s.empty()) {\n        return words; // Return empty vector\n    }\n\n    // Traverse the string\n    for (char c : s) {\n        if (c != ' ' && c != ',') {\n            temp += c; // Build the word\n        } else {\n            if (!temp.empty()) {\n                words.push_back(temp); // Add the word to the vector\n                temp.clear(); // Reset the temporary string\n            }\n        }\n    }\n\n    // Check for any remaining word\n    if (!temp.empty()) {\n        words.push_back(temp);\n    }\n\n    return words; // Return the vector of words\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(words_string(\"Hi, my name is John\") , {\"Hi\", \"my\", \"name\", \"is\", \"John\"}));\n    assert (issame(words_string(\"One, two, three, four, five, six\") , {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}));\n    assert (issame(words_string(\"Hi, my name\") , {\"Hi\", \"my\", \"name\"}));\n    assert (issame(words_string(\"One,, two, three, four, five, six,\") , {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}));\n    assert (issame(words_string(\"\") , {}));\n    assert (issame(words_string(\"ahmed     , gamal\") , {\"ahmed\", \"gamal\"}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/102", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Step 1: Determine the range\n    if (x > y) {\n        int temp = x;\n        x = y;\n        y = temp;\n    }\n\n    // Step 2: Identify the largest even integer\n    int largest_even = y;\n    if (largest_even % 2 != 0) {\n        largest_even--; // Decrement if odd\n    }\n\n    // Step 3: Check validity\n    if (largest_even < x) {\n        return -1; // No even integer in range\n    }\n    \n    return largest_even; // Return the largest even integer\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (choose_num(12, 15) == 14);\n    assert (choose_num(13, 12) == -1);\n    assert (choose_num(33, 12354) == 12354);\n    assert (choose_num(5234, 5233) == -1);\n    assert (choose_num(6, 29) == 28);\n    assert (choose_num(27, 10) == -1);\n    assert (choose_num(7, 7) == -1);\n    assert (choose_num(546, 546) == 546);\n}\n", "result": "failed: a.out: test.cpp:46: int main(): Assertion `choose_num(13, 12) == -1' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/103", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <math.h>\n#include <string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Input Validation\n    if (n <= 0 || m <= 0) {\n        return \"-1\"; // Not required by the problem but good practice\n    }\n    \n    // Range Check\n    if (n > m) {\n        return \"-1\";\n    }\n    \n    // Calculate the Sum and Count\n    int sum = 0;\n    int count = m - n + 1;\n    \n    for (int i = n; i <= m; i++) {\n        sum += i;\n    }\n    \n    // Compute the Average\n    int average = floor(static_cast<double>(sum) / count);\n    \n    // Convert to Binary\n    string binary = \"\";\n    if (average == 0) {\n        binary = \"0\";\n    } else {\n        while (average > 0) {\n            binary = to_string(average % 2) + binary;\n            average /= 2;\n        }\n    }\n    \n    return binary;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (rounded_avg(1, 5) == \"11\");\n    assert (rounded_avg(7, 13) == \"1010\");\n    assert (rounded_avg(964,977) == \"1111001010\");\n    assert (rounded_avg(996,997) == \"1111100100\");\n    assert (rounded_avg(560,851) == \"1011000001\");  \n    assert (rounded_avg(185,546) == \"101101101\");\n    assert (rounded_avg(362,496) == \"110101101\");\n    assert (rounded_avg(350,902) == \"1001110010\");\n    assert (rounded_avg(197,233) == \"11010111\");\n    assert (rounded_avg(7, 5) == \"-1\");\n    assert (rounded_avg(5, 1) == \"-1\");\n    assert (rounded_avg(5, 5) == \"101\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/106", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n// Helper function to calculate factorial\nint factorial(int i) {\n    int result = 1;\n    for (int j = 1; j <= i; j++) {\n        result *= j;\n    }\n    return result;\n}\n\n// Helper function to calculate sum from 1 to i\nint sumToN(int i) {\n    return (i * (i + 1)) / 2; // Using the formula for the sum of the first i natural numbers\n}\n\n// Main function to generate the vector\nvector<int> f(int n) {\n    vector<int> result(n);\n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            result[i - 1] = factorial(i); // Store factorial for even index\n        } else {\n            result[i - 1] = sumToN(i); // Store sum for odd index\n        }\n    }\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(f(5) , {1, 2, 6, 24, 15}));\n    assert (issame(f(7) , {1, 2, 6, 24, 15, 720, 28}));\n    assert (issame(f(1) , {1}));\n    assert (issame(f(3) , {1, 2, 6}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/104", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result; // Step 2\n\n    for (int num : x) { // Step 3\n        bool hasEvenDigit = false;\n        int temp = num;\n        \n        while (temp > 0) {\n            int digit = temp % 10;\n            if (digit % 2 == 0) { // Check if digit is even\n                hasEvenDigit = true;\n                break; // No need to check further\n            }\n            temp /= 10;\n        }\n\n        if (!hasEvenDigit) {\n            result.push_back(num); // Step 5\n        }\n    }\n\n    sort(result.begin(), result.end()); // Step 6\n    return result; // Step 7\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(unique_digits({15, 33, 1422, 1}) , {1, 15, 33}));\n    assert (issame(unique_digits({152, 323, 1422, 10}) , {}));\n    assert (issame(unique_digits({12345, 2033, 111, 151}) , {111, 151}));\n    assert (issame(unique_digits({135, 103, 31}) , {31, 135}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/107", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a number is a palindrome\nbool is_palindrome(int num) {\n    string str = to_string(num);\n    string rev_str = string(str.rbegin(), str.rend());\n    return str == rev_str;\n}\n\n// Main function to count even and odd palindromes\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count}; // Return the counts as a vector\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(even_odd_palindrome(123) , {8, 13}));\n    assert (issame(even_odd_palindrome(12) , {4, 6}));\n    assert (issame(even_odd_palindrome(3) , {1, 2}));\n    assert (issame(even_odd_palindrome(63) , {6, 8}));\n    assert (issame(even_odd_palindrome(25) , {5, 6}));\n    assert (issame(even_odd_palindrome(19) , {4, 6}));\n    assert (issame(even_odd_palindrome(9) , {4, 5}));\n    assert (issame(even_odd_palindrome(1) , {0, 1}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/109", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true; // Edge case for empty vector\n\n    int breakCount = 0;\n    int N = arr.size();\n\n    for (int i = 0; i < N; i++) {\n        if (arr[i] > arr[(i + 1) % N]) {\n            breakCount++;\n        }\n    }\n\n    // If there are more than one break points, return false\n    return breakCount <= 1;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (move_one_ball({3, 4, 5, 1, 2})==true);\n    assert (move_one_ball({3, 5, 10, 1, 2})==true);\n    assert (move_one_ball({4, 3, 1, 2})==false);\n    assert (move_one_ball({3, 5, 4, 1, 2})==false);\n    assert (move_one_ball({})==true);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/108", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool isNegative = (num < 0);\n    num = abs(num);\n    \n    while (num > 0) {\n        int digit = num % 10;\n        sum += digit;\n        num /= 10;\n    }\n    \n    if (isNegative) {\n        // Adjust for the first signed digit\n        sum -= 1; // Subtract 1 for the first signed digit\n    }\n    \n    return sum;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (count_nums({}) == 0);\n    assert (count_nums({-1, -2, 0}) == 0);\n    assert (count_nums({1, 1, 2, -2, 3, 4, 5}) == 6);\n    assert (count_nums({1, 6, 9, -6, 0, 1, 5}) == 5);\n    assert (count_nums({1, 100, 98, -7, 1, -1}) == 4);\n    assert (count_nums({12, 23, 34, -45, -56, 0}) == 5);\n    assert (count_nums({-0, 1}) == 1);\n    assert (count_nums({1}) == 1);\n}\n", "result": "failed: a.out: test.cpp:53: int main(): Assertion `count_nums({-1, -2, 0}) == 0' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/105", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Step 2: Initialize variables\n    vector<int> validIntegers;\n    map<int, string> intToString = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Step 8: Handle edge case for empty vector\n    if (arr.empty()) {\n        return {};\n    }\n\n    // Step 3: Filter valid integers\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            validIntegers.push_back(num);\n        }\n    }\n\n    // Step 4: Sort the filtered integers\n    sort(validIntegers.begin(), validIntegers.end());\n\n    // Step 5: Reverse the sorted integers\n    reverse(validIntegers.begin(), validIntegers.end());\n\n    // Step 6: Map integers to names\n    vector<string> result;\n    for (int num : validIntegers) {\n        result.push_back(intToString[num]);\n    }\n\n    // Step 7: Return the result\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(by_length({2, 1, 1, 4, 5, 8, 2, 3}) , {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}));\n    assert (issame(by_length({}) , {}));\n    assert (issame(by_length({1, -1 , 55}) , {\"One\"}));\n    assert (issame(by_length({1, -1, 3, 2}) , {\"Three\", \"Two\", \"One\"}));\n    assert (issame(by_length({9, 4, 8}) , {\"Nine\", \"Eight\", \"Four\"}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/110", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount1 = 0;\n    int evenCount2 = 0;\n\n    // Count odd numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount1++;\n        }\n    }\n\n    // Count even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCount2++;\n        }\n    }\n\n    // Check if we can exchange to make lst1 all even\n    if (oddCount1 <= evenCount2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (exchange({1, 2, 3, 4}, {1, 2, 3, 4}) == \"YES\");\n    assert (exchange({1, 2, 3, 4}, {1, 5, 3, 4}) == \"NO\");\n    assert (exchange({1, 2, 3, 4}, {2, 1, 4, 3}) == \"YES\" );\n    assert (exchange({5, 7, 3}, {2, 6, 4}) == \"YES\");\n    assert (exchange({5, 7, 3}, {2, 6, 3}) == \"NO\" );\n    assert (exchange({3, 2, 6, 1, 8, 9}, {3, 5, 5, 1, 1, 1}) == \"NO\");\n    assert (exchange({100, 200}, {200, 200}) == \"YES\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/111", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <map>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    // Handle empty input\n    if (test.empty()) {\n        return {};\n    }\n\n    // Input Parsing\n    map<char, int> countMap;\n    stringstream ss(test);\n    string letter;\n\n    // Counting Occurrences\n    while (ss >> letter) {\n        countMap[letter[0]]++; // Assuming single lowercase letters\n    }\n\n    // Finding Maximum Occurrences\n    int maxCount = 0;\n    for (const auto& pair : countMap) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Output Formatting\n    map<char, int> result;\n    for (const auto& pair : countMap) {\n        if (pair.second == maxCount) {\n            result[pair.first] = pair.second;\n        }\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(map<char,int> a,map<char,int> b){\n    if (a.size()!=b.size()) return false;\n    map <char,int>::iterator it;\n    for (it=a.begin();it!=a.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (b.find(w1)==b.end()) return false;\n        if (b[w1]!=w2) return false;\n    }\n\n    return true;\n}\nint main(){\n    assert (issame(histogram(\"a b b a\") , {{'a',2},{'b', 2}}));\n    assert (issame(histogram(\"a b c a b\") , {{'a', 2},{'b', 2}}));\n    assert (issame(histogram(\"a b c d g\") , {{'a', 1}, {'b', 1}, {'c', 1}, {'d', 1}, {'g', 1}}));\n    assert (issame(histogram(\"r t g\") , {{'r', 1},{'t', 1},{'g', 1}}));\n    assert (issame(histogram(\"b b b b a\") , {{'b', 4}}));\n    assert (issame(histogram(\"r t g\") , {{'r', 1},{'t', 1},{'g', 1}}));\n    assert (issame(histogram(\"\") , {}));\n    assert (issame(histogram(\"a\") , {{'a', 1}}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/114", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\n#include <limits.h> // For LLONG_MAX\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long minSum = LLONG_MAX; // Step 1: Initialize minSum\n    int n = nums.size(); // Get the size of the vector\n\n    // Step 2: Iterate through all possible subarrays\n    for (int start = 0; start < n; start++) {\n        long long currentSum = 0; // To hold the sum of the current subarray\n        for (int end = start; end < n; end++) {\n            currentSum += nums[end]; // Step 3: Calculate the sum of the current subarray\n            // Step 4: Update the minimum sum\n            if (currentSum < minSum) {\n                minSum = currentSum;\n            }\n        }\n    }\n\n    // Step 5: Return the result\n    return minSum;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (minSubArraySum({2, 3, 4, 1, 2, 4}) == 1);\n    assert (minSubArraySum({-1, -2, -3}) == -6);\n    assert (minSubArraySum({-1, -2, -3, 2, -10}) == -14);\n    assert (minSubArraySum({-9999999999999999}) == -9999999999999999);\n    assert (minSubArraySum({0, 10, 20, 1000000}) == 0);\n    assert (minSubArraySum({-1, -2, -3, 10, -5}) == -6);\n    assert (minSubArraySum({100, -1, -2, -3, 10, -5}) == -6);\n    assert (minSubArraySum({10, 11, 13, 8, 3, 4}) == 3);\n    assert (minSubArraySum({100, -33, 32, -1, 0, -2}) == -33);\n    assert (minSubArraySum({-10}) == -10);\n    assert (minSubArraySum({7}) == 7);\n    assert (minSubArraySum({1, -1}) == -1);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/112", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n// Function to delete characters in c from string s\nstring deleteCharacters(const string& s, const string& c) {\n    string result;\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) { // If ch is not in c\n            result += ch;\n        }\n    }\n    return result;\n}\n\n// Function to check if a string is a palindrome\nbool isPalindrome(const string& s) {\n    string reversed = s;\n    reverse(reversed.begin(), reversed.end());\n    return s == reversed;\n}\n\n// Main function to implement the requirement\nvector<string> reverse_delete(string s, string c) {\n    // Step 1: Delete characters\n    string modifiedString = deleteCharacters(s, c);\n    \n    // Step 2: Check for palindrome\n    bool palindromeCheck = isPalindrome(modifiedString);\n    \n    // Step 3: Format the result\n    vector<string> result;\n    result.push_back(modifiedString);\n    result.push_back(palindromeCheck ? \"True\" : \"False\");\n    \n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(reverse_delete(\"abcde\",\"ae\") , {\"bcd\",\"False\"}));\n    assert (issame(reverse_delete(\"abcdef\", \"b\") , {\"acdef\",\"False\"}));\n    assert (issame(reverse_delete(\"abcdedcba\",\"ab\") , {\"cdedc\",\"True\"}));\n    assert (issame(reverse_delete(\"dwik\",\"w\") , {\"dik\",\"False\"}));\n    assert (issame(reverse_delete(\"a\",\"a\") , {\"\",\"True\"}));\n    assert (issame(reverse_delete(\"abcdedcba\",\"\") , {\"abcdedcba\",\"True\"}));\n    assert (issame(reverse_delete(\"abcdedcba\",\"v\") , {\"abcdedcba\",\"True\"}));\n    assert (issame(reverse_delete(\"vabba\",\"v\") , {\"abba\",\"True\"}));\n    assert (issame(reverse_delete(\"mamma\", \"mia\") , {\"\", \"True\"}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/113", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result; // Initialize output vector\n\n    // Iterate over input vector\n    for (const string& str : lst) {\n        int odd_count = 0; // Initialize odd digit counter\n        \n        // Count odd digits\n        for (char ch : str) {\n            if ((ch - '0') % 2 != 0) { // Check if the character is an odd digit\n                odd_count++;\n            }\n        }\n        \n        // Format the output string\n        string formatted_string = \"the number of odd elements \" + to_string(odd_count) + \n                                  \"n the str\" + to_string(odd_count) + \n                                  \"ng \" + to_string(odd_count) + \n                                  \" of the \" + to_string(odd_count) + \"nput.\";\n        \n        result.push_back(formatted_string); // Collect results\n    }\n\n    return result; // Return the result\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(odd_count({\"1234567\"}) , {\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}));\n    assert (issame(odd_count({\"3\",\"11111111\"}) , {\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"}));\n    assert (issame(odd_count({\"271\", \"137\", \"314\"}) , {\n        \"the number of odd elements 2n the str2ng 2 of the 2nput.\",\n        \"the number of odd elements 3n the str3ng 3 of the 3nput.\",\n        \"the number of odd elements 2n the str2ng 2 of the 2nput.\"\n    }));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/115", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_buckets = 0;\n\n    for (const auto& well : grid) {\n        int water_units = 0;\n\n        // Count water units in the current well\n        for (int water : well) {\n            water_units += water; // Increment for each 1 found\n        }\n\n        // Calculate buckets needed for the current well\n        if (water_units > 0) {\n            total_buckets += (water_units / capacity) + (water_units % capacity > 0 ? 1 : 0);\n        }\n    }\n\n    return total_buckets;\n}\n\n// Example usage\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (max_fill({{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}, 1) == 6);\n    assert (max_fill({{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}, 2) == 5);\n    assert (max_fill({{0,0,0}, {0,0,0}}, 5) == 0);\n    assert (max_fill({{1,1,1,1}, {1,1,1,1}}, 2) == 4);\n    assert (max_fill({{1,1,1,1}, {1,1,1,1}}, 9) == 2);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/116", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint countOnes(int n) {\n    return __builtin_popcount(n); // Count the number of 1's in binary representation\n}\n\nvector<int> sort_array(vector<int> arr) {\n    auto comparator = [](int a, int b) {\n        int countA = countOnes(a);\n        int countB = countOnes(b);\n        if (countA == countB) {\n            return a < b; // Sort by value if counts are equal\n        }\n        return countA < countB; // Sort by number of ones\n    };\n\n    sort(arr.begin(), arr.end(), comparator);\n    return arr;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sort_array({1,5,2,3,4}) , {1, 2, 4, 3, 5}));\n    assert (issame(sort_array({-2,-3,-4,-5,-6}) , {-4, -2, -6, -5, -3}));\n    assert (issame(sort_array({1,0,2,3,4}) , {0, 1, 2, 4, 3}));\n    assert (issame(sort_array({}) , {}));\n    assert (issame(sort_array({2,5,77,4,5,3,5,7,2,3,4}) , {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77}));\n    assert (issame(sort_array({3,6,44,12,32,5}) , {32, 3, 5, 6, 12, 44}));\n    assert (issame(sort_array({2,4,8,16,32}) , {2, 4, 8, 16, 32}));\n    assert (issame(sort_array({2,4,8,16,32}) , {2, 4, 8, 16, 32}));\n}\n", "result": "failed: a.out: test.cpp:50: int main(): Assertion `issame(sort_array({-2,-3,-4,-5,-6}) , {-4, -2, -6, -5, -3})' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/117", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char c : word) {\n        c = tolower(c); // Normalize to lowercase\n        if (isalpha(c) && !strchr(\"aeiou\", c)) { // Check if it's a consonant\n            count++;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(string s, int n) {\n    if (s.empty()) return {};\n\n    vector<string> words;\n    stringstream ss(s);\n    string word;\n\n    // Split the string into words\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    vector<string> result;\n\n    // Filter words based on consonant count\n    for (const string& w : words) {\n        if (count_consonants(w) == n) {\n            result.push_back(w);\n        }\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(select_words(\"Mary had a little lamb\", 4) , {\"little\"}   ));\n    assert (issame(select_words(\"Mary had a little lamb\", 3) , {\"Mary\", \"lamb\"} ));\n    assert (issame(select_words(\"simple white space\", 2) , {}     ));\n    assert (issame(select_words(\"Hello world\", 4) , {\"world\"}  ));\n    assert (issame(select_words(\"Uncle sam\", 3) , {\"Uncle\"}));\n    assert (issame(select_words(\"\", 4) , {}));\n    assert (issame(select_words(\"a b c d e f\", 1) , {\"b\", \"c\", \"d\", \"f\"}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/118", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    string vowels = \"aeiouAEIOU\";\n    int length = word.length();\n\n    // Edge case: if the word is too short to have a vowel between consonants\n    if (length < 3) {\n        return \"\";\n    }\n\n    // Iterate from the end to the beginning of the string\n    for (int i = length - 2; i > 0; --i) {\n        // Check if the current character is a vowel\n        if (vowels.find(word[i]) != string::npos) {\n            // Check if the characters before and after are consonants\n            if (isalpha(word[i - 1]) && isalpha(word[i + 1]) && \n                vowels.find(word[i - 1]) == string::npos && \n                vowels.find(word[i + 1]) == string::npos) {\n                return string(1, word[i]); // Return the vowel found\n            }\n        }\n    }\n\n    return \"\"; // Return empty string if no valid vowel is found\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (get_closest_vowel(\"yogurt\") == \"u\");\n    assert (get_closest_vowel(\"full\") == \"u\");\n    assert (get_closest_vowel(\"easy\") == \"\");\n    assert (get_closest_vowel(\"eAsy\") == \"\");\n    assert (get_closest_vowel(\"ali\") == \"\");\n    assert (get_closest_vowel(\"bad\") == \"a\");\n    assert (get_closest_vowel(\"most\") ==\"o\");\n    assert (get_closest_vowel(\"ab\") == \"\");\n    assert (get_closest_vowel(\"ba\") == \"\");\n    assert (get_closest_vowel(\"quick\") == \"\");\n    assert (get_closest_vowel(\"anime\") == \"i\");\n    assert (get_closest_vowel(\"Asia\") == \"\");\n    assert (get_closest_vowel(\"Above\") == \"o\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/119", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to count open and close parentheses\npair<int, int> count_parentheses(const string& s) {\n    int open = 0, close = 0;\n    for (char c : s) {\n        if (c == '(') open++;\n        else if (c == ')') close++;\n    }\n    return {open, close};\n}\n\n// Helper function to check if a concatenated string is balanced\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') balance++;\n        else if (c == ')') balance--;\n        if (balance < 0) return false; // More closing than opening\n    }\n    return balance == 0; // Must be balanced at the end\n}\n\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0];\n    string s2 = lst[1];\n\n    // Check both concatenation orders\n    if (is_balanced(s1 + s2) || is_balanced(s2 + s1)) {\n        return \"Yes\";\n    }\n    return \"No\";\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (match_parens({\"()(\", \")\"}) == \"Yes\");\n    assert (match_parens({\")\", \")\"}) == \"No\");\n    assert (match_parens({\"(()(())\", \"())())\"}) == \"No\");\n    assert (match_parens({\")())\", \"(()()(\"}) == \"Yes\");\n    assert (match_parens({\"(())))\", \"(()())((\"}) == \"Yes\");\n    assert (match_parens({\"()\", \"())\"}) == \"No\");\n    assert (match_parens({\"(()(\", \"()))()\"}) == \"Yes\");\n    assert (match_parens({\"((((\", \"((())\"}) == \"No\");\n    assert (match_parens({\")(()\", \"(()(\"}) == \"No\");\n    assert (match_parens({\")(\", \")(\"}) == \"No\");\n    assert (match_parens({\"(\", \")\"}) == \"Yes\");\n    assert (match_parens({\")\", \"(\"}) == \"Yes\" );\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/121", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0; // Initialize sum variable\n\n    // Iterate through the vector at even indices\n    for (int i = 0; i < lst.size(); i += 2) {\n        // Check if the element is odd\n        if (lst[i] % 2 != 0) {\n            sum += lst[i]; // Add to sum if odd\n        }\n    }\n\n    // Return the result\n    return sum;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (solution({5, 8, 7, 1})    == 12);\n    assert (solution({3, 3, 3, 3, 3}) == 9);\n    assert (solution({30, 13, 24, 321}) == 0);\n    assert (solution({5, 9}) == 5);\n    assert (solution({2, 4, 8}) == 0);\n    assert (solution({30, 13, 23, 32}) == 23);\n    assert (solution({3, 13, 2, 9}) == 3);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/120", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 2: Input Validation\n    if (k == 0) return {}; // Return empty vector if k is 0\n    if (k > arr.size()) k = arr.size(); // Adjust k if it's greater than the length of arr\n\n    // Step 3: Sort arr in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n\n    // Step 4: Select the top k elements\n    vector<int> top_k(arr.begin(), arr.begin() + k);\n\n    // Step 5: Sort the selected elements in ascending order\n    sort(top_k.begin(), top_k.end());\n\n    // Step 6: Return the result\n    return top_k;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(maximum({-3, -4, 5}, 3) , {-4, -3, 5}));\n    assert (issame(maximum({4, -4, 4}, 2) , {4, 4}));\n    assert (issame(maximum({-3, 2, 1, 2, -1, -2, 1}, 1) , {2}));\n    assert (issame(maximum({123, -123, 20, 0 , 1, 2, -3}, 3) , {2, 20, 123}));\n    assert (issame(maximum({-123, 20, 0 , 1, 2, -3}, 4) , {0, 1, 2, 20}));\n    assert (issame(maximum({5, 15, 0, 3, -13, -8, 0}, 7) , {-13, -8, 0, 0, 3, 5, 15}));\n    assert (issame(maximum({-1, 0, 2, 5, 3, -10}, 2) , {3, 5}));\n    assert (issame(maximum({1, 0, 5, -7}, 1) , {5}));\n    assert (issame(maximum({4, -4}, 2) , {-4, 4}));\n    assert (issame(maximum({-10, 10}, 2) , {-10, 10}));\n    assert (issame(maximum({1, 2, 3, -23, 243, -400, 0}, 0) , {}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/122", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    // Step 1: Validate k\n    if (k < 1 || k > arr.size()) {\n        return 0; // or handle error appropriately\n    }\n\n    // Step 2: Extract first k elements\n    vector<int> first_k_elements(arr.begin(), arr.begin() + k);\n    \n    // Step 3: Initialize sum\n    int sum = 0;\n\n    // Step 4: Filter and sum elements with at most two digits\n    for (int num : first_k_elements) {\n        if (num >= -99 && num <= 99) {\n            sum += num;\n        }\n    }\n\n    // Step 5: Return the result\n    return sum;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (add_elements({1,-2,-3,41,57,76,87,88,99}, 3) == -4);\n    assert (add_elements({111,121,3,4000,5,6}, 2) == 0);\n    assert (add_elements({11,21,3,90,5,6,7,8,9}, 4) == 125);\n    assert (add_elements({111,21,3,4000,5,6,7,8,9}, 4) == 24);\n    assert (add_elements({1}, 1) == 1);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/124", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nbool valid_date(string date) {\n    // Input Validation\n    if (date.empty()) {\n        return false;\n    }\n\n    // Format Validation\n    if (date.size() != 10 || date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n\n    // Extract Month, Day, Year\n    int month, day, year;\n    char dash1, dash2;\n    stringstream ss(date);\n    ss >> month >> dash1 >> day >> dash2 >> year;\n\n    // Check if the extraction was successful\n    if (ss.fail() || dash1 != '-' || dash2 != '-') {\n        return false;\n    }\n\n    // Range Validation\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    if (day < 1) {\n        return false;\n    }\n\n    // Validate days based on month\n    if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && day > 31) {\n        return false;\n    }\n    if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30) {\n        return false;\n    }\n    if (month == 2) {\n        if (day > 29) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (valid_date(\"03-11-2000\") == true);\n    assert (valid_date(\"15-01-2012\") == false);\n    assert (valid_date(\"04-0-2040\") == false);\n    assert (valid_date(\"06-04-2020\") == true);\n    assert (valid_date(\"01-01-2007\") == true);\n    assert (valid_date(\"03-32-2011\") == false);\n    assert (valid_date(\"\") == false);\n    assert (valid_date(\"04-31-3000\") == false);\n    assert (valid_date(\"06-06-2005\") == true);\n    assert (valid_date(\"21-31-2000\") == false);\n    assert (valid_date(\"04-12-2003\") == true);\n    assert (valid_date(\"04122003\") == false);\n    assert (valid_date(\"20030412\") == false);\n    assert (valid_date(\"2003-04\") == false);\n    assert (valid_date(\"2003-04-12\") == false);\n    assert (valid_date(\"04-2003\") == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/123", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> collatz_sequence;\n    int current_term = n;\n\n    // Generate the Collatz sequence\n    while (current_term != 1) {\n        collatz_sequence.push_back(current_term);\n        if (current_term % 2 == 0) {\n            current_term /= 2; // Even case\n        } else {\n            current_term = 3 * current_term + 1; // Odd case\n        }\n    }\n    collatz_sequence.push_back(1); // Add the last term (1)\n\n    // Filter odd numbers\n    vector<int> odd_numbers;\n    for (int num : collatz_sequence) {\n        if (num % 2 != 0) {\n            odd_numbers.push_back(num);\n        }\n    }\n\n    // Sort the odd numbers\n    sort(odd_numbers.begin(), odd_numbers.end());\n\n    // Return the result\n    return odd_numbers;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(get_odd_collatz(14) , {1, 5, 7, 11, 13, 17}));\n    assert (issame(get_odd_collatz(5) , {1, 5}));\n    assert (issame(get_odd_collatz(12) , {1, 3, 5}));\n    assert (issame(get_odd_collatz(1) , {1}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/125", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n\n    // Check for whitespace\n    if (txt.find(' ') != string::npos) {\n        stringstream ss(txt);\n        string word;\n        while (ss >> word) {\n            result.push_back(word);\n        }\n    }\n    // Check for commas\n    else if (txt.find(',') != string::npos) {\n        stringstream ss(txt);\n        string word;\n        while (getline(ss, word, ',')) {\n            result.push_back(word);\n        }\n    }\n    // Count odd-positioned lowercase letters\n    else {\n        int count = 0;\n        for (char c : txt) {\n            if (c >= 'a' && c <= 'z') {\n                int position = c - 'a'; // Get the position in the alphabet\n                if (position % 2 == 1) { // Check if the position is odd\n                    count++;\n                }\n            }\n        }\n        result.push_back(to_string(count)); // Convert count to string and add to result\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(split_words(\"Hello world!\") , {\"Hello\",\"world!\"}));\n    assert (issame(split_words(\"Hello,world!\") , {\"Hello\",\"world!\"}));\n    assert (issame(split_words(\"Hello world,!\") , {\"Hello\",\"world,!\"}));\n    assert (issame(split_words(\"Hello,Hello,world !\") , {\"Hello,Hello,world\",\"!\"}));\n    assert (issame(split_words(\"abcdef\") , {\"3\"}));\n    assert (issame(split_words(\"aaabb\") , {\"2\"}));\n    assert (issame(split_words(\"aaaBb\") , {\"1\"}));\n    assert (issame(split_words(\"\") ,{\"0\"}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/128", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    // Check for empty vector\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    // Initialize variables\n    int sum_magnitudes = 0;\n    int product_signs = 1;\n\n    // Iterate through the vector\n    for (int num : arr) {\n        sum_magnitudes += abs(num); // Calculate magnitude\n\n        if (num > 0) {\n            product_signs *= 1; // Positive sign\n        } else if (num < 0) {\n            product_signs *= -1; // Negative sign\n        } else {\n            product_signs = 0; // Zero encountered\n            break; // Exit loop early\n        }\n    }\n\n    // Calculate final result\n    return sum_magnitudes * product_signs;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (prod_signs({1, 2, 2, -4}) == -9);\n    assert (prod_signs({0, 1}) == 0);\n    assert (prod_signs({1, 1, 1, 2, 3, -1, 1}) == -10);\n    assert (prod_signs({}) == -32768);\n    assert (prod_signs({2, 4,1, 2, -1, -1, 9}) == 20);\n    assert (prod_signs({-1, 1, -1, 1}) == 4);\n    assert (prod_signs({-1, 1, 1, 1}) == -4);\n    assert (prod_signs({-1, 1, 1, 0}) == 0);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/126", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Step 1: Edge case handling\n    if (lst.size() <= 1) return true;\n\n    // Step 2: Count occurrences\n    unordered_map<int, int> countMap;\n    for (int num : lst) {\n        countMap[num]++;\n        if (countMap[num] > 2) return false; // More than twice\n    }\n\n    // Step 3: Check ascending order\n    for (size_t i = 0; i < lst.size() - 1; i++) {\n        if (lst[i] > lst[i + 1]) return false; // Not sorted\n    }\n\n    // Step 4: Return true if all checks passed\n    return true;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_sorted({5}) == true);\n    assert (is_sorted({1, 2, 3, 4, 5}) == true);\n    assert (is_sorted({1, 3, 2, 4, 5}) == false);\n    assert (is_sorted({1, 2, 3, 4, 5, 6}) == true);\n    assert (is_sorted({1, 2, 3, 4, 5, 6, 7}) == true);\n    assert (is_sorted({1, 3, 2, 4, 5, 6, 7}) == false);\n    assert (is_sorted({}) == true);\n    assert (is_sorted({1}) == true);\n    assert (is_sorted({3, 2, 1}) == false);\n    assert (is_sorted({1, 2, 2, 2, 3, 4}) == false);\n    assert (is_sorted({1, 2, 3, 3, 3, 4}) == false);\n    assert (is_sorted({1, 2, 2, 3, 3, 4}) == true);\n    assert (is_sorted({1, 2, 3, 4}) == true);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/127", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    // Input validation\n    if (interval1[0] > interval1[1] || interval2[0] > interval2[1]) {\n        return \"NO\"; // Invalid input\n    }\n\n    // Calculate intersection\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n\n    // Check for intersection\n    if (start > end) {\n        return \"NO\"; // No intersection\n    }\n\n    // Calculate length of intersection\n    int length = end - start + 1;\n\n    // Check if length is prime\n    return isPrime(length) ? \"YES\" : \"NO\";\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (intersection({1, 2}, {2, 3}) == \"NO\");\n    assert (intersection({-1, 1}, {0, 4}) == \"NO\");\n    assert (intersection({-3, -1}, {-5, 5}) == \"YES\");\n    assert (intersection({-2, 2}, {-4, 0}) == \"YES\");\n    assert (intersection({-11, 2}, {-1, -1}) == \"NO\");\n    assert (intersection({1, 2}, {3, 5}) == \"NO\");\n    assert (intersection({1, 2}, {1, 2}) == \"NO\");\n    assert (intersection({-2, -2}, {-3, -2}) == \"NO\");\n}\n", "result": "failed: a.out: test.cpp:54: int main(): Assertion `intersection({-1, 1}, {0, 4}) == \"NO\"' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/131", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint digits(int n) {\n    // Convert integer to string\n    string strN = to_string(n);\n    \n    // Initialize product and flag\n    int product = 1;\n    bool hasOdd = false;\n    \n    // Iterate over each character in the string\n    for (char c : strN) {\n        int digit = c - '0'; // Convert char to int\n        if (digit % 2 != 0) { // Check if odd\n            product *= digit; // Multiply to product\n            hasOdd = true; // Mark that we found an odd digit\n        }\n    }\n    \n    // Return result\n    return hasOdd ? product : 0; // Return product or 0\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (digits(5) == 5);\n    assert (digits(54) == 5);\n    assert (digits(120) ==1);\n    assert (digits(5014) == 5);\n    assert (digits(98765) == 315);\n    assert (digits(5576543) == 2625);\n    assert (digits(2468) == 0);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/130", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint computeTri(int n, vector<int>& memo) {\n    if (memo[n] != -1) return memo[n]; // Return cached value\n    if (n == 1) return memo[n] = 3; // Base case\n    if (n == 0) return memo[n] = 1; // Base case\n    if (n == 2) return memo[n] = 2; // Base case\n\n    if (n % 2 == 0) {\n        return memo[n] = 1 + n / 2; // Even case\n    } else {\n        return memo[n] = computeTri(n - 1, memo) + computeTri(n - 2, memo) + computeTri(n + 1, memo); // Odd case\n    }\n}\n\nvector<int> tri(int n) {\n    vector<int> memo(n + 1, -1); // Initialize memoization vector\n    vector<int> result(n + 1); // Result vector\n    for (int i = 0; i <= n; ++i) {\n        result[i] = computeTri(i, memo); // Compute and store results\n    }\n    return result; // Return the result vector\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(tri(3) , {1, 3, 2, 8}));\n    assert (issame(tri(4) , {1, 3, 2, 8, 3}));\n    assert (issame(tri(5) , {1, 3, 2, 8, 3, 15}));\n    assert (issame(tri(6) , {1, 3, 2, 8, 3, 15, 4}));\n    assert (issame(tri(7) , {1, 3, 2, 8, 3, 15, 4, 24}));\n    assert (issame(tri(8) , {1, 3, 2, 8, 3, 15, 4, 24, 5}));\n    assert (issame(tri(9) , {1, 3, 2, 8, 3, 15, 4, 24, 5, 35}));\n    assert (issame(tri(20) , {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11}));\n    assert (issame(tri(0) , {1}));\n    assert (issame(tri(1) , {1, 3}));\n}\n", "result": "failed: a.out: test.cpp:53: int main(): Assertion `issame(tri(3) , {1, 3, 2, 8})' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/132", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int open_count = 0;\n    int close_count = 0;\n    bool has_nested = false;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            open_count++;\n            if (open_count > 1) {\n                has_nested = true; // Found potential nesting\n            }\n        } else if (ch == ']') {\n            close_count++;\n        }\n\n        // If closing brackets exceed opening brackets, return false\n        if (close_count > open_count) {\n            return false;\n        }\n    }\n\n    // Check if the counts are balanced and if nesting was found\n    return (open_count == close_count) && has_nested;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_nested(\"[[]]\") == true);\n    assert (is_nested(\"[]]]]]]][[[[[]\") == false);\n    assert (is_nested(\"[][]\") == false);\n    assert (is_nested((\"[]\")) == false);\n    assert (is_nested(\"[[[[]]]]\") == true);\n    assert (is_nested(\"[]]]]]]]]]]\") == false);\n    assert (is_nested(\"[][][[]]\") == true);\n    assert (is_nested(\"[[]\") == false);\n    assert (is_nested(\"[]]\") == false);\n    assert (is_nested(\"[[]][[\") == true);\n    assert (is_nested(\"[[][]]\") == true);\n    assert (is_nested(\"\") == false);\n    assert (is_nested(\"[[[[[[[[\") == false);\n    assert (is_nested(\"]]]]]]]]\") == false);\n}\n", "result": "failed: a.out: test.cpp:50: int main(): Assertion `is_nested(\"[][]\") == false' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/133", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0; // Initialize sum variable\n\n    // Iterate through the vector\n    for (float num : lst) {\n        // Round each element\n        int rounded_num = ceil(num);\n        \n        // Square the rounded value\n        int squared_value = rounded_num * rounded_num;\n        \n        // Accumulate the sum\n        sum += squared_value;\n    }\n\n    // Return the result\n    return sum;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sum_squares({1,2,3})==14);\n    assert (sum_squares({1.0,2,3})==14);\n    assert (sum_squares({1,3,5,7})==84);\n    assert (sum_squares({1.4,4.2,0})==29);\n    assert (sum_squares({-2.4,1,1})==6);\n    assert (sum_squares({100,1,15,2})==10230);\n    assert (sum_squares({10000,10000})==200000000);\n    assert (sum_squares({-1.4,4.6,6.3})==75);\n    assert (sum_squares({-1.4,17.9,18.9,19.9})==1086);\n    assert (sum_squares({0})==0);\n    assert (sum_squares({-1})==1);\n    assert (sum_squares({-1,1,0})==2);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/135", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int largestIndex = -1; // Initialize largestIndex\n\n    // Iterate through the vector\n    for (int i = 1; i < arr.size(); i++) {\n        // Check condition\n        if (arr[i] < arr[i - 1]) {\n            largestIndex = i; // Update largestIndex\n        }\n    }\n\n    // Return the result\n    return largestIndex; // Return the largest index found or -1\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (can_arrange({1,2,4,3,5})==3);\n    assert (can_arrange({1,2,4,5})==-1);\n    assert (can_arrange({1,4,2,5,6,7,8,9,10})==2);\n    assert (can_arrange({4,8,5,7,3})==4);\n    assert (can_arrange({})==-1);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/136", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <limits.h> // For INT_MIN and INT_MAX\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = INT_MIN; // Initialize to minimum possible integer\n    int smallest_positive = INT_MAX; // Initialize to maximum possible integer\n\n    for (int num : lst) {\n        if (num < 0) {\n            if (num > largest_negative) {\n                largest_negative = num; // Update largest negative\n            }\n        } else if (num > 0) {\n            if (num < smallest_positive) {\n                smallest_positive = num; // Update smallest positive\n            }\n        }\n    }\n\n    // Handle edge cases\n    if (largest_negative == INT_MIN) {\n        largest_negative = 0; // No negative integers found\n    }\n    if (smallest_positive == INT_MAX) {\n        smallest_positive = 0; // No positive integers found\n    }\n\n    return {largest_negative, smallest_positive}; // Return the result\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(largest_smallest_integers({2, 4, 1, 3, 5, 7}) , {0, 1}));\n    assert (issame(largest_smallest_integers({2, 4, 1, 3, 5, 7, 0}) , {0, 1}));\n    assert (issame(largest_smallest_integers({1, 3, 2, 4, 5, 6, -2}) , {-2, 1}));\n    assert (issame(largest_smallest_integers({4, 5, 3, 6, 2, 7, -7}) , {-7, 2}));\n    assert (issame(largest_smallest_integers({7, 3, 8, 4, 9, 2, 5, -9}) , {-9, 2}));\n    assert (issame(largest_smallest_integers({}) , {0, 0}));\n    assert (issame(largest_smallest_integers({0}) , {0, 0}));\n    assert (issame(largest_smallest_integers({-1, -3, -5, -6}) , {-1, 0}));\n    assert (issame(largest_smallest_integers({-1, -3, -5, -6, 0}) , {-1, 0}));\n    assert (issame(largest_smallest_integers({-6, -4, -4, -3, 1}) , {-3, 1}));\n    assert (issame(largest_smallest_integers({-6, -4, -4, -3, -100, 1}) , {-3, 1}));\n\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/134", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Step 2: Trim the string\n    size_t end = txt.find_last_not_of(' ');\n    if (end == string::npos) return false; // Step 3: Check for empty string\n    txt = txt.substr(0, end + 1); // Trimmed string\n\n    // Step 4: Extract the last character\n    char lastChar = txt.back();\n\n    // Step 5: Check if last character is alphabetical\n    if (!isalpha(lastChar)) return false;\n\n    // Step 6: Check if last character is part of a word\n    if (txt.size() > 1 && txt[end - 1] != ' ') return false;\n\n    // Step 7: Return the result\n    return true;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (check_if_last_char_is_a_letter(\"apple\") == false);\n    assert (check_if_last_char_is_a_letter(\"apple pi e\") == true);\n    assert (check_if_last_char_is_a_letter(\"eeeee\") == false);\n    assert (check_if_last_char_is_a_letter(\"A\") == true);\n    assert (check_if_last_char_is_a_letter(\"Pumpkin pie \") == false);\n    assert (check_if_last_char_is_a_letter(\"Pumpkin pie 1\") == false);\n    assert (check_if_last_char_is_a_letter(\"\") == false);\n    assert (check_if_last_char_is_a_letter(\"eeeee e \") == false);\n    assert (check_if_last_char_is_a_letter(\"apple pie\") == false);\n    assert (check_if_last_char_is_a_letter(\"apple pi e \") == false);\n}\n", "result": "failed: a.out: test.cpp:51: int main(): Assertion `check_if_last_char_is_a_letter(\"eeeee e \") == false' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/129", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int N = grid.size();\n    vector<int> min_path;\n\n    // Directions for moving up, down, left, right\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    // Helper function for DFS\n    function<void(int, int, int, vector<int>&)> dfs = [&](int x, int y, int depth, vector<int>& current_path) {\n        if (depth == k) {\n            if (min_path.empty() || current_path < min_path) {\n                min_path = current_path;\n            }\n            return;\n        }\n\n        for (auto& dir : directions) {\n            int new_x = x + dir.first;\n            int new_y = y + dir.second;\n            if (new_x >= 0 && new_x < N && new_y >= 0 && new_y < N) {\n                current_path.push_back(grid[new_x][new_y]);\n                dfs(new_x, new_y, depth + 1, current_path);\n                current_path.pop_back(); // backtrack\n            }\n        }\n    };\n\n    // Validate the grid\n    unordered_set<int> unique_values;\n    for (const auto& row : grid) {\n        for (int value : row) {\n            if (value < 1 || value > N * N || !unique_values.insert(value).second) {\n                throw invalid_argument(\"Grid must contain unique integers from 1 to N*N.\");\n            }\n        }\n    }\n\n    // Start DFS from each cell\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            vector<int> current_path = {grid[i][j]};\n            dfs(i, j, 1, current_path);\n        }\n    }\n\n    return min_path;\n}\n\n// Example usage\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(minPath({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3) , {1, 2, 1}));\n    assert (issame(minPath({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1) , {1}));\n    assert (issame(minPath({{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}}, 4) , {1, 2, 1, 2}));\n    assert (issame(minPath({{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}}, 7) , {1, 10, 1, 10, 1, 10, 1}));\n    assert (issame(minPath({{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}}, 5) , {1, 7, 1, 7, 1}));\n    assert (issame(minPath({{11, 8, 7, 2}, {5, 16, 14, 4}, {9, 3, 15, 6}, {12, 13, 10, 1}}, 9) , {1, 6, 1, 6, 1, 6, 1, 6, 1}));\n    assert (issame(minPath({{12, 13, 10, 1}, {9, 3, 15, 6}, {5, 16, 14, 4}, {11, 8, 7, 2}}, 12) , {1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6}));\n    assert (issame(minPath({{2, 7, 4}, {3, 1, 5}, {6, 8, 9}}, 8) , {1, 3, 1, 3, 1, 3, 1, 3}));\n    assert (issame(minPath({{6, 1, 5}, {3, 8, 9}, {2, 7, 4}}, 8) , {1, 5, 1, 5, 1, 5, 1, 5}));\n    assert (issame(minPath({{1, 2}, {3, 4}}, 10) , {1, 2, 1, 2, 1, 2, 1, 2, 1, 2}));\n    assert (issame(minPath({{1, 3}, {3, 2}}, 10) , {1, 3, 1, 3, 1, 3, 1, 3, 1, 3}));\n}\n", "result": "failed: terminate called after throwing an instance of 'std::invalid_argument'\n  what():  Grid must contain unique integers from 1 to N*N.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/139", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\nusing namespace std;\n\n// Helper function to calculate factorial\nlong long factorial(int k) {\n    if (k == 0) return 1;\n    long long result = 1;\n    for (int i = 1; i <= k; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Main function to calculate Brazilian factorial\nlong long special_factorial(int n) {\n    if (n <= 0) {\n        // Handle invalid input\n        return 0; // or throw an exception\n    }\n    \n    long long result = 1;\n    for (int i = n; i >= 1; --i) {\n        result *= factorial(i);\n    }\n    \n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (special_factorial(4) == 288);\n    assert (special_factorial(5) == 34560);\n    assert (special_factorial(7) == 125411328000);\n    assert (special_factorial(1) == 1);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/138", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Step 1: Check for minimum value\n    if (n < 8) return false;\n\n    // Step 2: Check for parity\n    if (n % 2 != 0) return false;\n\n    // Step 3: Calculate n / 2\n    int half_n = n / 2;\n\n    // Step 4: Check if half_n - 4 is non-negative\n    return (half_n - 4) >= 0;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (is_equal_to_sum_even(4) == false);\n    assert (is_equal_to_sum_even(6) == false);\n    assert (is_equal_to_sum_even(8) == true);\n    assert (is_equal_to_sum_even(10) == true);\n    assert (is_equal_to_sum_even(11) == false);\n    assert (is_equal_to_sum_even(12) == true);\n    assert (is_equal_to_sum_even(13) == false);\n    assert (is_equal_to_sum_even(16) == true);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/140", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int space_count = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n        } else {\n            if (space_count > 0) {\n                if (space_count == 1) {\n                    result += '_'; // Replace single space with underscore\n                } else {\n                    result += '-'; // Replace more than 2 spaces with hyphen\n                }\n                space_count = 0; // Reset space count\n            }\n            result += c; // Append the non-space character\n        }\n    }\n\n    // Handle trailing spaces\n    if (space_count > 0) {\n        if (space_count == 1) {\n            result += '_';\n        } else {\n            result += '-';\n        }\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (fix_spaces(\"Example\") == \"Example\");\n    assert (fix_spaces(\"Mudasir Hanif \") == \"Mudasir_Hanif_\");\n    assert (fix_spaces(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\");\n    assert (fix_spaces(\"Exa   mple\") == \"Exa-mple\");\n    assert (fix_spaces(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\");\n}\n", "result": "failed: a.out: test.cpp:57: int main(): Assertion `fix_spaces(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\"' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/137", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n#include <sstream>\n#include <locale>\n\nusing namespace std;\n\ndouble convert_to_double(const string& str) {\n    string normalized = str;\n    replace(normalized.begin(), normalized.end(), ',', '.'); // Replace ',' with '.'\n    return stod(normalized); // Convert to double\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    double numA, numB;\n    bool isAString = false, isBString = false;\n\n    // Determine the type of 'a'\n    try {\n        numA = boost::any_cast<int>(a);\n    } catch (const boost::bad_any_cast&) {\n        try {\n            numA = boost::any_cast<float>(a);\n        } catch (const boost::bad_any_cast&) {\n            isAString = true;\n            string strA = boost::any_cast<string>(a);\n            numA = convert_to_double(strA);\n        }\n    }\n\n    // Determine the type of 'b'\n    try {\n        numB = boost::any_cast<int>(b);\n    } catch (const boost::bad_any_cast&) {\n        try {\n            numB = boost::any_cast<float>(b);\n        } catch (const boost::bad_any_cast&) {\n            isBString = true;\n            string strB = boost::any_cast<string>(b);\n            numB = convert_to_double(strB);\n        }\n    }\n\n    // Comparison logic\n    if (isAString && isBString) {\n        if (numA == numB) return \"None\";\n        return (numA > numB) ? b : a;\n    } else if (isAString) {\n        return (numA == numB) ? \"None\" : (numA > numB ? b : a);\n    } else if (isBString) {\n        return (numA == numB) ? \"None\" : (numA > numB ? b : a);\n    } else {\n        if (numA == numB) return \"None\";\n        return (numA > numB) ? a : b;\n    }\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (boost::any_cast<int>(compare_one(1, 2)) == 2);\n    assert (boost::any_cast<double>(compare_one(1, 2.5))== 2.5);\n    assert (boost::any_cast<int>(compare_one(2, 3)) == 3);\n    assert (boost::any_cast<int>(compare_one(5, 6)) == 6);\n    assert (boost::any_cast<string>(compare_one(1, string(\"2,3\")))== \"2,3\");\n    assert (boost::any_cast<string>(compare_one(string(\"5,1\"), string(\"6\"))) == \"6\");\n    assert (boost::any_cast<string>(compare_one(string(\"1\"), string(\"2\"))) == \"2\");\n    assert (boost::any_cast<string>(compare_one(string(\"1\"), 1)) == \"None\");\n}\n", "result": "failed: terminate called after throwing an instance of 'boost::wrapexcept<boost::bad_any_cast>'\n  what():  boost::bad_any_cast: failed conversion using boost::any_cast\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/141", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    int dot_count = 0;\n    int digit_count = 0;\n    size_t dot_position = string::npos;\n\n    // Step 2: Find the dot and count digits\n    for (size_t i = 0; i < file_name.length(); ++i) {\n        if (file_name[i] == '.') {\n            dot_count++;\n            dot_position = i;\n        } else if (isdigit(file_name[i])) {\n            digit_count++;\n        }\n    }\n\n    // Step 3: Check for exactly one dot\n    if (dot_count != 1) return \"No\";\n\n    // Step 4: Extract substrings\n    string before_dot = file_name.substr(0, dot_position);\n    string after_dot = file_name.substr(dot_position + 1);\n\n    // Step 5: Validate the substring before the dot\n    if (before_dot.empty() || !isalpha(before_dot[0])) return \"No\";\n\n    // Step 6: Check digit count\n    if (digit_count > 3) return \"No\";\n\n    // Step 7: Validate the substring after the dot\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\") return \"No\";\n\n    // Step 8: All checks passed\n    return \"Yes\";\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (file_name_check(\"example.txt\") == \"Yes\");\n    assert (file_name_check(\"1example.dll\") == \"No\");\n    assert (file_name_check(\"s1sdf3.asd\") == \"No\");\n    assert (file_name_check(\"K.dll\") == \"Yes\");\n    assert (file_name_check(\"MY16FILE3.exe\") == \"Yes\");\n    assert (file_name_check(\"His12FILE94.exe\") == \"No\");\n    assert (file_name_check(\"_Y.txt\") == \"No\");\n    assert (file_name_check(\"?aREYA.exe\") == \"No\");\n    assert (file_name_check(\"/this_is_valid.dll\") == \"No\");\n    assert (file_name_check(\"this_is_valid.wow\") == \"No\");\n    assert (file_name_check(\"this_is_valid.txt\") == \"Yes\");\n    assert (file_name_check(\"this_is_valid.txtexe\") == \"No\");\n    assert (file_name_check(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert (file_name_check(\"@this1_is6_valid.exe\") == \"No\");\n    assert (file_name_check(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert (file_name_check(\"all.exe.txt\") == \"No\");\n    assert (file_name_check(\"I563_No.exe\") == \"Yes\");\n    assert (file_name_check(\"Is3youfault.txt\") == \"Yes\");\n    assert (file_name_check(\"no_one#knows.dll\") == \"Yes\");\n    assert (file_name_check(\"1I563_Yes3.exe\") == \"No\");\n    assert (file_name_check(\"I563_Yes3.txtt\") == \"No\");\n    assert (file_name_check(\"final..txt\") == \"No\");\n    assert (file_name_check(\"final132\") == \"No\");\n    assert (file_name_check(\"_f4indsartal132.\") == \"No\");\n    assert (file_name_check(\".txt\") == \"No\");\n    assert (file_name_check(\"s.\") == \"No\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/142", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;  // Initialize sum\n\n    // Iterate through the vector\n    for (size_t i = 0; i < lst.size(); i++) {\n        // Evaluate each index\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];  // Square if index is multiple of 3\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];  // Cube if index is multiple of 4 (not multiple of 3)\n        } else {\n            sum += lst[i];  // Leave unchanged\n        }\n    }\n\n    // Return the sum\n    return sum;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (sum_squares({1,2,3}) == 6);\n    assert (sum_squares({1,4,9}) == 14);\n    assert (sum_squares({}) == 0);\n    assert (sum_squares({1,1,1,1,1,1,1,1,1}) == 9);\n    assert (sum_squares({-1,-1,-1,-1,-1,-1,-1,-1,-1}) == -3);\n    assert (sum_squares({0}) == 0);\n    assert (sum_squares({-1,-5,2,-1,-5}) == -126);\n    assert (sum_squares({-56,-99,1,0,-2}) == 3030);\n    assert (sum_squares({-1,0,0,0,0,0,0,0,-1}) == 0);\n    assert (sum_squares({-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37}) == -14196);\n    assert (sum_squares({-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10}) == -1448);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/143", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to extract words with prime lengths\nstring words_in_sentence(string sentence) {\n    vector<string> words;\n    stringstream ss(sentence);\n    string word;\n\n    // Split the sentence into words\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    // Filter words with prime lengths\n    vector<string> prime_length_words;\n    for (const string& w : words) {\n        if (is_prime(w.length())) {\n            prime_length_words.push_back(w);\n        }\n    }\n\n    // Construct the output string\n    string result;\n    for (const string& w : prime_length_words) {\n        if (!result.empty()) {\n            result += \" \"; // Add space between words\n        }\n        result += w;\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (words_in_sentence(\"This is a test\") == \"is\");\n    assert (words_in_sentence(\"lets go for swimming\") == \"go for\");\n    assert (words_in_sentence(\"there is no place available here\") == \"there is no place\");\n    assert (words_in_sentence(\"Hi I am Hussein\") == \"Hi am Hussein\");\n    assert (words_in_sentence(\"go for it\") == \"go for it\");\n    assert (words_in_sentence(\"here\") == \"\");\n    assert (words_in_sentence(\"here is\") == \"is\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/144", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Step 2: Parse the fractions\n    int numerator_x, denominator_x, numerator_n, denominator_n;\n    \n    // Parse x\n    size_t pos = x.find('/');\n    numerator_x = stoi(x.substr(0, pos));\n    denominator_x = stoi(x.substr(pos + 1));\n    \n    // Parse n\n    pos = n.find('/');\n    numerator_n = stoi(n.substr(0, pos));\n    denominator_n = stoi(n.substr(pos + 1));\n    \n    // Step 3: Calculate the product\n    int numerator_product = numerator_x * numerator_n;\n    int denominator_product = denominator_x * denominator_n;\n    \n    // Step 4: Check if the product is a whole number\n    return (numerator_product % denominator_product == 0);\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (simplify(\"1/5\", \"5/1\") == true);\n    assert (simplify(\"1/6\", \"2/1\") == false);\n    assert (simplify(\"5/1\", \"3/1\") == true);\n    assert (simplify(\"7/10\", \"10/2\") == false);\n    assert (simplify(\"2/10\", \"50/10\") == true);\n    assert (simplify(\"7/2\", \"4/2\") == true);\n    assert (simplify(\"11/6\", \"6/1\") == true);\n    assert (simplify(\"2/3\", \"5/2\") == false);\n    assert (simplify(\"5/2\", \"3/5\") == false);\n    assert (simplify(\"2/4\", \"8/4\") == true);\n    assert (simplify(\"2/4\", \"4/2\") == true);\n    assert (simplify(\"1/5\", \"5/1\") == true);\n    assert (simplify(\"1/5\", \"1/5\") == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/146", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n// Helper function to check if a digit is odd\nbool isOdd(int digit) {\n    return (digit % 2 != 0);\n}\n\n// Helper function to get the first and last digits of a number\npair<int, int> getFirstAndLastDigits(int num) {\n    int lastDigit = abs(num) % 10; // Last digit\n    while (num >= 10) {\n        num /= 10; // Reduce the number to get the first digit\n    }\n    int firstDigit = abs(num); // First digit\n    return make_pair(firstDigit, lastDigit);\n}\n\n// Main function to filter numbers\nint specialFilter(vector<int> nums) {\n    int count = 0; // Counter for valid numbers\n    for (int num : nums) {\n        if (num > 10) { // Check if greater than 10\n            auto [firstDigit, lastDigit] = getFirstAndLastDigits(num);\n            if (isOdd(firstDigit) && isOdd(lastDigit)) { // Check if both digits are odd\n                count++; // Increment count\n            }\n        }\n    }\n    return count; // Return the final count\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (specialFilter({5, -2, 1, -5}) == 0  );\n    assert (specialFilter({15, -73, 14, -15}) == 1);\n    assert (specialFilter({33, -2, -3, 45, 21, 109}) == 2);\n    assert (specialFilter({43, -12, 93, 125, 121, 109}) == 4);\n    assert (specialFilter({71, -2, -33, 75, 21, 19}) == 3);\n    assert (specialFilter({1}) == 0              );\n    assert (specialFilter({}) == 0                   );\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/145", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility> // for std::pair\n\nusing namespace std;\n\n// Helper function to calculate the sum of digits\nint sum_of_digits(int num) {\n    int sum = 0;\n    num = abs(num); // Work with absolute value for digit sum\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Main function to order by points\nvector<int> order_by_points(vector<int> nums) {\n    vector<pair<int, int>> indexed_nums; // Pair of (number, original index)\n\n    // Populate the pairing structure\n    for (int i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back(make_pair(nums[i], i));\n    }\n\n    // Sort based on the sum of digits and original index\n    sort(indexed_nums.begin(), indexed_nums.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        int sum_a = sum_of_digits(a.first);\n        int sum_b = sum_of_digits(b.first);\n        if (sum_a == sum_b) {\n            return a.second < b.second; // Sort by index if sums are equal\n        }\n        return sum_a < sum_b; // Sort by sum of digits\n    });\n\n    // Extract sorted values\n    vector<int> sorted_nums;\n    for (const auto& p : indexed_nums) {\n        sorted_nums.push_back(p.first);\n    }\n\n    return sorted_nums;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(order_by_points({1, 11, -1, -11, -12}) , {-1, -11, 1, -12, 11}));\n    assert (issame(order_by_points({1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46}) , {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457}));\n    assert (issame(order_by_points({}) , {}));\n    assert (issame(order_by_points({1, -11, -32, 43, 54, -98, 2, -3}) , {-3, -32, -98, -11, 1, 2, 43, 54}));\n    assert (issame(order_by_points({1,2,3,4,5,6,7,8,9,10,11}) , {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9}));\n    assert (issame(order_by_points({0,6,6,-76,-21,23,4}) , {-76, -21, 0, 4, 23, 6, 6}));\n    \n}\n", "result": "failed: a.out: test.cpp:72: int main(): Assertion `issame(order_by_points({1, 11, -1, -11, -12}) , {-1, -11, 1, -12, 11})' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/147", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    // Generate vector a\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    // Count occurrences of each modulo\n    int modCount[3] = {0, 0, 0};\n    for (int i = 0; i < n; ++i) {\n        modCount[a[i] % 3]++;\n    }\n\n    // Calculate valid triples\n    int count = 0;\n\n    // Count triples of the same mod\n    for (int i = 0; i < 3; ++i) {\n        if (modCount[i] >= 3) {\n            count += (modCount[i] * (modCount[i] - 1) * (modCount[i] - 2)) / 6;\n        }\n    }\n\n    // Count triples of different mods\n    count += modCount[0] * modCount[1] * modCount[2];\n\n    // Return the result\n    return count;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (get_max_triples(5) == 1);\n    assert (get_max_triples(6) == 4);\n    assert (get_max_triples(10) == 36);\n    assert (get_max_triples(100) == 53361);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/150", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <cmath>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n < 2) return false; // Numbers less than 2 are not prime\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Main function to return x or y based on the primality of n\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x; // n is prime\n    } else {\n        return y; // n is not prime\n    }\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (x_or_y(7, 34, 12) == 34);\n    assert (x_or_y(15, 8, 5) == 5);\n    assert (x_or_y(3, 33, 5212) == 33);\n    assert (x_or_y(1259, 3, 52) == 3);\n    assert (x_or_y(7919, -1, 12) == -1);\n    assert (x_or_y(3609, 1245, 583) == 583);\n    assert (x_or_y(91, 56, 129) == 129);\n    assert (x_or_y(6, 34, 1234) == 1234);\n    assert (x_or_y(1, 2, 0) == 0);\n    assert (x_or_y(2, 2, 0) == 2);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/148", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\n    // Input validation\n    if (find(planets.begin(), planets.end(), planet1) == planets.end() || \n        find(planets.begin(), planets.end(), planet2) == planets.end()) {\n        return {};\n    }\n\n    // Determine positions\n    int pos1 = find(planets.begin(), planets.end(), planet1) - planets.begin();\n    int pos2 = find(planets.begin(), planets.end(), planet2) - planets.begin();\n\n    // Identify the range\n    int start = min(pos1, pos2) + 1; // Start after planet1\n    int end = max(pos1, pos2); // End at planet2\n\n    // Collect and return the result\n    vector<string> result;\n    for (int i = start; i < end; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(bf(\"Jupiter\", \"Neptune\") , {\"Saturn\", \"Uranus\"}));\n    assert (issame(bf(\"Earth\", \"Mercury\") , {\"Venus\",}));\n    assert (issame(bf(\"Mercury\", \"Uranus\") , {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}));\n    assert (issame(bf(\"Neptune\", \"Venus\") , {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"}));\n    assert (issame(bf(\"Earth\", \"Earth\") , {}));\n    assert (issame(bf(\"Mars\", \"Earth\") , {}));\n    assert (issame(bf(\"Jupiter\", \"Makemake\") , {}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/152", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    // Step 2: Input Validation\n    if (game.size() != guess.size()) {\n        return {}; // Return an empty vector if sizes do not match\n    }\n\n    // Step 3: Initialize Result Vector\n    vector<int> result(game.size());\n\n    // Step 4: Iterate and Calculate Differences\n    for (size_t i = 0; i < game.size(); ++i) {\n        result[i] = abs(game[i] - guess[i]); // Calculate absolute difference\n    }\n\n    // Step 5: Return the Result\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(compare({1,2,3,4,5,1},{1,2,3,4,2,-2}),{0,0,0,0,3,3}));\n    assert (issame(compare({0,5,0,0,0,4},{4,1,1,0,0,-2}),{4,4,1,0,0,6}));\n    assert (issame(compare({1,2,3,4,5,1},{1,2,3,4,2,-2}),{0,0,0,0,3,3}));\n    assert (issame(compare({0,0,0,0,0,0},{0,0,0,0,0,0}),{0,0,0,0,0,0}));\n    assert (issame(compare({1,2,3},{-1,-2,-3}),{2,4,6}));\n    assert (issame(compare({1,2,3,5},{-1,2,3,4}),{2,0,0,1}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/151", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    // Check for empty vector\n    if (lst.empty()) {\n        return 0;\n    }\n\n    // Initialize sum of squares\n    long long sum_of_squares = 0;\n\n    // Iterate through the vector\n    for (float num : lst) {\n        // Filter and process each element\n        if (num >= 0 && floor(num) == num) { // Check for non-negative integer\n            int int_num = static_cast<int>(num); // Convert to integer\n            if (int_num % 2 != 0) { // Check if odd\n                sum_of_squares += int_num * int_num; // Calculate square and add to sum\n            }\n        }\n    }\n\n    // Return the sum\n    return sum_of_squares;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (double_the_difference({}) == 0);\n    assert (double_the_difference({5, 4}) == 25);\n    assert (double_the_difference({0.1, 0.2, 0.3}) == 0 );\n    assert (double_the_difference({-10, -20, -30}) == 0 );\n    assert (double_the_difference({-1, -2, 8}) == 0);\n    assert (double_the_difference({0.2, 3, 5}) == 34);\n    \n    \n    long long odd_sum=0;\n    vector<float> lst={};\n\n    for (int i=-99;i<100;i+=2)\n    {\n        lst.push_back(i+0.0);\n        if (i>0 and i%2==1) odd_sum+=i*i;\n    }\n  \n    assert (double_the_difference(lst) == odd_sum );\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/149", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Step 3: Filtering\n    vector<string> filtered;\n    for (const auto& str : lst) {\n        if (str.length() % 2 == 0) { // Check for even length\n            filtered.push_back(str);\n        }\n    }\n\n    // Step 4: Sorting\n    sort(filtered.begin(), filtered.end(), [](const string &a, const string &b) {\n        if (a.length() == b.length()) {\n            return a < b; // Alphabetical order if lengths are equal\n        }\n        return a.length() < b.length(); // Sort by length\n    });\n\n    // Step 5: Return the result\n    return filtered;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sorted_list_sum({\"aa\", \"a\", \"aaa\"}) , {\"aa\"}));\n    assert (issame(sorted_list_sum({\"school\", \"AI\", \"asdf\", \"b\"}) , {\"AI\", \"asdf\", \"school\"}));\n    assert (issame(sorted_list_sum({\"d\", \"b\", \"c\", \"a\"}) , {}));\n    assert (issame(sorted_list_sum({\"d\", \"dcba\", \"abcd\", \"a\"}) , {\"abcd\", \"dcba\"}));\n    assert (issame(sorted_list_sum({\"AI\", \"ai\", \"au\"}) , {\"AI\", \"ai\", \"au\"}));\n    assert (issame(sorted_list_sum({\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"}) , {}));\n    assert (issame(sorted_list_sum({\"aaaa\", \"bbbb\", \"dd\", \"cc\"}) , {\"cc\", \"dd\", \"aaaa\", \"bbbb\"}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/154", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n// Function to generate all rotations of a string\nvector<string> generateRotations(const string& b) {\n    vector<string> rotations;\n    int n = b.length();\n    for (int i = 0; i < n; ++i) {\n        rotations.push_back(b.substr(i) + b.substr(0, i)); // Create rotation\n    }\n    return rotations;\n}\n\n// Function to check if 'b' is a substring of 'a'\nbool isSubstring(const string& a, const string& b) {\n    return a.find(b) != string::npos; // Check for substring\n}\n\n// Main function to check cyclical pattern\nbool cycpattern_check(string a, string b) {\n    // Step 1: Input validation\n    if (a.empty() || b.empty()) {\n        return false;\n    }\n\n    // Step 2: Generate rotations of b\n    vector<string> rotations = generateRotations(b);\n\n    // Step 3: Check each rotation against a\n    for (const string& rotation : rotations) {\n        if (isSubstring(a, rotation)) {\n            return true; // Found a rotation as substring\n        }\n    }\n\n    // Step 4: No rotations matched\n    return false;\n}\n\n// Example usage\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert  (cycpattern_check(\"xyzw\",\"xyw\") == false );\n    assert  (cycpattern_check(\"yello\",\"ell\") == true );\n    assert  (cycpattern_check(\"whattup\",\"ptut\") == false );\n    assert  (cycpattern_check(\"efef\",\"fee\") == true );\n    assert  (cycpattern_check(\"abab\",\"aabb\") == false );\n    assert  (cycpattern_check(\"winemtt\",\"tinem\") == true );\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/153", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cctype> // for isupper and islower functions\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = -1; // Initialize to a value lower than any possible strength\n    string strongest_extension = \"\";\n\n    for (const string& ext : extensions) {\n        int CAP = 0, SM = 0;\n\n        // Count uppercase and lowercase letters\n        for (char c : ext) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n\n        // Calculate strength\n        int strength = CAP - SM;\n\n        // Update strongest extension if necessary\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    // Construct and return the result\n    return class_name + \".\" + strongest_extension;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (Strongest_Extension(\"Watashi\", {\"tEN\", \"niNE\", \"eIGHt8OKe\"}) == \"Watashi.eIGHt8OKe\");\n    assert (Strongest_Extension(\"Boku123\", {\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}) == \"Boku123.YEs.WeCaNe\");\n    assert (Strongest_Extension(\"__YESIMHERE\", {\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}) == \"__YESIMHERE.NuLl__\");\n    assert (Strongest_Extension(\"K\", {\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}) == \"K.TAR\");\n    assert (Strongest_Extension(\"__HAHA\", {\"Tab\", \"123\", \"781345\", \"-_-\"}) == \"__HAHA.123\");\n    assert (Strongest_Extension(\"YameRore\", {\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}) == \"YameRore.okIWILL123\");\n    assert (Strongest_Extension(\"finNNalLLly\", {\"Die\", \"NowW\", \"Wow\", \"WoW\"}) == \"finNNalLLly.WoW\");\n    assert (Strongest_Extension(\"_\", {\"Bb\", \"91245\"}) == \"_.Bb\");\n    assert (Strongest_Extension(\"Sp\", {\"671235\", \"Bb\"}) == \"Sp.671235\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/156", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define Roman numeral mapping\n    vector<pair<int, string>> roman_map = {\n        {1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"},\n        {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"},\n        {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"},\n        {1, \"I\"}\n    };\n\n    // Input validation\n    if (number < 1 || number > 1000) {\n        return \"\"; // or handle error\n    }\n\n    // Conversion logic\n    string result = \"\";\n    for (const auto& pair : roman_map) {\n        while (number >= pair.first) {\n            result += pair.second; // Append Roman numeral\n            number -= pair.first;   // Subtract value\n        }\n    }\n\n    // Convert to lowercase\n    for (auto &c : result) {\n        c = tolower(c);\n    }\n\n    // Return the result\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (int_to_mini_roman(19) == \"xix\");\n    assert (int_to_mini_roman(152) == \"clii\");\n    assert (int_to_mini_roman(251) == \"ccli\");\n    assert (int_to_mini_roman(426) == \"cdxxvi\");\n    assert (int_to_mini_roman(500) == \"d\");\n    assert (int_to_mini_roman(1) == \"i\");\n    assert (int_to_mini_roman(4) == \"iv\");\n    assert (int_to_mini_roman(43) == \"xliii\");\n    assert (int_to_mini_roman(90) == \"xc\");\n    assert (int_to_mini_roman(94) == \"xciv\");\n    assert (int_to_mini_roman(532) == \"dxxxii\");\n    assert (int_to_mini_roman(900) == \"cm\");\n    assert (int_to_mini_roman(994) == \"cmxciv\");\n    assert (int_to_mini_roman(1000) == \"m\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/157", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Step 2: Input Validation\n    if (a <= 0 || b <= 0 || c <= 0) {\n        return false;\n    }\n\n    // Step 3: Identify the Longest Side\n    float hypotenuse, side1, side2;\n    if (a >= b && a >= c) {\n        hypotenuse = a;\n        side1 = b;\n        side2 = c;\n    } else if (b >= a && b >= c) {\n        hypotenuse = b;\n        side1 = a;\n        side2 = c;\n    } else {\n        hypotenuse = c;\n        side1 = a;\n        side2 = b;\n    }\n\n    // Step 4: Check the Pythagorean Condition\n    float hypotenuse_squared = hypotenuse * hypotenuse;\n    float sum_of_squares = side1 * side1 + side2 * side2;\n\n    // Step 5: Return the Result\n    return (sum_of_squares == hypotenuse_squared);\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (right_angle_triangle(3, 4, 5) == true);\n    assert (right_angle_triangle(1, 2, 3) == false);\n    assert (right_angle_triangle(10, 6, 8) == true);\n    assert (right_angle_triangle(2, 2, 2) == false);\n    assert (right_angle_triangle(7, 24, 25) == true);\n    assert (right_angle_triangle(10, 5, 7) == false);\n    assert (right_angle_triangle(5, 12, 13) == true);\n    assert (right_angle_triangle(15, 8, 17) == true);\n    assert (right_angle_triangle(48, 55, 73) == true);\n    assert (right_angle_triangle(1, 1, 1) == false);\n    assert (right_angle_triangle(2, 2, 10) == false);\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/155", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Step 1: Handle negative numbers\n    if (num < 0) {\n        num = -num; // Convert to absolute value\n    }\n\n    // Step 2: Initialize counters\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Step 3: Extract digits and count\n    while (num > 0) {\n        int digit = num % 10; // Get the last digit\n        if (digit % 2 == 0) {\n            even_count++; // Increment even counter\n        } else {\n            odd_count++; // Increment odd counter\n        }\n        num /= 10; // Remove the last digit\n    }\n\n    // Step 4: Prepare the result vector\n    vector<int> result = {even_count, odd_count};\n    return result; // Return the counts\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(even_odd_count(7) , {0, 1}));\n    assert (issame(even_odd_count(-78) , {1, 1}));\n    assert (issame(even_odd_count(3452) , {2, 2}));\n    assert (issame(even_odd_count(346211) , {3, 3}));\n    assert (issame(even_odd_count(-345821) , {3, 3}));\n    assert (issame(even_odd_count(-2) , {1, 0}));\n    assert (issame(even_odd_count(-45347) , {2, 3}));\n    assert (issame(even_odd_count(0) , {1, 0}));\n}\n", "result": "failed: a.out: test.cpp:64: int main(): Assertion `issame(even_odd_count(0) , {1, 0})' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/158", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string maxWord = \"\";\n    int maxUniqueCount = 0;\n\n    for (const string& word : words) {\n        set<char> uniqueChars(word.begin(), word.end());\n        int uniqueCount = uniqueChars.size();\n\n        if (uniqueCount > maxUniqueCount || (uniqueCount == maxUniqueCount && word < maxWord)) {\n            maxWord = word;\n            maxUniqueCount = uniqueCount;\n        }\n    }\n\n    return maxWord;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert ((find_max({\"name\", \"of\", \"string\"}) == \"string\"));\n    assert ((find_max({\"name\", \"enam\", \"game\"}) == \"enam\"));\n    assert ((find_max({\"aaaaaaa\", \"bb\", \"cc\"}) == \"aaaaaaa\"));\n    assert ((find_max({\"abc\", \"cba\"}) == \"abc\"));\n    assert ((find_max({\"play\", \"this\", \"game\", \"of\",\"footbott\"}) == \"footbott\"));\n    assert ((find_max({\"we\", \"are\", \"gonna\", \"rock\"}) == \"gonna\"));\n    assert ((find_max({\"we\", \"are\", \"a\", \"mad\", \"nation\"}) == \"nation\"));\n    assert ((find_max({\"this\", \"is\", \"a\", \"prrk\"}) == \"this\"));\n    assert ((find_max({\"b\"}) == \"b\"));\n    assert ((find_max({\"play\", \"play\", \"play\"}) == \"play\"));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/159", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int totalEaten;\n    int carrotsLeft;\n\n    // Calculate total eaten carrots\n    if (remaining >= need) {\n        totalEaten = number + need;\n        carrotsLeft = remaining - need;\n    } else {\n        totalEaten = number + remaining;\n        carrotsLeft = 0; // All remaining carrots are eaten\n    }\n\n    // Return the result as a vector\n    return {totalEaten, carrotsLeft};\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(eat(5, 6, 10) , {11, 4}));\n    assert (issame(eat(4, 8, 9) , {12, 1}));\n    assert (issame(eat(1, 10, 10) , {11, 0}));\n    assert (issame(eat(2, 11, 5) , {7, 0}));\n    \n    assert (issame(eat(4, 5, 7) , {9, 2}));\n    assert (issame(eat(4, 5, 1) , {5, 0}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/161", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring solve(string s) {\n    string result;\n    bool hasLetter = false;\n\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            if (islower(c)) {\n                result += toupper(c);\n            } else {\n                result += tolower(c);\n            }\n        } else {\n            result += c;\n        }\n    }\n\n    if (!hasLetter) {\n        reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (solve(\"AsDf\") == \"aSdF\");\n    assert (solve(\"1234\") == \"4321\");\n    assert (solve(\"ab\") == \"AB\");\n    assert (solve(\"#a@C\") == \"#A@c\");\n    assert (solve(\"#AsdfW^45\") == \"#aSDFw^45\");\n    assert (solve(\"#6@2\") == \"2@6#\");\n    assert (solve(\"#$a^D\") == \"#$A^d\");\n    assert (solve(\"#ccc\") == \"#CCC\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/160", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <stdexcept>\n#include <cmath>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    // Step 1: Input Validation\n    if (operato.size() != operand.size() - 1) {\n        throw invalid_argument(\"Operator vector length must be one less than operand vector length.\");\n    }\n    \n    for (int num : operand) {\n        if (num < 0) {\n            throw invalid_argument(\"Operand vector must contain non-negative integers.\");\n        }\n    }\n    \n    for (const string& op : operato) {\n        if (op != \"+\" && op != \"-\" && op != \"*\" && op != \"//\" && op != \"**\") {\n            throw invalid_argument(\"Invalid operator in operator vector.\");\n        }\n    }\n\n    // Step 2: Initialize result\n    int result = operand[0];\n\n    // Step 3: Iterate through operators and operands\n    for (size_t i = 0; i < operato.size(); ++i) {\n        string op = operato[i];\n        int next_operand = operand[i + 1];\n\n        // Step 4: Handle each operation\n        if (op == \"+\") {\n            result += next_operand;\n        } else if (op == \"-\") {\n            result -= next_operand;\n        } else if (op == \"*\") {\n            result *= next_operand;\n        } else if (op == \"//\") {\n            if (next_operand == 0) throw invalid_argument(\"Division by zero.\");\n            result /= next_operand; // Floor division\n        } else if (op == \"**\") {\n            result = pow(result, next_operand);\n        }\n    }\n\n    // Step 5: Return the result\n    return result;\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (do_algebra({\"**\", \"*\", \"+\"}, {2, 3, 4, 5}) == 37);\n    assert (do_algebra({\"+\", \"*\", \"-\"}, {2, 3, 4, 5}) == 9);\n    assert (do_algebra({\"//\", \"*\"}, {7, 3, 4}) == 8);\n}\n", "result": "failed: a.out: test.cpp:70: int main(): Assertion `do_algebra({\"+\", \"*\", \"-\"}, {2, 3, 4, 5}) == 9' failed.\n", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/162", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n#include <sstream>\n#include <iomanip>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    // Check for empty input\n    if (text.empty()) {\n        return \"None\"; // or return nullptr if using pointers\n    }\n\n    // Initialize MD5 context\n    MD5_CTX md5Context;\n    MD5_Init(&md5Context);\n\n    // Update MD5 with input string\n    MD5_Update(&md5Context, text.c_str(), text.length());\n\n    // Finalize the MD5 hash\n    unsigned char hash[MD5_DIGEST_LENGTH];\n    MD5_Final(hash, &md5Context);\n\n    // Convert to hexadecimal string\n    stringstream hexString;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        hexString << hex << setw(2) << setfill('0') << (int)hash[i];\n    }\n\n    // Return the MD5 hash\n    return hexString.str();\n}\n\n#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (string_to_md5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\");\n    assert (string_to_md5(\"\") == \"None\");\n    assert (string_to_md5(\"A B C\") == \"0ef78513b0cb8cef12743f5aeb35f888\");\n    assert (string_to_md5(\"password\") == \"5f4dcc3b5aa765d61d8327deb882cf99\");\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
{"task_id": "CPP/163", "completion_id": 0, "test_code": "#include <stdlib.h>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <cassert>\n#include <bitset>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <bits/stdc++.h>\n\n#include <stdio.h>\n#include <vector>\n#include <algorithm> // for std::sort\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    // Normalize Input\n    int min_value = min(a, b);\n    int max_value = max(a, b);\n    \n    // Initialize a Collection\n    vector<int> even_digits;\n    \n    // Iterate Through the Range\n    for (int i = min_value; i <= max_value; ++i) {\n        // Check if the digit is even and less than 10\n        if (i % 2 == 0 && i < 10) {\n            even_digits.push_back(i);\n        }\n    }\n    \n    // Sort the Collection (if necessary)\n    sort(even_digits.begin(), even_digits.end());\n    \n    // Return the Result\n    return even_digits;\n}\n\n#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(generate_integers(2, 10) , {2, 4, 6, 8}));\n    assert (issame(generate_integers(10, 2) , {2, 4, 6, 8}));\n    assert (issame(generate_integers(132, 2) , {2, 4, 6, 8}));\n    assert (issame(generate_integers(17,89) , {}));\n}\n", "result": "passed", "passed": true, "finish": -1, "file": "", "output": []}
