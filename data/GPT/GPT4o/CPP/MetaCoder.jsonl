{"task_id": "CPP/0", "generation": "#include <stdio.h>\n#include <vector>\n#include <math.h>\n#include <algorithm> // For std::sort\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Step 1: Input validation (optional)\n    if (numbers.size() < 2) {\n        return false; // No pairs to compare\n    }\n\n    // Step 2: Sort the vector\n    sort(numbers.begin(), numbers.end());\n\n    // Step 3: Compare adjacent elements\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        if (fabs(numbers[i] - numbers[i + 1]) < threshold) {\n            return true; // Found close elements\n        }\n    }\n\n    // Step 4: No close elements found\n    return false;\n}\n"}
{"task_id": "CPP/1", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    // Step 2: Input Cleaning\n    string cleaned;\n    for (char c : paren_string) {\n        if (c != ' ') {\n            cleaned += c;\n        }\n    }\n\n    // Step 3: Initialize Variables\n    vector<string> groups;\n    int balance = 0;\n    string temp;\n\n    // Step 4: Traverse the Cleaned String\n    for (char c : cleaned) {\n        temp += c; // Add current character to the temporary string\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n        }\n\n        // If balance is zero, we have a complete group\n        if (balance == 0) {\n            groups.push_back(temp); // Store the complete group\n            temp.clear(); // Clear temporary string for the next group\n        }\n    }\n\n    // Step 5: Return Result\n    return groups;\n}\n"}
{"task_id": "CPP/2", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nfloat truncate_number(float number) {\n    // Input validation\n    if (number <= 0) {\n        return 0; // or handle error\n    }\n\n    // Extract Integer Part\n    int integerPart = floor(number);\n\n    // Calculate Decimal Part\n    float decimalPart = number - integerPart;\n\n    // Return the Decimal Part\n    return decimalPart;\n}\n\n// Example usage\n"}
{"task_id": "CPP/3", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Initialize balance\n\n    // Loop through each operation\n    for (int operation : operations) {\n        balance += operation; // Update balance\n\n        // Check if balance is below zero\n        if (balance < 0) {\n            return true; // Return true if balance is negative\n        }\n    }\n\n    return false; // Return false if balance never went below zero\n}\n"}
{"task_id": "CPP/4", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    // Step 1: Calculate the mean\n    float sum = 0.0;\n    int n = numbers.size();\n    \n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / n;\n\n    // Step 2: Calculate the sum of absolute differences\n    float absolute_difference_sum = 0.0;\n    \n    for (float num : numbers) {\n        absolute_difference_sum += fabs(num - mean);\n    }\n\n    // Step 3: Calculate Mean Absolute Deviation\n    float mad = absolute_difference_sum / n;\n\n    // Step 4: Return the result\n    return mad;\n}\n"}
{"task_id": "CPP/5", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) { \n    // Check for edge cases\n    if (numbers.empty()) {\n        return {};\n    }\n    if (numbers.size() == 1) {\n        return numbers;\n    }\n\n    // Initialize the output vector\n    vector<int> result;\n\n    // Iterate through the input vector\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        // Add the current element to the result\n        result.push_back(numbers[i]);\n\n        // Add delimeter if not the last element\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    // Return the output vector\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> results;\n    stringstream ss(paren_string);\n    string group;\n\n    while (ss >> group) {\n        int current_depth = 0;\n        int max_depth = 0;\n\n        for (char ch : group) {\n            if (ch == '(') {\n                current_depth++;\n                if (current_depth > max_depth) {\n                    max_depth = current_depth;\n                }\n            } else if (ch == ')') {\n                current_depth--;\n            }\n        }\n\n        results.push_back(max_depth);\n    }\n\n    return results;\n}\n"}
{"task_id": "CPP/7", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    // Step 1: Initialize an empty result vector\n    vector<string> result;\n\n    // Step 2: Handle edge cases\n    if (strings.empty() || substring.empty()) {\n        return result; // Return empty vector if input vector or substring is empty\n    }\n\n    // Step 3: Iterate through each string in the input vector\n    for (const string& str : strings) {\n        // Step 4: Check if the substring is found in the current string\n        if (str.find(substring) != string::npos) {\n            // Step 5: If found, add the string to the result vector\n            result.push_back(str);\n        }\n    }\n\n    // Step 6: Return the filtered result vector\n    return result;\n}\n"}
{"task_id": "CPP/8", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    // Check for empty vector\n    if (numbers.empty()) {\n        return {0, 1}; // Return (0, 1) for empty input\n    }\n\n    // Initialize sum and product\n    int sum = 0;\n    int product = 1;\n\n    // Iterate through the vector\n    for (int number : numbers) {\n        sum += number;      // Calculate sum\n        product *= number;  // Calculate product\n    }\n\n    // Return the result\n    return {sum, product}; // Return the sum and product as a vector\n}\n"}
{"task_id": "CPP/9", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    // Step 1: Check for empty input\n    if (numbers.empty()) {\n        return {};\n    }\n\n    // Step 2: Initialize result vector and current maximum\n    vector<int> result;\n    int current_max = numbers[0]; // Start with the first element\n\n    // Step 3: Iterate through the input vector\n    for (int num : numbers) {\n        // Step 4: Update current maximum if necessary\n        if (num > current_max) {\n            current_max = num;\n        }\n        // Step 5: Append current maximum to result\n        result.push_back(current_max);\n    }\n\n    // Step 6: Return the result vector\n    return result;\n}\n"}
{"task_id": "CPP/10", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring longest_palindromic_suffix(string str) {\n    for (int i = str.length(); i >= 0; --i) {\n        if (is_palindrome(str.substr(i))) {\n            return str.substr(i);\n        }\n    }\n    return \"\"; // In case no palindromic suffix is found\n}\n\nstring make_palindrome(string str) {\n    string suffix = longest_palindromic_suffix(str);\n    string prefix = str.substr(0, str.length() - suffix.length());\n    string reversed_prefix(prefix.rbegin(), prefix.rend());\n    return str + reversed_prefix; // Construct the palindrome\n}\n"}
{"task_id": "CPP/11", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    // Step 1: Input validation\n    if (a.length() != b.length()) {\n        return \"Error: Strings must be of equal length.\";\n    }\n    for (char c : a) {\n        if (c != '0' && c != '1') {\n            return \"Error: String a contains invalid characters.\";\n        }\n    }\n    for (char c : b) {\n        if (c != '0' && c != '1') {\n            return \"Error: String b contains invalid characters.\";\n        }\n    }\n\n    // Step 2: Initialize result string\n    string result = \"\";\n\n    // Step 3: Iterate and compute XOR\n    for (size_t i = 0; i < a.length(); ++i) {\n        if (a[i] == b[i]) {\n            result += '0'; // Both are the same\n        } else {\n            result += '1'; // Different\n        }\n    }\n\n    // Step 4: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"None\"; // Return \"None\" for empty input\n    }\n\n    string longestString = \"\";\n    size_t maxLength = 0;\n\n    for (const string& str : strings) {\n        if (str.length() > maxLength) {\n            longestString = str;\n            maxLength = str.length();\n        }\n    }\n\n    return longestString;\n}\n"}
{"task_id": "CPP/13", "generation": "#include <stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    // Input validation\n    if (a == 0 && b == 0) {\n        return 0; // GCD is undefined for both zero\n    }\n\n    // Euclidean algorithm\n    while (b != 0) {\n        int temp = b;\n        b = a % b; // Remainder\n        a = temp;  // Update a\n    }\n\n    return abs(a); // Return the absolute value of GCD\n}\n"}
{"task_id": "CPP/14", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    if (str.empty()) {\n        return {};\n    }\n    \n    vector<string> prefixes;\n    \n    for (size_t i = 0; i < str.length(); ++i) {\n        prefixes.push_back(str.substr(0, i + 1));\n    }\n    \n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring string_sequence(int n) {\n    if (n < 0) {\n        return \"\"; // Handle negative input\n    }\n    \n    string result = \"\";\n    for (int i = 0; i <= n; i++) {\n        result += to_string(i); // Convert number to string\n        if (i < n) {\n            result += \" \"; // Add space if not the last number\n        }\n    }\n    \n    return result; // Return the final string\n}\n"}
{"task_id": "CPP/16", "generation": "#include <iostream>\n#include <set>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint count_distinct_characters(string str) { \n    // Normalize case\n    for (char &c : str) {\n        c = tolower(c); // Convert to lowercase\n    }\n    \n    // Use a set to track distinct characters\n    set<char> distinct_chars;\n    \n    // Insert characters into the set\n    for (char c : str) {\n        distinct_chars.insert(c); // Insert character into the set\n    }\n    \n    // Return the count of distinct characters\n    return distinct_chars.size(); // Size of the set is the count of distinct characters\n}\n"}
{"task_id": "CPP/17", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    // Step 2: Input Validation\n    if (music_string.empty()) {\n        return {};\n    }\n\n    // Step 3: String Splitting\n    istringstream iss(music_string);\n    string note;\n    vector<int> beats;\n\n    // Step 4: Mapping Notes to Beats\n    unordered_map<string, int> note_to_beats = {\n        {\"o\", 4},\n        {\"o|\", 2},\n        {\".|\", 1}\n    };\n\n    // Step 5: Beat Calculation\n    while (iss >> note) {\n        if (note_to_beats.find(note) != note_to_beats.end()) {\n            beats.push_back(note_to_beats[note]);\n        }\n    }\n\n    // Step 6: Output Construction\n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    // Input Validation\n    if (substring.empty()) return 0;\n    if (str.empty()) return 0;\n\n    // Initialize Variables\n    int count = 0;\n    size_t position = 0;\n\n    // Search Loop\n    while ((position = str.find(substring, position)) != string::npos) {\n        count++; // Increment count for each found occurrence\n        position++; // Move to the next position for overlapping\n    }\n\n    // Return the Count\n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Define the mappings\n    map<string, int> numToInt = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, \n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, \n        {\"eight\", 8}, {\"nine\", 9}\n    };\n    \n    map<int, string> intToNum = {\n        {0, \"zero\"}, {1, \"one\"}, {2, \"two\"}, {3, \"three\"}, \n        {4, \"four\"}, {5, \"five\"}, {6, \"six\"}, {7, \"seven\"}, \n        {8, \"eight\"}, {9, \"nine\"}\n    };\n\n    // Input handling: trim leading/trailing spaces and split into words\n    stringstream ss(numbers);\n    string word;\n    vector<int> numValues;\n\n    while (ss >> word) {\n        if (numToInt.find(word) != numToInt.end()) {\n            numValues.push_back(numToInt[word]);\n        }\n    }\n\n    // Sort the integer values\n    sort(numValues.begin(), numValues.end());\n\n    // Convert back to string\n    vector<string> sortedWords;\n    for (int num : numValues) {\n        sortedWords.push_back(intToNum[num]);\n    }\n\n    // Join the sorted words into a single space-delimited string\n    string result;\n    for (size_t i = 0; i < sortedWords.size(); ++i) {\n        result += sortedWords[i];\n        if (i < sortedWords.size() - 1) {\n            result += \" \";\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/20", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm> // For std::sort\n#include <limits>    // For std::numeric_limits\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Input Validation\n    if (numbers.size() < 2) {\n        return {}; // or handle error\n    }\n\n    // Sorting\n    sort(numbers.begin(), numbers.end());\n\n    // Initialize Variables\n    float min_diff = numeric_limits<float>::max(); // Initialize to maximum float value\n    int closest_index1 = 0, closest_index2 = 1;\n\n    // Iterate Through the Sorted Vector\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_index1 = i;\n            closest_index2 = i + 1;\n        }\n    }\n\n    // Prepare the Result\n    vector<float> result = {numbers[closest_index1], numbers[closest_index2]};\n\n    // Return the Result\n    return result;\n}\n"}
{"task_id": "CPP/21", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) { \n    // Step 1: Check input validity\n    if (numbers.size() < 2) {\n        return {}; // or handle error\n    }\n\n    // Step 2: Find min and max\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n    for (float num : numbers) {\n        if (num < min_val) min_val = num;\n        if (num > max_val) max_val = num;\n    }\n\n    // Step 3: Calculate range\n    float range = max_val - min_val;\n\n    // Step 4: Rescale the vector\n    vector<float> rescaled;\n    for (float num : numbers) {\n        if (range == 0) {\n            rescaled.push_back(0.0); // All elements are the same\n        } else {\n            rescaled.push_back((num - min_val) / range);\n        }\n    }\n\n    // Step 5: Return the rescaled vector\n    return rescaled;\n}\n"}
{"task_id": "CPP/22", "generation": "#include <iostream>\n#include <vector>\n#include <list>\n#include <boost/any.hpp>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result; // Initialize result vector\n\n    // Iterate over input list\n    for (const auto& value : values) {\n        try {\n            // Type Checking\n            int integer_value = boost::any_cast<int>(value); // Attempt to cast\n            result.push_back(integer_value); // If successful, add to result\n        } catch (const boost::bad_any_cast&) {\n            // If cast fails, do nothing and continue\n        }\n    }\n\n    // Return the result\n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint strlen(string str) {\n    int length = 0; // Initialize length counter\n\n    // Iterate through the string\n    for (char c : str) {\n        length++; // Increment length for each character\n    }\n\n    // Return the length\n    return length;\n}\n\n// Testing the function\n"}
{"task_id": "CPP/24", "generation": "#include <iostream>\nusing namespace std;\n\nint largest_divisor(int n) {\n    // Step 2: Input Validation\n    if (n <= 1) {\n        // Handle error case\n        return -1; // or print an error message\n    }\n\n    // Step 3: Iterate to find the largest divisor\n    for (int d = n - 1; d >= 1; d--) {\n        if (n % d == 0) {\n            return d; // Step 4: Return the largest divisor\n        }\n    }\n\n    // If no divisor found (should not happen for n > 1)\n    return -1; // or an appropriate value\n}\n"}
{"task_id": "CPP/25", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n\n    // Input validation\n    if (n <= 1) {\n        return factors; // Return empty vector for invalid input\n    }\n\n    // Factorization logic\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // Check for odd factors from 3 to sqrt(n)\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // If n is still greater than 2, then n is prime\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors; // Return the vector of prime factors\n}\n"}
{"task_id": "CPP/26", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> count_map; // Step 1: Initialize count map\n    vector<int> result; // Step 1: Initialize result vector\n\n    // Step 2: Count occurrences\n    for (int num : numbers) {\n        count_map[num]++;\n    }\n\n    // Step 3: Filter unique elements\n    for (int num : numbers) {\n        if (count_map[num] == 1) { // Check if the element is unique\n            result.push_back(num); // Add to result\n        }\n    }\n\n    // Step 4: Return result\n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include <stdio.h>\n#include <string>\n#include <cctype> // For toupper and tolower\n\nusing namespace std;\n\nstring flip_case(string str) {\n    string result; // Initialize an output string\n\n    // Iterate through each character\n    for (char c : str) {\n        // Check character case\n        if (islower(c)) {\n            result += toupper(c); // Flip to uppercase\n        } else if (isupper(c)) {\n            result += tolower(c); // Flip to lowercase\n        } else {\n            result += c; // Leave unchanged\n        }\n    }\n\n    // Return the result\n    return result;\n}\n"}
{"task_id": "CPP/28", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result; // Initialize result string\n\n    // Iterate over the vector\n    for (const string& str : strings) {\n        result += str; // Append each string to result\n    }\n\n    // Return the concatenated result\n    return result;\n}\n\n// Testing the function\n"}
{"task_id": "CPP/29", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> result; // Initialize output vector\n\n    // Iterate over input vector\n    for (const string& str : strings) {\n        // Check if the string starts with the prefix\n        if (str.substr(0, prefix.size()) == prefix) {\n            // Store matches\n            result.push_back(str);\n        }\n    }\n\n    // Return result\n    return result;\n}\n"}
{"task_id": "CPP/30", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positive_numbers; // Initialize output vector\n\n    // Iterate through input vector\n    for (float num : l) {\n        // Check if the number is positive\n        if (num > 0) {\n            positive_numbers.push_back(num); // Add to output vector\n        }\n    }\n\n    // Return the output vector\n    return positive_numbers;\n}\n"}
{"task_id": "CPP/31", "generation": "#include <cmath>\n#include <stdio.h>\nusing namespace std;\n\nbool is_prime(long long n) {\n    // Input Validation\n    if (n <= 1) return false; // Not prime\n    if (n == 2) return true;  // 2 is prime\n    if (n % 2 == 0) return false; // Even numbers greater than 2 are not prime\n\n    // Check for divisibility\n    for (long long i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) {\n            return false; // Found a divisor\n        }\n    }\n    \n    // Return true if no divisors found\n    return true;\n}\n"}
{"task_id": "CPP/32", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <stdexcept>\n\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    /* \n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n \n    */\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    /*\n    xs are coefficients of a polynomial. find_zero find x such that poly(x) = 0. find_zero returns only one zero point, even if there are many. \n    Moreover, find_zero only takes list xs having even number of coefficients and largest non zero coefficient as it guarantees a solution.\n    */\n    if (xs.size() % 2 != 0) {\n        throw invalid_argument(\"The number of coefficients must be even.\");\n    }\n\n    double lower_bound = -1000; // Arbitrary lower bound\n    double upper_bound = 1000;  // Arbitrary upper bound\n    double mid;\n\n    while (upper_bound - lower_bound > 1e-7) { // Precision threshold\n        mid = (lower_bound + upper_bound) / 2.0;\n        if (poly(xs, mid) == 0) {\n            return mid; // Found exact zero\n        } else if (poly(xs, mid) * poly(xs, lower_bound) < 0) {\n            upper_bound = mid; // Zero is in the left half\n        } else {\n            lower_bound = mid; // Zero is in the right half\n        }\n    }\n    return mid; // Return the approximate zero\n}\n"}
{"task_id": "CPP/33", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> valuesAtDivisibleByThree;\n\n    // Extract values at indices divisible by three\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            valuesAtDivisibleByThree.push_back(l[i]);\n        }\n    }\n\n    // Sort the extracted values\n    sort(valuesAtDivisibleByThree.begin(), valuesAtDivisibleByThree.end());\n\n    // Rebuild the output vector\n    vector<int> result = l; // Copy original vector\n    int sortedIndex = 0;\n    for (int i = 0; i < result.size(); i++) {\n        if (i % 3 == 0) {\n            result[i] = valuesAtDivisibleByThree[sortedIndex++];\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/34", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Step 1: Use a set to remove duplicates\n    set<int> uniqueSet(l.begin(), l.end());\n    \n    // Step 2: Convert the set back to a vector\n    vector<int> uniqueVector(uniqueSet.begin(), uniqueSet.end());\n    \n    // Step 3: Return the result\n    return uniqueVector;\n}\n"}
{"task_id": "CPP/35", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    // Step 1: Input Validation\n    if (l.empty()) {\n        return NAN; // Return NAN for empty vector\n    }\n\n    // Step 2: Initialize Maximum Value\n    float maxValue = l[0];\n\n    // Step 3: Iterate Through the Vector\n    for (size_t i = 1; i < l.size(); i++) {\n        if (l[i] > maxValue) {\n            maxValue = l[i]; // Update maxValue\n        }\n    }\n\n    // Step 4: Return the Result\n    return maxValue;\n}\n"}
{"task_id": "CPP/36", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint count_sevens(int number) {\n    int count = 0;\n    string num_str = to_string(number);\n    for (char c : num_str) {\n        if (c == '7') {\n            count++;\n        }\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int total_count = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            total_count += count_sevens(i);\n        }\n    }\n    return total_count;\n}\n"}
{"task_id": "CPP/37", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    vector<float> even_values; // Initialize even values vector\n    vector<float> result(l.size()); // Initialize result vector\n\n    // Loop through input vector\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) { // Even index\n            even_values.push_back(l[i]); // Store even indexed value\n        } else { // Odd index\n            result[i] = l[i]; // Copy odd indexed value\n        }\n    }\n\n    // Sort the even indexed values\n    sort(even_values.begin(), even_values.end());\n\n    // Reinsert sorted values into result vector\n    for (int i = 0, j = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            result[i] = even_values[j++]; // Replace with sorted value\n        }\n    }\n\n    // Return the result vector\n    return result;\n}\n"}
{"task_id": "CPP/38", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_cyclic(string s) { \n    // returns encoded string by cycling groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l = s.length();\n    string output;\n    for (int i = 0; i < l; i += 3) {\n        string x = s.substr(i, 3);\n        if (x.length() == 3) {\n            x = x.substr(1) + x[0]; // Cycle left\n        }\n        output += x; // Append modified group to output\n    }\n    return output;\n}\n\nstring decode_cyclic(string s) { \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string. \n    */\n    int l = s.length();\n    string output;\n    for (int i = 0; i < l; i += 3) {\n        string x = s.substr(i, 3);\n        if (x.length() == 3) {\n            x = x[x.length() - 1] + x.substr(0, 2); // Reverse cycle\n        }\n        output += x; // Append modified group to output\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num < 2) return false;\n    for (int i = 2; i <= sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nvector<int> fibonacci_generator() {\n    vector<int> fibs;\n    int a = 0, b = 1;\n    while (true) {\n        fibs.push_back(b);\n        int next = a + b;\n        a = b;\n        b = next;\n        if (fibs.size() > 100) break; // Limit to avoid infinite loop in this example\n    }\n    return fibs;\n}\n\nint prime_fib(int n) {\n    vector<int> fibs = fibonacci_generator();\n    int count = 0;\n\n    for (int fib : fibs) {\n        if (is_prime(fib)) {\n            count++;\n            if (count == n) {\n                return fib;\n            }\n        }\n    }\n    return -1; // In case n is out of bounds\n}\n\n"}
{"task_id": "CPP/40", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    // Step 2: Input Validation\n    if (l.size() < 3) return false;\n\n    // Step 3: Sort the Vector\n    sort(l.begin(), l.end());\n\n    // Step 4: Iterate Through the Vector\n    for (int i = 0; i < l.size() - 2; i++) {\n        // Skip duplicates\n        if (i > 0 && l[i] == l[i - 1]) continue;\n\n        // Step 5: Two-Pointer Technique\n        int left = i + 1;\n        int right = l.size() - 1;\n\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true; // Triplet found\n            } else if (sum < 0) {\n                left++; // Increase sum\n            } else {\n                right--; // Decrease sum\n            }\n        }\n    }\n\n    // Step 6: Return False\n    return false;\n}\n"}
{"task_id": "CPP/41", "generation": "#include <stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Input validation (optional)\n    if (n < 0) {\n        return 0; // or handle error\n    }\n    \n    // Calculate total collisions\n    return n * n; // Each car from left collides with each car from right\n}\n"}
{"task_id": "CPP/42", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> incr_vector(vector<int> l) {\n    // Step 2: Input Validation\n    if (l.empty()) {\n        return {}; // Return an empty vector if input is empty\n    }\n\n    // Step 3: Create Output Vector\n    vector<int> incremented_vector;\n\n    // Step 4: Iterate and Increment\n    for (int i = 0; i < l.size(); i++) {\n        incremented_vector.push_back(l[i] + 1); // Increment and add to output vector\n    }\n\n    // Step 5: Return Output\n    return incremented_vector;\n}\n"}
{"task_id": "CPP/43", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_set> // Include for using unordered_set\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    // Step 2: Input Validation\n    if (l.size() < 2) return false;\n\n    // Step 3: Initialize Data Structure\n    unordered_set<int> seen;\n\n    // Step 4: Loop Through Each Element\n    for (int num : l) {\n        // Calculate negation\n        int neg_num = -num;\n\n        // Step 4.1: Check for Pairs\n        if (seen.find(neg_num) != seen.end()) {\n            return true; // Found a pair\n        }\n\n        // Step 4.2: Add current number to the set\n        seen.insert(num);\n    }\n\n    // Step 5: Final Check\n    return false; // No pairs found\n}\n"}
{"task_id": "CPP/44", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    // Step 2: Input Validation\n    if (x < 0) {\n        return \"Error: Negative input not allowed.\";\n    }\n    if (base < 2 || base >= 10) {\n        return \"Error: Base must be between 2 and 9.\";\n    }\n\n    // Step 3: Initialize Result String\n    string result = \"\";\n\n    // Step 4: Conversion Logic\n    if (x == 0) {\n        return \"0\"; // Handle edge case for zero\n    }\n    \n    while (x > 0) {\n        int remainder = x % base; // Get remainder\n        result = to_string(remainder) + result; // Prepend to result\n        x = x / base; // Update x\n    }\n\n    // Step 6: Return the Result\n    return result;\n}\n"}
{"task_id": "CPP/45", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h; // Area calculation\n}\n\n"}
{"task_id": "CPP/46", "generation": "#include <stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    // Step 2: Input validation\n    if (n < 0) return -1; // or handle error appropriately\n\n    // Step 3: Base cases handling\n    int fib4[100]; // Assuming n will not exceed 99 for simplicity\n    fib4[0] = 0;\n    fib4[1] = 0;\n    fib4[2] = 2;\n    fib4[3] = 0;\n\n    // Step 4: Iterative calculation\n    for (int i = 4; i <= n; i++) {\n        fib4[i] = fib4[i-1] + fib4[i-2] + fib4[i-3] + fib4[i-4];\n    }\n\n    // Step 5: Return the result\n    return fib4[n];\n}\n"}
{"task_id": "CPP/47", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Step 2: Input Validation\n    if (l.empty()) {\n        // Handle empty vector case (e.g., return 0 or throw an error)\n        return 0; // or throw an exception\n    }\n\n    // Step 3: Sorting the Vector\n    sort(l.begin(), l.end());\n\n    // Step 4: Calculate the Median\n    int n = l.size();\n    if (n % 2 == 1) {\n        // Odd number of elements\n        return l[n / 2];\n    } else {\n        // Even number of elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    // Step 2: Input Validation\n    if (text.empty()) {\n        return true; // An empty string is a palindrome\n    }\n\n    // Step 3: Initialize Pointers\n    int left = 0;\n    int right = text.length() - 1;\n\n    // Step 4: Character Comparison Loop\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Mismatch found\n        }\n        left++;\n        right--;\n    }\n\n    // Step 5: Completion Check\n    return true; // No mismatches found, it's a palindrome\n}\n"}
{"task_id": "CPP/49", "generation": "#include <stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    // Handle edge cases\n    if (n < 0) return 1; // Assuming 2^n for negative n returns 1\n    if (p <= 1) return 1; // Any number mod 1 is 0, but we return 1 for n = 0\n\n    long long result = 1; // Use long long to avoid overflow\n    long long base = 2;   // Base is 2\n\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd\n            result = (result * base) % p; // Multiply result by base and take mod p\n        }\n        base = (base * base) % p; // Square the base and take mod p\n        n /= 2; // Divide n by 2\n    }\n\n    return result; // Return the final result\n}\n"}
{"task_id": "CPP/50", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            char shifted = (c - 'a' + 5) % 26 + 'a';\n            out += shifted;\n        } else {\n            out += c; // Non-alphabetic characters remain unchanged\n        }\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            char shifted = (c - 'a' - 5 + 26) % 26 + 'a'; // Adding 26 to handle negative values\n            out += shifted;\n        } else {\n            out += c; // Non-alphabetic characters remain unchanged\n        }\n    }\n    return out;\n}\n\n"}
{"task_id": "CPP/51", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    // Define the set of vowels\n    string vowels = \"aeiouAEIOU\";\n    \n    // Initialize the result string\n    string result = \"\";\n    \n    // Loop through each character in the input string\n    for (char c : text) {\n        // Check if the character is not a vowel\n        if (vowels.find(c) == string::npos) {\n            // Append non-vowel characters to the result\n            result += c;\n        }\n    }\n    \n    // Return the result string\n    return result;\n}\n"}
{"task_id": "CPP/52", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    // Step 2: Input Validation\n    if (l.empty()) {\n        return true; // No elements to check\n    }\n\n    // Step 3: Iterate Through the Vector\n    for (int num : l) {\n        // Step 4: Condition Checking\n        if (num >= t) {\n            return false; // Found an element not below the threshold\n        }\n    }\n\n    // Step 5: Return Result\n    return true; // All elements are below the threshold\n}\n"}
{"task_id": "CPP/53", "generation": "#include <iostream>\nusing namespace std;\n\n// Function to add two integers\nint add(int x, int y) {\n    return x + y; // Addition logic\n}\n\n"}
{"task_id": "CPP/54", "generation": "#include <iostream>\n#include <string>\n#include <set>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Step 1: Create sets for unique characters\n    set<char> chars1;\n    set<char> chars2;\n\n    // Step 2: Populate the first set with unique characters from s0\n    for (char c : s0) {\n        chars1.insert(c);\n    }\n\n    // Step 3: Populate the second set with unique characters from s1\n    for (char c : s1) {\n        chars2.insert(c);\n    }\n\n    // Step 4: Compare the two sets\n    return chars1 == chars2;\n}\n"}
{"task_id": "CPP/55", "generation": "#include <iostream>\nusing namespace std;\n\nint fib(int n) {\n    // Input validation\n    if (n < 0) {\n        throw invalid_argument(\"Input must be a non-negative integer.\");\n    }\n\n    // Base case handling\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n\n    // Iterative calculation for better performance\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; ++i) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n"}
{"task_id": "CPP/56", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // Initialize counter\n\n    // Iterate through the string\n    for (char ch : brackets) {\n        if (ch == '<') {\n            balance++; // Increment for opening bracket\n        } else if (ch == '>') {\n            balance--; // Decrement for closing bracket\n        }\n\n        // Check for negative balance\n        if (balance < 0) {\n            return false; // Unmatched closing bracket\n        }\n    }\n\n    // Final balance check\n    return balance == 0; // Return true if balanced\n}\n"}
{"task_id": "CPP/57", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    // Edge case: empty or single element vector\n    if (l.size() <= 1) return true;\n\n    bool isIncreasing = true;\n    bool isDecreasing = true;\n\n    for (size_t i = 0; i < l.size() - 1; ++i) {\n        if (l[i] > l[i + 1]) {\n            isIncreasing = false;\n        }\n        if (l[i] < l[i + 1]) {\n            isDecreasing = false;\n        }\n    }\n\n    return isIncreasing || isDecreasing;\n}\n"}
{"task_id": "CPP/58", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    set<int> set1(l1.begin(), l1.end());\n    set<int> commonSet;\n\n    for (int num : l2) {\n        if (set1.find(num) != set1.end()) {\n            commonSet.insert(num);\n        }\n    }\n\n    vector<int> result(commonSet.begin(), commonSet.end());\n    return result;\n}\n"}
{"task_id": "CPP/59", "generation": "#include <stdio.h>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int largest_factor = 0;\n\n    // Check for factor 2\n    while (n % 2 == 0) {\n        largest_factor = 2;\n        n /= 2;\n    }\n\n    // Check for odd factors from 3 to sqrt(n)\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest_factor = i;\n            n /= i;\n        }\n    }\n\n    // If n is still greater than 2, then n itself is prime\n    if (n > 2) {\n        largest_factor = n;\n    }\n\n    return largest_factor;\n}\n"}
{"task_id": "CPP/60", "generation": "#include <stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    // Input validation\n    if (n < 0) {\n        // Handle error for negative input\n        return 0; // or some error code\n    }\n    \n    // Summation logic (using formula)\n    int sum = n * (n + 1) / 2;\n    \n    // Return the result\n    return sum;\n}\n\n// Main function for testing\n"}
{"task_id": "CPP/61", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // Step 2: Initialization\n\n    // Step 3: Loop through the string\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++; // Increment for opening bracket\n        } else if (ch == ')') {\n            if (balance == 0) {\n                return false; // Invalid case: more closing than opening\n            }\n            balance--; // Decrement for closing bracket\n        }\n    }\n\n    // Step 4: Final Check\n    return balance == 0; // Return true if balanced\n}\n"}
{"task_id": "CPP/62", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    // Step 2: Input Validation\n    if (xs.empty()) {\n        return {}; // Return empty vector for empty input\n    }\n\n    // Step 3: Initialize Output Vector\n    vector<float> result;\n\n    // Step 4: Iterate Over Coefficients\n    for (size_t i = 1; i < xs.size(); ++i) {\n        // Calculate the derivative coefficient\n        result.push_back(i * xs[i]);\n    }\n\n    // Step 5: Return the Result\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint fibfib(int n) {\n    // Handle edge cases\n    if (n < 0) return -1; // Return -1 for negative inputs\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 1;\n\n    // Use an array to store computed values for optimization\n    vector<int> fibfib_values(n + 1);\n    fibfib_values[0] = 0;\n    fibfib_values[1] = 0;\n    fibfib_values[2] = 1;\n\n    // Compute the fibfib sequence iteratively\n    for (int i = 3; i <= n; ++i) {\n        fibfib_values[i] = fibfib_values[i - 1] + fibfib_values[i - 2] + fibfib_values[i - 3];\n    }\n\n    return fibfib_values[n];\n}\n\n"}
{"task_id": "CPP/64", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0; // Initialize counter\n\n    // Iterate through each character in the string\n    for (size_t i = 0; i < s.length(); i++) {\n        char c = tolower(s[i]); // Convert to lowercase for uniformity\n\n        // Check for vowels\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++; // Increment count for standard vowels\n        } else if (c == 'y' && i == s.length() - 1) {\n            count++; // Increment count if 'y' is at the end\n        }\n    }\n\n    // Return the total count of vowels\n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm> // for std::reverse\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string str = to_string(x);\n    int num_digits = str.length();\n\n    if (shift > num_digits) {\n        reverse(str.begin(), str.end());\n        return str;\n    }\n\n    // Calculate effective shift\n    shift = shift % num_digits;\n\n    // Perform circular shift\n    string result = str.substr(num_digits - shift) + str.substr(0, num_digits - shift);\n    return result;\n}\n"}
{"task_id": "CPP/66", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0; // Initialize sum\n\n    // Iterate through the string\n    for (char c : s) {\n        // Check if the character is uppercase\n        if (c >= 'A' && c <= 'Z') {\n            // Calculate ASCII value and add to sum\n            sum += static_cast<int>(c);\n        }\n    }\n\n    // Return the sum\n    return sum;\n}\n"}
{"task_id": "CPP/67", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <iostream>\n\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0, oranges = 0;\n\n    // Step 3: Parse the input string\n    size_t apple_pos = s.find(\"apples\");\n    size_t orange_pos = s.find(\"oranges\");\n\n    // Step 4: Extract and convert the numbers\n    if (apple_pos != string::npos) {\n        stringstream ss(s.substr(0, apple_pos));\n        ss >> apples; // Extract number of apples\n    }\n    \n    if (orange_pos != string::npos) {\n        stringstream ss(s.substr(apple_pos + 7, orange_pos - (apple_pos + 7)));\n        ss >> oranges; // Extract number of oranges\n    }\n\n    // Step 5: Calculate the number of mangoes\n    int mango_count = n - (apples + oranges);\n\n    // Step 6: Return the result\n    return mango_count;\n}\n"}
{"task_id": "CPP/68", "generation": "#include <iostream>\n#include <vector>\n#include <limits.h> // for INT_MAX\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    // Check for empty input\n    if (arr.empty()) {\n        return {};\n    }\n\n    // Initialize variables\n    int smallest_even = INT_MAX;\n    int index_of_smallest_even = -1;\n\n    // Iterate through the vector\n    for (int i = 0; i < arr.size(); i++) {\n        // Check if the number is even\n        if (arr[i] % 2 == 0) {\n            // Update smallest even value and index\n            if (arr[i] < smallest_even) {\n                smallest_even = arr[i];\n                index_of_smallest_even = i;\n            }\n        }\n    }\n\n    // Check and return result\n    if (index_of_smallest_even == -1) {\n        return {};\n    } else {\n        return {smallest_even, index_of_smallest_even};\n    }\n}\n"}
{"task_id": "CPP/69", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequencyMap;\n\n    // Count frequencies\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    // Find the greatest integer that meets the criteria\n    int greatest = -1;\n    for (const auto& pair : frequencyMap) {\n        int value = pair.first;\n        int frequency = pair.second;\n        if (frequency >= value) {\n            greatest = max(greatest, value);\n        }\n    }\n\n    return greatest;\n}\n"}
{"task_id": "CPP/70", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    // Step 2: Input Validation\n    if (lst.empty()) {\n        return {};\n    }\n\n    // Step 3: Sorting\n    vector<int> sorted_lst = lst; // Copy the input\n    sort(sorted_lst.begin(), sorted_lst.end());\n\n    // Step 4: Initialize Pointers\n    vector<int> result;\n    int left = 0;\n    int right = sorted_lst.size() - 1;\n\n    // Step 5: Alternating Selection\n    while (left <= right) {\n        // Add minimum\n        result.push_back(sorted_lst[left]);\n        left++;\n        \n        // Add maximum if there's still an element\n        if (left <= right) {\n            result.push_back(sorted_lst[right]);\n            right--;\n        }\n    }\n\n    // Step 6: Return the Result\n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the triangle is valid\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1; // Invalid triangle\n    }\n\n    // Calculate semi-perimeter\n    float s = (a + b + c) / 2;\n\n    // Calculate area using Heron's formula\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Round the area to 2 decimal points\n    return round(area * 100) / 100; // Rounding to 2 decimal points\n}\n"}
{"task_id": "CPP/72", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n// Helper function to check if a vector is a palindrome\nbool is_palindrome(const vector<int>& q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Helper function to calculate the sum of elements in the vector\nint calculate_sum(const vector<int>& q) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    return sum;\n}\n\n// Main function to determine if the object will fly\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is balanced (palindromic)\n    bool balanced = is_palindrome(q);\n    \n    // Calculate the sum of the elements\n    int total_weight = calculate_sum(q);\n    \n    // Return true if balanced and total weight is less than or equal to w\n    return balanced && (total_weight <= w);\n}\n"}
{"task_id": "CPP/73", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int change_count = 0;\n    int n = arr.size();\n    \n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            change_count++;\n        }\n    }\n    \n    return change_count;\n}\n"}
{"task_id": "CPP/74", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint calculate_total_chars(const vector<string>& lst) {\n    int total = 0;\n    for (const string& str : lst) {\n        total += str.length();\n    }\n    return total;\n}\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int total_chars1 = calculate_total_chars(lst1);\n    int total_chars2 = calculate_total_chars(lst2);\n\n    if (total_chars1 < total_chars2) {\n        return lst1;\n    } else if (total_chars1 > total_chars2) {\n        return lst2;\n    } else {\n        return lst1; // If equal\n    }\n}\n\n// Example test cases\n"}
{"task_id": "CPP/75", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to generate prime numbers less than 100\nvoid generate_primes(vector<int>& primes) {\n    bool is_prime[100];\n    fill(begin(is_prime), end(is_prime), true);\n    is_prime[0] = is_prime[1] = false; // 0 and 1 are not prime numbers\n\n    for (int i = 2; i * i < 100; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < 100; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    for (int i = 2; i < 100; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n}\n\n// Function to check if a number is the product of three primes\nbool is_multiply_prime(int a) {\n    vector<int> primes;\n    generate_primes(primes); // Generate primes less than 100\n\n    // Iterate over all combinations of three primes\n    for (int i = 0; i < primes.size(); i++) {\n        for (int j = 0; j < primes.size(); j++) {\n            for (int k = 0; k < primes.size(); k++) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true; // Found a valid combination\n                }\n            }\n        }\n    }\n    return false; // No valid combination found\n}\n"}
{"task_id": "CPP/76", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    // Step 2: Input Validation\n    if (n <= 1) return false; // n must be greater than 1\n    if (x < 0) return false; // x must be non-negative\n\n    // Step 3: Initialize Variables\n    int power = 1; // This represents n^0\n\n    // Step 4: Loop to Calculate Powers\n    while (power < x) {\n        power *= n; // Calculate the next power of n\n        if (power == x) {\n            return true; // Found a match\n        }\n    }\n\n    // Step 5: Final Check\n    return false; // No match found\n}\n"}
{"task_id": "CPP/77", "generation": "#include <stdio.h>\n#include <cmath>\n\nusing namespace std;\n\nbool iscube(int a) {\n    // Handle the special case for zero\n    if (a == 0) return true;\n\n    // Calculate the cube root\n    double root = cbrt(a);\n    int roundedRoot = round(root);\n\n    // Check if the rounded cube root cubed equals a\n    if (roundedRoot * roundedRoot * roundedRoot == a) {\n        return true;\n    }\n\n    // Check the neighboring integers to account for rounding issues\n    if ((roundedRoot - 1) * (roundedRoot - 1) * (roundedRoot - 1) == a ||\n        (roundedRoot + 1) * (roundedRoot + 1) * (roundedRoot + 1) == a) {\n        return true;\n    }\n\n    // If none of the checks passed, return false\n    return false;\n}\n"}
{"task_id": "CPP/78", "generation": "#include <iostream>\n#include <string>\n#include <unordered_set>\n\nusing namespace std;\n\nint hex_key(string num) {\n    // Initialize variables\n    int count = 0;\n    unordered_set<char> prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'};\n\n    // Iterate through input string\n    for (char digit : num) {\n        // Count matches\n        if (prime_hex_digits.find(digit) != prime_hex_digits.end()) {\n            count++;\n        }\n    }\n\n    // Return the result\n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include <string>\n#include <algorithm> // for std::reverse\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    // Handle edge case for zero\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    // Convert decimal to binary\n    string binary = \"\";\n    while (decimal > 0) {\n        // Append remainder (0 or 1)\n        binary += (decimal % 2) ? '1' : '0';\n        decimal /= 2; // Update decimal to quotient\n    }\n\n    // Reverse the binary string to get the correct order\n    reverse(binary.begin(), binary.end());\n\n    // Format the result\n    return \"db\" + binary + \"db\";\n}\n"}
{"task_id": "CPP/80", "generation": "#include <iostream>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check length\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Loop through the string\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        // Check distinct characters\n        unordered_set<char> charSet;\n        charSet.insert(s[i]);\n        charSet.insert(s[i + 1]);\n        charSet.insert(s[i + 2]);\n\n        // If the size of the set is not 3, we have duplicates\n        if (charSet.size() != 3) {\n            return false;\n        }\n    }\n\n    // All groups of three characters are distinct\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letterGrades;\n\n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letterGrades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letterGrades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letterGrades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letterGrades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letterGrades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letterGrades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letterGrades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letterGrades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letterGrades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letterGrades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letterGrades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letterGrades.push_back(\"D-\");\n        } else {\n            letterGrades.push_back(\"E\");\n        }\n    }\n\n    return letterGrades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include <iostream>\n#include <string>\n#include <cmath> // For sqrt function\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n < 2) return false;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to check if string length is prime\nbool prime_length(string str) {\n    int length = str.length();\n    return is_prime(length);\n}\n\n// Example usage\n"}
{"task_id": "CPP/83", "generation": "/*\nGiven a positive integer n, return the count of the numbers of n-digit\npositive integers that start or end with 1.\n*/\n#include <stdio.h>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n == 1) {\n        return 1; // Only the number 1\n    }\n\n    // Count of n-digit numbers starting with 1\n    int count_starting_with_1 = 1 * (1 * 10^(n - 1)); // 10^(n-1)\n\n    // Count of n-digit numbers ending with 1\n    int count_ending_with_1 = 9 * (1 * 10^(n - 2)); // 9 * 10^(n-2)\n\n    // Count of n-digit numbers starting and ending with 1\n    int count_both_starting_and_ending_with_1 = 1 * (1 * 10^(n - 2)); // 10^(n-2)\n\n    // Total count using inclusion-exclusion principle\n    return count_starting_with_1 + count_ending_with_1 - count_both_starting_and_ending_with_1;\n}\n"}
{"task_id": "CPP/84", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nstring solve(int N) {\n    // Step 1: Input Validation\n    if (N < 0 || N > 10000) {\n        return \"\"; // or handle error\n    }\n    if (N == 0) {\n        return \"0\";\n    }\n\n    // Step 2: Digit Extraction and Summation\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10; // Add last digit to sum\n        N /= 10;       // Remove last digit\n    }\n\n    // Step 3: Binary Conversion\n    string binary = \"\";\n    while (sum > 0) {\n        binary = to_string(sum % 2) + binary; // Prepend the remainder\n        sum /= 2; // Divide sum by 2\n    }\n\n    // Step 4: Return the Result\n    return binary.empty() ? \"0\" : binary; // Handle case where sum is 0\n}\n"}
{"task_id": "CPP/85", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0; // Initialize sum variable\n\n    // Iterate through the vector at odd indices\n    for (int i = 1; i < lst.size(); i += 2) {\n        // Check if the element is even\n        if (lst[i] % 2 == 0) {\n            // Update the sum\n            sum += lst[i];\n        }\n    }\n\n    // Return the result\n    return sum;\n}\n"}
{"task_id": "CPP/86", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result = \"\";\n    string currentWord = \"\";\n\n    for (char c : s) {\n        if (c == ' ') {\n            // Sort and append the current word if it's not empty\n            if (!currentWord.empty()) {\n                sort(currentWord.begin(), currentWord.end());\n                result += currentWord;\n                currentWord = \"\"; // Reset for the next word\n            }\n            result += ' '; // Append the space\n        } else {\n            currentWord += c; // Build the current word\n        }\n    }\n\n    // Handle the last word if there is one\n    if (!currentWord.empty()) {\n        sort(currentWord.begin(), currentWord.end());\n        result += currentWord;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/87", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> result; // Initialize result vector\n\n    // Loop through each row\n    for (int i = 0; i < lst.size(); i++) {\n        // Loop through each element in the row\n        for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) { // Check for matches\n                result.push_back({i, j}); // Store coordinates\n            }\n        }\n    }\n\n    // Sort the result vector\n    sort(result.begin(), result.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort by column index descending\n        }\n        return a[0] < b[0]; // Sort by row index ascending\n    });\n\n    // Return the result\n    return result;\n}\n"}
{"task_id": "CPP/88", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Step 2: Input Validation\n    if (array.empty()) {\n        return {}; // Return empty vector if input is empty\n    }\n\n    // Step 3: Calculate the Sum\n    int first = array.front();\n    int last = array.back();\n    int sum = first + last;\n\n    // Step 4: Determine Sorting Order\n    vector<int> sorted_array = array; // Create a copy of the original array\n    if (sum % 2 == 0) {\n        // Step 5: Sort in descending order\n        sort(sorted_array.begin(), sorted_array.end(), greater<int>());\n    } else {\n        // Step 5: Sort in ascending order\n        sort(sorted_array.begin(), sorted_array.end());\n    }\n\n    // Step 6: Return the Result\n    return sorted_array;\n}\n"}
{"task_id": "CPP/89", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string result; // Initialize an empty result string\n\n    for (char c : s) { // Loop through each character\n        if (c >= 'a' && c <= 'z') { // Check if character is lowercase\n            char newChar = (c - 'a' + 4) % 26 + 'a'; // Shift by 4 and wrap around\n            result += newChar; // Append new character to result\n        } else {\n            result += c; // Append unchanged character (if needed)\n        }\n    }\n\n    return result; // Return the encrypted string\n}\n"}
{"task_id": "CPP/90", "generation": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    // Step 2: Check for empty vector\n    if (lst.empty()) {\n        return -1; // Return -1 to indicate None\n    }\n\n    // Step 3: Extract unique elements\n    set<int> unique_elements(lst.begin(), lst.end());\n\n    // Step 4: Check for unique element count\n    if (unique_elements.size() < 2) {\n        return -1; // Return -1 to indicate None\n    }\n\n    // Step 5: Convert set to vector and sort (set is already sorted)\n    vector<int> sorted_unique(unique_elements.begin(), unique_elements.end());\n\n    // Step 6: Return the second smallest element\n    return sorted_unique[1];\n}\n\n// Test cases\n"}
{"task_id": "CPP/91", "generation": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint is_bored(string S) {\n    int boredom_count = 0;\n    string sentence;\n    stringstream ss(S);\n    \n    // Loop through the string and extract sentences\n    while (getline(ss, sentence, '.')) {\n        // Check for other delimiters\n        if (sentence.back() == '?' || sentence.back() == '!') {\n            sentence.pop_back(); // Remove the delimiter\n        }\n        \n        // Trim leading whitespace\n        size_t start = sentence.find_first_not_of(\" \\n\\r\\t\");\n        if (start != string::npos) {\n            sentence = sentence.substr(start);\n        }\n        \n        // Check if the sentence starts with \"I\"\n        if (sentence.rfind(\"I \", 0) == 0 || sentence == \"I\") { // Check if it starts with \"I \"\n            boredom_count++;\n        }\n    }\n    \n    return boredom_count;\n}\n"}
{"task_id": "CPP/92", "generation": "#include <stdio.h>\n#include <math.h>\n\nbool any_int(float a, float b, float c) {\n    // Input validation: Check if all inputs are integers\n    if (a != floor(a) || b != floor(b) || c != floor(c)) {\n        return false;\n    }\n\n    // Check if any number is equal to the sum of the other two\n    if (a == b + c || b == a + c || c == a + b) {\n        return true;\n    }\n\n    // If none of the conditions are satisfied, return false\n    return false;\n}\n"}
{"task_id": "CPP/93", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring encode(string message) {\n    string encodedMessage = \"\"; // Initialize the result string\n    for (char c : message) { // Iterate through each character\n        // Swap case\n        if (isalpha(c)) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n            // Check for vowels and replace\n            switch (c) {\n                case 'A': c = 'C'; break;\n                case 'E': c = 'G'; break;\n                case 'I': c = 'K'; break;\n                case 'O': c = 'Q'; break;\n                case 'U': c = 'W'; break;\n                case 'a': c = 'c'; break;\n                case 'e': c = 'g'; break;\n                case 'i': c = 'k'; break;\n                case 'o': c = 'q'; break;\n                case 'u': c = 'w'; break;\n                default: break; // Non-vowel letters remain unchanged\n            }\n        }\n        // Build the encoded message\n        encodedMessage += c;\n    }\n    // Return the result\n    return encodedMessage;\n}\n"}
{"task_id": "CPP/94", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and return the sum of its digits\nint skjkasdkd(vector<int> lst) {\n    vector<int> primes;\n    \n    // Collect prime numbers\n    for (int num : lst) {\n        if (isPrime(num)) {\n            primes.push_back(num);\n        }\n    }\n    \n    // Find the largest prime\n    if (primes.empty()) return 0; // No prime found\n    int largestPrime = primes[0];\n    for (int prime : primes) {\n        if (prime > largestPrime) {\n            largestPrime = prime;\n        }\n    }\n    \n    // Return the sum of digits of the largest prime\n    return sumOfDigits(largestPrime);\n}\n"}
{"task_id": "CPP/95", "generation": "#include <stdio.h>\n#include <string>\n#include <map>\n#include <cctype> // For islower and isupper functions\nusing namespace std;\n\nbool check_dict_case(map<string, string> dict) {\n    // Check for empty map\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Initialize case type\n    bool isLowerCase = islower(dict.begin()->first[0]);\n    bool isUpperCase = isupper(dict.begin()->first[0]);\n\n    // Iterate through the map\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        // Check if key is alphabetic and matches case\n        if (!isalpha(key[0]) || (isLowerCase && !islower(key[0])) || (isUpperCase && !isupper(key[0]))) {\n            return false;\n        }\n    }\n\n    // Return true if all checks passed\n    return true;\n}\n"}
{"task_id": "CPP/96", "generation": "#include <stdio.h>\n#include <vector>\n#include <cmath> // For sqrt function\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int num) {\n    if (num < 2) return false;\n    for (int i = 2; i <= sqrt(num); i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Main function to count primes up to n\nvector<int> count_up_to(int n) {\n    vector<int> primes; // Vector to store prime numbers\n\n    // Input validation\n    if (n < 0) return primes; // Return empty vector for negative input\n\n    // Loop through numbers from 2 to n-1\n    for (int i = 2; i < n; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i); // Add prime number to vector\n        }\n    }\n\n    return primes; // Return the vector of prime numbers\n}\n"}
{"task_id": "CPP/97", "generation": "#include <stdio.h>\n#include <math.h>\n\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Extract unit digits\n    int unit_digit_a = abs(a) % 10; // Get unit digit of a\n    int unit_digit_b = abs(b) % 10; // Get unit digit of b\n    \n    // Multiply unit digits\n    int product = unit_digit_a * unit_digit_b;\n    \n    // Return the result\n    return product;\n}\n"}
{"task_id": "CPP/98", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0; // Initialize counter\n\n    // Iterate through the string\n    for (int i = 0; i < s.length(); i++) {\n        if (i % 2 == 0) { // Check for even index\n            char c = s[i];\n            // Check if the character is an uppercase vowel\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                count++; // Increment counter\n            }\n        }\n    }\n\n    return count; // Return the count\n}\n"}
{"task_id": "CPP/99", "generation": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <stdexcept>\n\nusing namespace std;\n\nint closest_integer(string value) {\n    // Step 1: Convert string to float\n    double num;\n    try {\n        num = stod(value);\n    } catch (invalid_argument&) {\n        throw runtime_error(\"Invalid input: not a number\");\n    }\n\n    // Step 2: Calculate closest integers\n    int lower_integer = static_cast<int>(floor(num));\n    int upper_integer = static_cast<int>(ceil(num));\n\n    // Step 3: Determine distances\n    double distance_to_lower = num - lower_integer;\n    double distance_to_upper = upper_integer - num;\n\n    // Step 4: Apply rounding logic\n    if (distance_to_lower < distance_to_upper) {\n        return lower_integer;\n    } else if (distance_to_upper < distance_to_lower) {\n        return upper_integer;\n    } else {\n        // Equidistant case\n        return (num >= 0) ? upper_integer : lower_integer;\n    }\n}\n"}
{"task_id": "CPP/100", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    // Input Validation\n    if (n <= 0) {\n        return {}; // Return an empty vector for non-positive input\n    }\n\n    // Initialize Variables\n    vector<int> stones;\n    int current_stones;\n\n    // Calculate Stones for Each Level\n    for (int i = 0; i < n; ++i) {\n        if (i == 0) {\n            current_stones = n; // First level has n stones\n        } else {\n            // Determine the next odd or even number\n            if (n % 2 == 0) { // n is even\n                current_stones += 2; // Next even number\n            } else { // n is odd\n                current_stones += 2; // Next odd number\n            }\n        }\n        stones.push_back(current_stones); // Append to the vector\n    }\n\n    // Return the Result\n    return stones;\n}\n"}
{"task_id": "CPP/101", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    string temp;\n\n    // Check for empty input\n    if (s.empty()) {\n        return words; // Return empty vector\n    }\n\n    // Traverse the string\n    for (char c : s) {\n        if (c != ' ' && c != ',') {\n            temp += c; // Build the word\n        } else {\n            if (!temp.empty()) {\n                words.push_back(temp); // Add the word to the vector\n                temp.clear(); // Reset the temporary string\n            }\n        }\n    }\n\n    // Check for any remaining word\n    if (!temp.empty()) {\n        words.push_back(temp);\n    }\n\n    return words; // Return the vector of words\n}\n"}
{"task_id": "CPP/102", "generation": "#include <stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Step 1: Determine the range\n    if (x > y) {\n        int temp = x;\n        x = y;\n        y = temp;\n    }\n\n    // Step 2: Identify the largest even integer\n    int largest_even = y;\n    if (largest_even % 2 != 0) {\n        largest_even--; // Decrement if odd\n    }\n\n    // Step 3: Check validity\n    if (largest_even < x) {\n        return -1; // No even integer in range\n    }\n    \n    return largest_even; // Return the largest even integer\n}\n"}
{"task_id": "CPP/103", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    // Input Validation\n    if (n <= 0 || m <= 0) {\n        return \"-1\"; // Not required by the problem but good practice\n    }\n    \n    // Range Check\n    if (n > m) {\n        return \"-1\";\n    }\n    \n    // Calculate the Sum and Count\n    int sum = 0;\n    int count = m - n + 1;\n    \n    for (int i = n; i <= m; i++) {\n        sum += i;\n    }\n    \n    // Compute the Average\n    int average = floor(static_cast<double>(sum) / count);\n    \n    // Convert to Binary\n    string binary = \"\";\n    if (average == 0) {\n        binary = \"0\";\n    } else {\n        while (average > 0) {\n            binary = to_string(average % 2) + binary;\n            average /= 2;\n        }\n    }\n    \n    return binary;\n}\n"}
{"task_id": "CPP/104", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result; // Step 2\n\n    for (int num : x) { // Step 3\n        bool hasEvenDigit = false;\n        int temp = num;\n        \n        while (temp > 0) {\n            int digit = temp % 10;\n            if (digit % 2 == 0) { // Check if digit is even\n                hasEvenDigit = true;\n                break; // No need to check further\n            }\n            temp /= 10;\n        }\n\n        if (!hasEvenDigit) {\n            result.push_back(num); // Step 5\n        }\n    }\n\n    sort(result.begin(), result.end()); // Step 6\n    return result; // Step 7\n}\n"}
{"task_id": "CPP/105", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Step 2: Initialize variables\n    vector<int> validIntegers;\n    map<int, string> intToString = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Step 8: Handle edge case for empty vector\n    if (arr.empty()) {\n        return {};\n    }\n\n    // Step 3: Filter valid integers\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            validIntegers.push_back(num);\n        }\n    }\n\n    // Step 4: Sort the filtered integers\n    sort(validIntegers.begin(), validIntegers.end());\n\n    // Step 5: Reverse the sorted integers\n    reverse(validIntegers.begin(), validIntegers.end());\n\n    // Step 6: Map integers to names\n    vector<string> result;\n    for (int num : validIntegers) {\n        result.push_back(intToString[num]);\n    }\n\n    // Step 7: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n// Helper function to calculate factorial\nint factorial(int i) {\n    int result = 1;\n    for (int j = 1; j <= i; j++) {\n        result *= j;\n    }\n    return result;\n}\n\n// Helper function to calculate sum from 1 to i\nint sumToN(int i) {\n    return (i * (i + 1)) / 2; // Using the formula for the sum of the first i natural numbers\n}\n\n// Main function to generate the vector\nvector<int> f(int n) {\n    vector<int> result(n);\n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            result[i - 1] = factorial(i); // Store factorial for even index\n        } else {\n            result[i - 1] = sumToN(i); // Store sum for odd index\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to check if a number is a palindrome\nbool is_palindrome(int num) {\n    string str = to_string(num);\n    string rev_str = string(str.rbegin(), str.rend());\n    return str == rev_str;\n}\n\n// Main function to count even and odd palindromes\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count}; // Return the counts as a vector\n}\n"}
{"task_id": "CPP/108", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool isNegative = (num < 0);\n    num = abs(num);\n    \n    while (num > 0) {\n        int digit = num % 10;\n        sum += digit;\n        num /= 10;\n    }\n    \n    if (isNegative) {\n        // Adjust for the first signed digit\n        sum -= 1; // Subtract 1 for the first signed digit\n    }\n    \n    return sum;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true; // Edge case for empty vector\n\n    int breakCount = 0;\n    int N = arr.size();\n\n    for (int i = 0; i < N; i++) {\n        if (arr[i] > arr[(i + 1) % N]) {\n            breakCount++;\n        }\n    }\n\n    // If there are more than one break points, return false\n    return breakCount <= 1;\n}\n"}
{"task_id": "CPP/110", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    int oddCount1 = 0;\n    int evenCount2 = 0;\n\n    // Count odd numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount1++;\n        }\n    }\n\n    // Count even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCount2++;\n        }\n    }\n\n    // Check if we can exchange to make lst1 all even\n    if (oddCount1 <= evenCount2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/111", "generation": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <map>\nusing namespace std;\n\nmap<char, int> histogram(string test) {\n    // Handle empty input\n    if (test.empty()) {\n        return {};\n    }\n\n    // Input Parsing\n    map<char, int> countMap;\n    stringstream ss(test);\n    string letter;\n\n    // Counting Occurrences\n    while (ss >> letter) {\n        countMap[letter[0]]++; // Assuming single lowercase letters\n    }\n\n    // Finding Maximum Occurrences\n    int maxCount = 0;\n    for (const auto& pair : countMap) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Output Formatting\n    map<char, int> result;\n    for (const auto& pair : countMap) {\n        if (pair.second == maxCount) {\n            result[pair.first] = pair.second;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/112", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n// Function to delete characters in c from string s\nstring deleteCharacters(const string& s, const string& c) {\n    string result;\n    for (char ch : s) {\n        if (c.find(ch) == string::npos) { // If ch is not in c\n            result += ch;\n        }\n    }\n    return result;\n}\n\n// Function to check if a string is a palindrome\nbool isPalindrome(const string& s) {\n    string reversed = s;\n    reverse(reversed.begin(), reversed.end());\n    return s == reversed;\n}\n\n// Main function to implement the requirement\nvector<string> reverse_delete(string s, string c) {\n    // Step 1: Delete characters\n    string modifiedString = deleteCharacters(s, c);\n    \n    // Step 2: Check for palindrome\n    bool palindromeCheck = isPalindrome(modifiedString);\n    \n    // Step 3: Format the result\n    vector<string> result;\n    result.push_back(modifiedString);\n    result.push_back(palindromeCheck ? \"True\" : \"False\");\n    \n    return result;\n}\n"}
{"task_id": "CPP/113", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result; // Initialize output vector\n\n    // Iterate over input vector\n    for (const string& str : lst) {\n        int odd_count = 0; // Initialize odd digit counter\n        \n        // Count odd digits\n        for (char ch : str) {\n            if ((ch - '0') % 2 != 0) { // Check if the character is an odd digit\n                odd_count++;\n            }\n        }\n        \n        // Format the output string\n        string formatted_string = \"the number of odd elements \" + to_string(odd_count) + \n                                  \"n the str\" + to_string(odd_count) + \n                                  \"ng \" + to_string(odd_count) + \n                                  \" of the \" + to_string(odd_count) + \"nput.\";\n        \n        result.push_back(formatted_string); // Collect results\n    }\n\n    return result; // Return the result\n}\n"}
{"task_id": "CPP/114", "generation": "#include <stdio.h>\n#include <vector>\n#include <limits.h> // For LLONG_MAX\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long minSum = LLONG_MAX; // Step 1: Initialize minSum\n    int n = nums.size(); // Get the size of the vector\n\n    // Step 2: Iterate through all possible subarrays\n    for (int start = 0; start < n; start++) {\n        long long currentSum = 0; // To hold the sum of the current subarray\n        for (int end = start; end < n; end++) {\n            currentSum += nums[end]; // Step 3: Calculate the sum of the current subarray\n            // Step 4: Update the minimum sum\n            if (currentSum < minSum) {\n                minSum = currentSum;\n            }\n        }\n    }\n\n    // Step 5: Return the result\n    return minSum;\n}\n"}
{"task_id": "CPP/115", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int total_buckets = 0;\n\n    for (const auto& well : grid) {\n        int water_units = 0;\n\n        // Count water units in the current well\n        for (int water : well) {\n            water_units += water; // Increment for each 1 found\n        }\n\n        // Calculate buckets needed for the current well\n        if (water_units > 0) {\n            total_buckets += (water_units / capacity) + (water_units % capacity > 0 ? 1 : 0);\n        }\n    }\n\n    return total_buckets;\n}\n\n// Example usage\n"}
{"task_id": "CPP/116", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint countOnes(int n) {\n    return __builtin_popcount(n); // Count the number of 1's in binary representation\n}\n\nvector<int> sort_array(vector<int> arr) {\n    auto comparator = [](int a, int b) {\n        int countA = countOnes(a);\n        int countB = countOnes(b);\n        if (countA == countB) {\n            return a < b; // Sort by value if counts are equal\n        }\n        return countA < countB; // Sort by number of ones\n    };\n\n    sort(arr.begin(), arr.end(), comparator);\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nint count_consonants(const string& word) {\n    int count = 0;\n    for (char c : word) {\n        c = tolower(c); // Normalize to lowercase\n        if (isalpha(c) && !strchr(\"aeiou\", c)) { // Check if it's a consonant\n            count++;\n        }\n    }\n    return count;\n}\n\nvector<string> select_words(string s, int n) {\n    if (s.empty()) return {};\n\n    vector<string> words;\n    stringstream ss(s);\n    string word;\n\n    // Split the string into words\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    vector<string> result;\n\n    // Filter words based on consonant count\n    for (const string& w : words) {\n        if (count_consonants(w) == n) {\n            result.push_back(w);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    string vowels = \"aeiouAEIOU\";\n    int length = word.length();\n\n    // Edge case: if the word is too short to have a vowel between consonants\n    if (length < 3) {\n        return \"\";\n    }\n\n    // Iterate from the end to the beginning of the string\n    for (int i = length - 2; i > 0; --i) {\n        // Check if the current character is a vowel\n        if (vowels.find(word[i]) != string::npos) {\n            // Check if the characters before and after are consonants\n            if (isalpha(word[i - 1]) && isalpha(word[i + 1]) && \n                vowels.find(word[i - 1]) == string::npos && \n                vowels.find(word[i + 1]) == string::npos) {\n                return string(1, word[i]); // Return the vowel found\n            }\n        }\n    }\n\n    return \"\"; // Return empty string if no valid vowel is found\n}\n"}
{"task_id": "CPP/119", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Helper function to count open and close parentheses\npair<int, int> count_parentheses(const string& s) {\n    int open = 0, close = 0;\n    for (char c : s) {\n        if (c == '(') open++;\n        else if (c == ')') close++;\n    }\n    return {open, close};\n}\n\n// Helper function to check if a concatenated string is balanced\nbool is_balanced(const string& s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') balance++;\n        else if (c == ')') balance--;\n        if (balance < 0) return false; // More closing than opening\n    }\n    return balance == 0; // Must be balanced at the end\n}\n\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0];\n    string s2 = lst[1];\n\n    // Check both concatenation orders\n    if (is_balanced(s1 + s2) || is_balanced(s2 + s1)) {\n        return \"Yes\";\n    }\n    return \"No\";\n}\n"}
{"task_id": "CPP/120", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Step 2: Input Validation\n    if (k == 0) return {}; // Return empty vector if k is 0\n    if (k > arr.size()) k = arr.size(); // Adjust k if it's greater than the length of arr\n\n    // Step 3: Sort arr in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n\n    // Step 4: Select the top k elements\n    vector<int> top_k(arr.begin(), arr.begin() + k);\n\n    // Step 5: Sort the selected elements in ascending order\n    sort(top_k.begin(), top_k.end());\n\n    // Step 6: Return the result\n    return top_k;\n}\n"}
{"task_id": "CPP/121", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0; // Initialize sum variable\n\n    // Iterate through the vector at even indices\n    for (int i = 0; i < lst.size(); i += 2) {\n        // Check if the element is odd\n        if (lst[i] % 2 != 0) {\n            sum += lst[i]; // Add to sum if odd\n        }\n    }\n\n    // Return the result\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    // Step 1: Validate k\n    if (k < 1 || k > arr.size()) {\n        return 0; // or handle error appropriately\n    }\n\n    // Step 2: Extract first k elements\n    vector<int> first_k_elements(arr.begin(), arr.begin() + k);\n    \n    // Step 3: Initialize sum\n    int sum = 0;\n\n    // Step 4: Filter and sum elements with at most two digits\n    for (int num : first_k_elements) {\n        if (num >= -99 && num <= 99) {\n            sum += num;\n        }\n    }\n\n    // Step 5: Return the result\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> collatz_sequence;\n    int current_term = n;\n\n    // Generate the Collatz sequence\n    while (current_term != 1) {\n        collatz_sequence.push_back(current_term);\n        if (current_term % 2 == 0) {\n            current_term /= 2; // Even case\n        } else {\n            current_term = 3 * current_term + 1; // Odd case\n        }\n    }\n    collatz_sequence.push_back(1); // Add the last term (1)\n\n    // Filter odd numbers\n    vector<int> odd_numbers;\n    for (int num : collatz_sequence) {\n        if (num % 2 != 0) {\n            odd_numbers.push_back(num);\n        }\n    }\n\n    // Sort the odd numbers\n    sort(odd_numbers.begin(), odd_numbers.end());\n\n    // Return the result\n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nbool valid_date(string date) {\n    // Input Validation\n    if (date.empty()) {\n        return false;\n    }\n\n    // Format Validation\n    if (date.size() != 10 || date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n\n    // Extract Month, Day, Year\n    int month, day, year;\n    char dash1, dash2;\n    stringstream ss(date);\n    ss >> month >> dash1 >> day >> dash2 >> year;\n\n    // Check if the extraction was successful\n    if (ss.fail() || dash1 != '-' || dash2 != '-') {\n        return false;\n    }\n\n    // Range Validation\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    if (day < 1) {\n        return false;\n    }\n\n    // Validate days based on month\n    if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && day > 31) {\n        return false;\n    }\n    if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30) {\n        return false;\n    }\n    if (month == 2) {\n        if (day > 29) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n\n    // Check for whitespace\n    if (txt.find(' ') != string::npos) {\n        stringstream ss(txt);\n        string word;\n        while (ss >> word) {\n            result.push_back(word);\n        }\n    }\n    // Check for commas\n    else if (txt.find(',') != string::npos) {\n        stringstream ss(txt);\n        string word;\n        while (getline(ss, word, ',')) {\n            result.push_back(word);\n        }\n    }\n    // Count odd-positioned lowercase letters\n    else {\n        int count = 0;\n        for (char c : txt) {\n            if (c >= 'a' && c <= 'z') {\n                int position = c - 'a'; // Get the position in the alphabet\n                if (position % 2 == 1) { // Check if the position is odd\n                    count++;\n                }\n            }\n        }\n        result.push_back(to_string(count)); // Convert count to string and add to result\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/126", "generation": "#include <stdio.h>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    // Step 1: Edge case handling\n    if (lst.size() <= 1) return true;\n\n    // Step 2: Count occurrences\n    unordered_map<int, int> countMap;\n    for (int num : lst) {\n        countMap[num]++;\n        if (countMap[num] > 2) return false; // More than twice\n    }\n\n    // Step 3: Check ascending order\n    for (size_t i = 0; i < lst.size() - 1; i++) {\n        if (lst[i] > lst[i + 1]) return false; // Not sorted\n    }\n\n    // Step 4: Return true if all checks passed\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    // Input validation\n    if (interval1[0] > interval1[1] || interval2[0] > interval2[1]) {\n        return \"NO\"; // Invalid input\n    }\n\n    // Calculate intersection\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n\n    // Check for intersection\n    if (start > end) {\n        return \"NO\"; // No intersection\n    }\n\n    // Calculate length of intersection\n    int length = end - start + 1;\n\n    // Check if length is prime\n    return isPrime(length) ? \"YES\" : \"NO\";\n}\n"}
{"task_id": "CPP/128", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    // Check for empty vector\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    // Initialize variables\n    int sum_magnitudes = 0;\n    int product_signs = 1;\n\n    // Iterate through the vector\n    for (int num : arr) {\n        sum_magnitudes += abs(num); // Calculate magnitude\n\n        if (num > 0) {\n            product_signs *= 1; // Positive sign\n        } else if (num < 0) {\n            product_signs *= -1; // Negative sign\n        } else {\n            product_signs = 0; // Zero encountered\n            break; // Exit loop early\n        }\n    }\n\n    // Calculate final result\n    return sum_magnitudes * product_signs;\n}\n"}
{"task_id": "CPP/129", "generation": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    int N = grid.size();\n    vector<int> min_path;\n\n    // Directions for moving up, down, left, right\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    // Helper function for DFS\n    function<void(int, int, int, vector<int>&)> dfs = [&](int x, int y, int depth, vector<int>& current_path) {\n        if (depth == k) {\n            if (min_path.empty() || current_path < min_path) {\n                min_path = current_path;\n            }\n            return;\n        }\n\n        for (auto& dir : directions) {\n            int new_x = x + dir.first;\n            int new_y = y + dir.second;\n            if (new_x >= 0 && new_x < N && new_y >= 0 && new_y < N) {\n                current_path.push_back(grid[new_x][new_y]);\n                dfs(new_x, new_y, depth + 1, current_path);\n                current_path.pop_back(); // backtrack\n            }\n        }\n    };\n\n    // Validate the grid\n    unordered_set<int> unique_values;\n    for (const auto& row : grid) {\n        for (int value : row) {\n            if (value < 1 || value > N * N || !unique_values.insert(value).second) {\n                throw invalid_argument(\"Grid must contain unique integers from 1 to N*N.\");\n            }\n        }\n    }\n\n    // Start DFS from each cell\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            vector<int> current_path = {grid[i][j]};\n            dfs(i, j, 1, current_path);\n        }\n    }\n\n    return min_path;\n}\n\n// Example usage\n"}
{"task_id": "CPP/130", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint computeTri(int n, vector<int>& memo) {\n    if (memo[n] != -1) return memo[n]; // Return cached value\n    if (n == 1) return memo[n] = 3; // Base case\n    if (n == 0) return memo[n] = 1; // Base case\n    if (n == 2) return memo[n] = 2; // Base case\n\n    if (n % 2 == 0) {\n        return memo[n] = 1 + n / 2; // Even case\n    } else {\n        return memo[n] = computeTri(n - 1, memo) + computeTri(n - 2, memo) + computeTri(n + 1, memo); // Odd case\n    }\n}\n\nvector<int> tri(int n) {\n    vector<int> memo(n + 1, -1); // Initialize memoization vector\n    vector<int> result(n + 1); // Result vector\n    for (int i = 0; i <= n; ++i) {\n        result[i] = computeTri(i, memo); // Compute and store results\n    }\n    return result; // Return the result vector\n}\n"}
{"task_id": "CPP/131", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nint digits(int n) {\n    // Convert integer to string\n    string strN = to_string(n);\n    \n    // Initialize product and flag\n    int product = 1;\n    bool hasOdd = false;\n    \n    // Iterate over each character in the string\n    for (char c : strN) {\n        int digit = c - '0'; // Convert char to int\n        if (digit % 2 != 0) { // Check if odd\n            product *= digit; // Multiply to product\n            hasOdd = true; // Mark that we found an odd digit\n        }\n    }\n    \n    // Return result\n    return hasOdd ? product : 0; // Return product or 0\n}\n"}
{"task_id": "CPP/132", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int open_count = 0;\n    int close_count = 0;\n    bool has_nested = false;\n\n    for (char ch : str) {\n        if (ch == '[') {\n            open_count++;\n            if (open_count > 1) {\n                has_nested = true; // Found potential nesting\n            }\n        } else if (ch == ']') {\n            close_count++;\n        }\n\n        // If closing brackets exceed opening brackets, return false\n        if (close_count > open_count) {\n            return false;\n        }\n    }\n\n    // Check if the counts are balanced and if nesting was found\n    return (open_count == close_count) && has_nested;\n}\n"}
{"task_id": "CPP/133", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0; // Initialize sum variable\n\n    // Iterate through the vector\n    for (float num : lst) {\n        // Round each element\n        int rounded_num = ceil(num);\n        \n        // Square the rounded value\n        int squared_value = rounded_num * rounded_num;\n        \n        // Accumulate the sum\n        sum += squared_value;\n    }\n\n    // Return the result\n    return sum;\n}\n"}
{"task_id": "CPP/134", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Step 2: Trim the string\n    size_t end = txt.find_last_not_of(' ');\n    if (end == string::npos) return false; // Step 3: Check for empty string\n    txt = txt.substr(0, end + 1); // Trimmed string\n\n    // Step 4: Extract the last character\n    char lastChar = txt.back();\n\n    // Step 5: Check if last character is alphabetical\n    if (!isalpha(lastChar)) return false;\n\n    // Step 6: Check if last character is part of a word\n    if (txt.size() > 1 && txt[end - 1] != ' ') return false;\n\n    // Step 7: Return the result\n    return true;\n}\n"}
{"task_id": "CPP/135", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int largestIndex = -1; // Initialize largestIndex\n\n    // Iterate through the vector\n    for (int i = 1; i < arr.size(); i++) {\n        // Check condition\n        if (arr[i] < arr[i - 1]) {\n            largestIndex = i; // Update largestIndex\n        }\n    }\n\n    // Return the result\n    return largestIndex; // Return the largest index found or -1\n}\n"}
{"task_id": "CPP/136", "generation": "#include <iostream>\n#include <vector>\n#include <limits.h> // For INT_MIN and INT_MAX\n\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = INT_MIN; // Initialize to minimum possible integer\n    int smallest_positive = INT_MAX; // Initialize to maximum possible integer\n\n    for (int num : lst) {\n        if (num < 0) {\n            if (num > largest_negative) {\n                largest_negative = num; // Update largest negative\n            }\n        } else if (num > 0) {\n            if (num < smallest_positive) {\n                smallest_positive = num; // Update smallest positive\n            }\n        }\n    }\n\n    // Handle edge cases\n    if (largest_negative == INT_MIN) {\n        largest_negative = 0; // No negative integers found\n    }\n    if (smallest_positive == INT_MAX) {\n        smallest_positive = 0; // No positive integers found\n    }\n\n    return {largest_negative, smallest_positive}; // Return the result\n}\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n#include <sstream>\n#include <locale>\n\nusing namespace std;\n\ndouble convert_to_double(const string& str) {\n    string normalized = str;\n    replace(normalized.begin(), normalized.end(), ',', '.'); // Replace ',' with '.'\n    return stod(normalized); // Convert to double\n}\n\nboost::any compare_one(boost::any a, boost::any b) {\n    double numA, numB;\n    bool isAString = false, isBString = false;\n\n    // Determine the type of 'a'\n    try {\n        numA = boost::any_cast<int>(a);\n    } catch (const boost::bad_any_cast&) {\n        try {\n            numA = boost::any_cast<float>(a);\n        } catch (const boost::bad_any_cast&) {\n            isAString = true;\n            string strA = boost::any_cast<string>(a);\n            numA = convert_to_double(strA);\n        }\n    }\n\n    // Determine the type of 'b'\n    try {\n        numB = boost::any_cast<int>(b);\n    } catch (const boost::bad_any_cast&) {\n        try {\n            numB = boost::any_cast<float>(b);\n        } catch (const boost::bad_any_cast&) {\n            isBString = true;\n            string strB = boost::any_cast<string>(b);\n            numB = convert_to_double(strB);\n        }\n    }\n\n    // Comparison logic\n    if (isAString && isBString) {\n        if (numA == numB) return \"None\";\n        return (numA > numB) ? b : a;\n    } else if (isAString) {\n        return (numA == numB) ? \"None\" : (numA > numB ? b : a);\n    } else if (isBString) {\n        return (numA == numB) ? \"None\" : (numA > numB ? b : a);\n    } else {\n        if (numA == numB) return \"None\";\n        return (numA > numB) ? a : b;\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include <stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Step 1: Check for minimum value\n    if (n < 8) return false;\n\n    // Step 2: Check for parity\n    if (n % 2 != 0) return false;\n\n    // Step 3: Calculate n / 2\n    int half_n = n / 2;\n\n    // Step 4: Check if half_n - 4 is non-negative\n    return (half_n - 4) >= 0;\n}\n"}
{"task_id": "CPP/139", "generation": "#include <stdio.h>\nusing namespace std;\n\n// Helper function to calculate factorial\nlong long factorial(int k) {\n    if (k == 0) return 1;\n    long long result = 1;\n    for (int i = 1; i <= k; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\n// Main function to calculate Brazilian factorial\nlong long special_factorial(int n) {\n    if (n <= 0) {\n        // Handle invalid input\n        return 0; // or throw an exception\n    }\n    \n    long long result = 1;\n    for (int i = n; i >= 1; --i) {\n        result *= factorial(i);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/140", "generation": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int space_count = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n        } else {\n            if (space_count > 0) {\n                if (space_count == 1) {\n                    result += '_'; // Replace single space with underscore\n                } else {\n                    result += '-'; // Replace more than 2 spaces with hyphen\n                }\n                space_count = 0; // Reset space count\n            }\n            result += c; // Append the non-space character\n        }\n    }\n\n    // Handle trailing spaces\n    if (space_count > 0) {\n        if (space_count == 1) {\n            result += '_';\n        } else {\n            result += '-';\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    int dot_count = 0;\n    int digit_count = 0;\n    size_t dot_position = string::npos;\n\n    // Step 2: Find the dot and count digits\n    for (size_t i = 0; i < file_name.length(); ++i) {\n        if (file_name[i] == '.') {\n            dot_count++;\n            dot_position = i;\n        } else if (isdigit(file_name[i])) {\n            digit_count++;\n        }\n    }\n\n    // Step 3: Check for exactly one dot\n    if (dot_count != 1) return \"No\";\n\n    // Step 4: Extract substrings\n    string before_dot = file_name.substr(0, dot_position);\n    string after_dot = file_name.substr(dot_position + 1);\n\n    // Step 5: Validate the substring before the dot\n    if (before_dot.empty() || !isalpha(before_dot[0])) return \"No\";\n\n    // Step 6: Check digit count\n    if (digit_count > 3) return \"No\";\n\n    // Step 7: Validate the substring after the dot\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\") return \"No\";\n\n    // Step 8: All checks passed\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;  // Initialize sum\n\n    // Iterate through the vector\n    for (size_t i = 0; i < lst.size(); i++) {\n        // Evaluate each index\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];  // Square if index is multiple of 3\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];  // Cube if index is multiple of 4 (not multiple of 3)\n        } else {\n            sum += lst[i];  // Leave unchanged\n        }\n    }\n\n    // Return the sum\n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to extract words with prime lengths\nstring words_in_sentence(string sentence) {\n    vector<string> words;\n    stringstream ss(sentence);\n    string word;\n\n    // Split the sentence into words\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    // Filter words with prime lengths\n    vector<string> prime_length_words;\n    for (const string& w : words) {\n        if (is_prime(w.length())) {\n            prime_length_words.push_back(w);\n        }\n    }\n\n    // Construct the output string\n    string result;\n    for (const string& w : prime_length_words) {\n        if (!result.empty()) {\n            result += \" \"; // Add space between words\n        }\n        result += w;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/144", "generation": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Step 2: Parse the fractions\n    int numerator_x, denominator_x, numerator_n, denominator_n;\n    \n    // Parse x\n    size_t pos = x.find('/');\n    numerator_x = stoi(x.substr(0, pos));\n    denominator_x = stoi(x.substr(pos + 1));\n    \n    // Parse n\n    pos = n.find('/');\n    numerator_n = stoi(n.substr(0, pos));\n    denominator_n = stoi(n.substr(pos + 1));\n    \n    // Step 3: Calculate the product\n    int numerator_product = numerator_x * numerator_n;\n    int denominator_product = denominator_x * denominator_n;\n    \n    // Step 4: Check if the product is a whole number\n    return (numerator_product % denominator_product == 0);\n}\n"}
{"task_id": "CPP/145", "generation": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility> // for std::pair\n\nusing namespace std;\n\n// Helper function to calculate the sum of digits\nint sum_of_digits(int num) {\n    int sum = 0;\n    num = abs(num); // Work with absolute value for digit sum\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Main function to order by points\nvector<int> order_by_points(vector<int> nums) {\n    vector<pair<int, int>> indexed_nums; // Pair of (number, original index)\n\n    // Populate the pairing structure\n    for (int i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back(make_pair(nums[i], i));\n    }\n\n    // Sort based on the sum of digits and original index\n    sort(indexed_nums.begin(), indexed_nums.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        int sum_a = sum_of_digits(a.first);\n        int sum_b = sum_of_digits(b.first);\n        if (sum_a == sum_b) {\n            return a.second < b.second; // Sort by index if sums are equal\n        }\n        return sum_a < sum_b; // Sort by sum of digits\n    });\n\n    // Extract sorted values\n    vector<int> sorted_nums;\n    for (const auto& p : indexed_nums) {\n        sorted_nums.push_back(p.first);\n    }\n\n    return sorted_nums;\n}\n"}
{"task_id": "CPP/146", "generation": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n// Helper function to check if a digit is odd\nbool isOdd(int digit) {\n    return (digit % 2 != 0);\n}\n\n// Helper function to get the first and last digits of a number\npair<int, int> getFirstAndLastDigits(int num) {\n    int lastDigit = abs(num) % 10; // Last digit\n    while (num >= 10) {\n        num /= 10; // Reduce the number to get the first digit\n    }\n    int firstDigit = abs(num); // First digit\n    return make_pair(firstDigit, lastDigit);\n}\n\n// Main function to filter numbers\nint specialFilter(vector<int> nums) {\n    int count = 0; // Counter for valid numbers\n    for (int num : nums) {\n        if (num > 10) { // Check if greater than 10\n            auto [firstDigit, lastDigit] = getFirstAndLastDigits(num);\n            if (isOdd(firstDigit) && isOdd(lastDigit)) { // Check if both digits are odd\n                count++; // Increment count\n            }\n        }\n    }\n    return count; // Return the final count\n}\n"}
{"task_id": "CPP/147", "generation": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    // Generate vector a\n    for (int i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    // Count occurrences of each modulo\n    int modCount[3] = {0, 0, 0};\n    for (int i = 0; i < n; ++i) {\n        modCount[a[i] % 3]++;\n    }\n\n    // Calculate valid triples\n    int count = 0;\n\n    // Count triples of the same mod\n    for (int i = 0; i < 3; ++i) {\n        if (modCount[i] >= 3) {\n            count += (modCount[i] * (modCount[i] - 1) * (modCount[i] - 2)) / 6;\n        }\n    }\n\n    // Count triples of different mods\n    count += modCount[0] * modCount[1] * modCount[2];\n\n    // Return the result\n    return count;\n}\n"}
{"task_id": "CPP/148", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n\n    // Input validation\n    if (find(planets.begin(), planets.end(), planet1) == planets.end() || \n        find(planets.begin(), planets.end(), planet2) == planets.end()) {\n        return {};\n    }\n\n    // Determine positions\n    int pos1 = find(planets.begin(), planets.end(), planet1) - planets.begin();\n    int pos2 = find(planets.begin(), planets.end(), planet2) - planets.begin();\n\n    // Identify the range\n    int start = min(pos1, pos2) + 1; // Start after planet1\n    int end = max(pos1, pos2); // End at planet2\n\n    // Collect and return the result\n    vector<string> result;\n    for (int i = start; i < end; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Step 3: Filtering\n    vector<string> filtered;\n    for (const auto& str : lst) {\n        if (str.length() % 2 == 0) { // Check for even length\n            filtered.push_back(str);\n        }\n    }\n\n    // Step 4: Sorting\n    sort(filtered.begin(), filtered.end(), [](const string &a, const string &b) {\n        if (a.length() == b.length()) {\n            return a < b; // Alphabetical order if lengths are equal\n        }\n        return a.length() < b.length(); // Sort by length\n    });\n\n    // Step 5: Return the result\n    return filtered;\n}\n"}
{"task_id": "CPP/150", "generation": "#include <stdio.h>\n#include <cmath>\n\nusing namespace std;\n\n// Helper function to check if a number is prime\nbool is_prime(int n) {\n    if (n < 2) return false; // Numbers less than 2 are not prime\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\n// Main function to return x or y based on the primality of n\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x; // n is prime\n    } else {\n        return y; // n is not prime\n    }\n}\n"}
{"task_id": "CPP/151", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    // Check for empty vector\n    if (lst.empty()) {\n        return 0;\n    }\n\n    // Initialize sum of squares\n    long long sum_of_squares = 0;\n\n    // Iterate through the vector\n    for (float num : lst) {\n        // Filter and process each element\n        if (num >= 0 && floor(num) == num) { // Check for non-negative integer\n            int int_num = static_cast<int>(num); // Convert to integer\n            if (int_num % 2 != 0) { // Check if odd\n                sum_of_squares += int_num * int_num; // Calculate square and add to sum\n            }\n        }\n    }\n\n    // Return the sum\n    return sum_of_squares;\n}\n"}
{"task_id": "CPP/152", "generation": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    // Step 2: Input Validation\n    if (game.size() != guess.size()) {\n        return {}; // Return an empty vector if sizes do not match\n    }\n\n    // Step 3: Initialize Result Vector\n    vector<int> result(game.size());\n\n    // Step 4: Iterate and Calculate Differences\n    for (size_t i = 0; i < game.size(); ++i) {\n        result[i] = abs(game[i] - guess[i]); // Calculate absolute difference\n    }\n\n    // Step 5: Return the Result\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cctype> // for isupper and islower functions\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = -1; // Initialize to a value lower than any possible strength\n    string strongest_extension = \"\";\n\n    for (const string& ext : extensions) {\n        int CAP = 0, SM = 0;\n\n        // Count uppercase and lowercase letters\n        for (char c : ext) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n\n        // Calculate strength\n        int strength = CAP - SM;\n\n        // Update strongest extension if necessary\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    // Construct and return the result\n    return class_name + \".\" + strongest_extension;\n}\n"}
{"task_id": "CPP/154", "generation": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n// Function to generate all rotations of a string\nvector<string> generateRotations(const string& b) {\n    vector<string> rotations;\n    int n = b.length();\n    for (int i = 0; i < n; ++i) {\n        rotations.push_back(b.substr(i) + b.substr(0, i)); // Create rotation\n    }\n    return rotations;\n}\n\n// Function to check if 'b' is a substring of 'a'\nbool isSubstring(const string& a, const string& b) {\n    return a.find(b) != string::npos; // Check for substring\n}\n\n// Main function to check cyclical pattern\nbool cycpattern_check(string a, string b) {\n    // Step 1: Input validation\n    if (a.empty() || b.empty()) {\n        return false;\n    }\n\n    // Step 2: Generate rotations of b\n    vector<string> rotations = generateRotations(b);\n\n    // Step 3: Check each rotation against a\n    for (const string& rotation : rotations) {\n        if (isSubstring(a, rotation)) {\n            return true; // Found a rotation as substring\n        }\n    }\n\n    // Step 4: No rotations matched\n    return false;\n}\n\n// Example usage\n"}
{"task_id": "CPP/155", "generation": "#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    // Step 1: Handle negative numbers\n    if (num < 0) {\n        num = -num; // Convert to absolute value\n    }\n\n    // Step 2: Initialize counters\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Step 3: Extract digits and count\n    while (num > 0) {\n        int digit = num % 10; // Get the last digit\n        if (digit % 2 == 0) {\n            even_count++; // Increment even counter\n        } else {\n            odd_count++; // Increment odd counter\n        }\n        num /= 10; // Remove the last digit\n    }\n\n    // Step 4: Prepare the result vector\n    vector<int> result = {even_count, odd_count};\n    return result; // Return the counts\n}\n"}
{"task_id": "CPP/156", "generation": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define Roman numeral mapping\n    vector<pair<int, string>> roman_map = {\n        {1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"},\n        {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"},\n        {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"},\n        {1, \"I\"}\n    };\n\n    // Input validation\n    if (number < 1 || number > 1000) {\n        return \"\"; // or handle error\n    }\n\n    // Conversion logic\n    string result = \"\";\n    for (const auto& pair : roman_map) {\n        while (number >= pair.first) {\n            result += pair.second; // Append Roman numeral\n            number -= pair.first;   // Subtract value\n        }\n    }\n\n    // Convert to lowercase\n    for (auto &c : result) {\n        c = tolower(c);\n    }\n\n    // Return the result\n    return result;\n}\n"}
{"task_id": "CPP/157", "generation": "#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Step 2: Input Validation\n    if (a <= 0 || b <= 0 || c <= 0) {\n        return false;\n    }\n\n    // Step 3: Identify the Longest Side\n    float hypotenuse, side1, side2;\n    if (a >= b && a >= c) {\n        hypotenuse = a;\n        side1 = b;\n        side2 = c;\n    } else if (b >= a && b >= c) {\n        hypotenuse = b;\n        side1 = a;\n        side2 = c;\n    } else {\n        hypotenuse = c;\n        side1 = a;\n        side2 = b;\n    }\n\n    // Step 4: Check the Pythagorean Condition\n    float hypotenuse_squared = hypotenuse * hypotenuse;\n    float sum_of_squares = side1 * side1 + side2 * side2;\n\n    // Step 5: Return the Result\n    return (sum_of_squares == hypotenuse_squared);\n}\n"}
{"task_id": "CPP/158", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string maxWord = \"\";\n    int maxUniqueCount = 0;\n\n    for (const string& word : words) {\n        set<char> uniqueChars(word.begin(), word.end());\n        int uniqueCount = uniqueChars.size();\n\n        if (uniqueCount > maxUniqueCount || (uniqueCount == maxUniqueCount && word < maxWord)) {\n            maxWord = word;\n            maxUniqueCount = uniqueCount;\n        }\n    }\n\n    return maxWord;\n}\n"}
{"task_id": "CPP/159", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int totalEaten;\n    int carrotsLeft;\n\n    // Calculate total eaten carrots\n    if (remaining >= need) {\n        totalEaten = number + need;\n        carrotsLeft = remaining - need;\n    } else {\n        totalEaten = number + remaining;\n        carrotsLeft = 0; // All remaining carrots are eaten\n    }\n\n    // Return the result as a vector\n    return {totalEaten, carrotsLeft};\n}\n"}
{"task_id": "CPP/160", "generation": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stdexcept>\n#include <cmath>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    // Step 1: Input Validation\n    if (operato.size() != operand.size() - 1) {\n        throw invalid_argument(\"Operator vector length must be one less than operand vector length.\");\n    }\n    \n    for (int num : operand) {\n        if (num < 0) {\n            throw invalid_argument(\"Operand vector must contain non-negative integers.\");\n        }\n    }\n    \n    for (const string& op : operato) {\n        if (op != \"+\" && op != \"-\" && op != \"*\" && op != \"//\" && op != \"**\") {\n            throw invalid_argument(\"Invalid operator in operator vector.\");\n        }\n    }\n\n    // Step 2: Initialize result\n    int result = operand[0];\n\n    // Step 3: Iterate through operators and operands\n    for (size_t i = 0; i < operato.size(); ++i) {\n        string op = operato[i];\n        int next_operand = operand[i + 1];\n\n        // Step 4: Handle each operation\n        if (op == \"+\") {\n            result += next_operand;\n        } else if (op == \"-\") {\n            result -= next_operand;\n        } else if (op == \"*\") {\n            result *= next_operand;\n        } else if (op == \"//\") {\n            if (next_operand == 0) throw invalid_argument(\"Division by zero.\");\n            result /= next_operand; // Floor division\n        } else if (op == \"**\") {\n            result = pow(result, next_operand);\n        }\n    }\n\n    // Step 5: Return the result\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring solve(string s) {\n    string result;\n    bool hasLetter = false;\n\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            if (islower(c)) {\n                result += toupper(c);\n            } else {\n                result += tolower(c);\n            }\n        } else {\n            result += c;\n        }\n    }\n\n    if (!hasLetter) {\n        reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/162", "generation": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n#include <sstream>\n#include <iomanip>\n\nusing namespace std;\n\nstring string_to_md5(string text) {\n    // Check for empty input\n    if (text.empty()) {\n        return \"None\"; // or return nullptr if using pointers\n    }\n\n    // Initialize MD5 context\n    MD5_CTX md5Context;\n    MD5_Init(&md5Context);\n\n    // Update MD5 with input string\n    MD5_Update(&md5Context, text.c_str(), text.length());\n\n    // Finalize the MD5 hash\n    unsigned char hash[MD5_DIGEST_LENGTH];\n    MD5_Final(hash, &md5Context);\n\n    // Convert to hexadecimal string\n    stringstream hexString;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        hexString << hex << setw(2) << setfill('0') << (int)hash[i];\n    }\n\n    // Return the MD5 hash\n    return hexString.str();\n}\n"}
{"task_id": "CPP/163", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm> // for std::sort\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    // Normalize Input\n    int min_value = min(a, b);\n    int max_value = max(a, b);\n    \n    // Initialize a Collection\n    vector<int> even_digits;\n    \n    // Iterate Through the Range\n    for (int i = min_value; i <= max_value; ++i) {\n        // Check if the digit is even and less than 10\n        if (i % 2 == 0 && i < 10) {\n            even_digits.push_back(i);\n        }\n    }\n    \n    // Sort the Collection (if necessary)\n    sort(even_digits.begin(), even_digits.end());\n    \n    // Return the Result\n    return even_digits;\n}\n"}
