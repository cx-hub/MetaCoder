{"task_id": "CPP/0", "generation": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    for (int i = 0; i < numbers.size(); i++) {\n        for (int j = i + 1; j < numbers.size(); j++) {\n            if (abs(numbers[i] - numbers[j]) < threshold) {\n                return true; // Found two numbers closer than the threshold\n            }\n        }\n    }\n    return false; // No such pair found\n}\n"}
{"task_id": "CPP/1", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    // Remove spaces from the input string\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n\n    for (char ch : paren_string) {\n        if (ch == '(') {\n            if (balance == 0) {\n                current_group.clear(); // Start a new group\n            }\n            current_group += ch;\n            balance++;\n        } else if (ch == ')') {\n            current_group += ch;\n            balance--;\n            if (balance == 0) {\n                result.push_back(current_group); // Add the completed group to the result\n            }\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat truncate_number(float number) {\n    int integerPart = static_cast<int>(number); // Get the integer part\n    float decimalPart = number - integerPart; // Calculate the decimal part\n    return decimalPart; // Return the decimal part\n}\n"}
{"task_id": "CPP/3", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with zero balance\n    for (int operation : operations) {\n        balance += operation; // Update balance with each operation\n        if (balance < 0) { // Check if balance falls below zero\n            return true; // Return true if it does\n        }\n    }\n    return false; // Return false if balance never falls below zero\n}\n"}
{"task_id": "CPP/4", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    float sum = 0.0;\n    int n = numbers.size();\n\n    // Calculate the mean\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / n;\n\n    // Calculate the Mean Absolute Deviation\n    float mad_sum = 0.0;\n    for (float num : numbers) {\n        mad_sum += fabs(num - mean);\n    }\n    \n    return mad_sum / n; // Return the average of absolute deviations\n}\n"}
{"task_id": "CPP/5", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) { // Avoid adding delimiter after the last element\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths;\n    stringstream ss(paren_string);\n    string group;\n\n    while (ss >> group) {\n        int current_depth = 0;\n        int max_depth = 0;\n\n        for (char ch : group) {\n            if (ch == '(') {\n                current_depth++;\n                max_depth = max(max_depth, current_depth);\n            } else if (ch == ')') {\n                current_depth--;\n            }\n        }\n        \n        depths.push_back(max_depth);\n    }\n\n    return depths;\n}\n"}
{"task_id": "CPP/7", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> result;\n    for (const string& str : strings) {\n        if (str.find(substring) != string::npos) {\n            result.push_back(str);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/8", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    // If the input vector is empty, we should return (0, 1)\n    if (numbers.empty()) {\n        product = 1; // Product should be 1 for empty input\n    }\n\n    return {sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> result;\n    int current_max = INT_MIN; // Initialize current_max to the smallest integer\n\n    for (int num : numbers) {\n        current_max = max(current_max, num); // Update the current maximum\n        result.push_back(current_max); // Add the current maximum to the result\n    }\n\n    return result; // Return the vector of rolling maximums\n}\n"}
{"task_id": "CPP/10", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome(\"\") \n    \"\" \n    >>> make_palindrome(\"cat\") \n    \"catac\" \n    >>> make_palindrome(\"cata\") \n    \"catac\" \n    */\n    \n    int n = str.length();\n    for (int i = n; i >= 0; --i) {\n        // Check if the substring from i to the end is a palindrome\n        if (is_palindrome(str.substr(i))) {\n            // Append the reverse of the prefix before the palindromic suffix\n            return str + string(str.begin(), str.begin() + i);\n        }\n    }\n    return str; // In case the input string is already a palindrome\n}\n"}
{"task_id": "CPP/11", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    int length = a.length();\n    \n    // Ensure both strings are of the same length\n    for (int i = 0; i < length; i++) {\n        // Perform XOR operation\n        if (a[i] == b[i]) {\n            result += '0'; // If both bits are the same, result is 0\n        } else {\n            result += '1'; // If bits are different, result is 1\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"None\"; // Return \"None\" for empty input\n    }\n    \n    string longestStr = strings[0]; // Initialize with the first string\n    for (const string& str : strings) {\n        if (str.length() > longestStr.length()) {\n            longestStr = str; // Update longestStr if a longer string is found\n        }\n    }\n    \n    return longestStr; // Return the longest string found\n}\n"}
{"task_id": "CPP/13", "generation": "#include<stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (int i = 1; i <= str.length(); i++) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        ss << i;\n        if (i < n) {\n            ss << \" \"; // Add space only if it's not the last number\n        }\n    }\n    return ss.str();\n}\n"}
{"task_id": "CPP/16", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    set<char> distinctChars;\n    for (char c : str) {\n        distinctChars.insert(tolower(c)); // Convert to lowercase and insert into the set\n    }\n    return distinctChars.size(); // The size of the set gives the count of distinct characters\n}\n"}
{"task_id": "CPP/17", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    stringstream ss(music_string);\n    string note;\n\n    while (ss >> note) {\n        if (note == \"o\") {\n            beats.push_back(4); // whole note\n        } else if (note == \"o|\") {\n            beats.push_back(2); // half note\n        } else if (note == \".|\") {\n            beats.push_back(1); // quarter note\n        }\n    }\n\n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (substring.empty() || str.empty()) {\n        return 0;\n    }\n    \n    int count = 0;\n    size_t pos = str.find(substring);\n    \n    while (pos != string::npos) {\n        count++;\n        pos = str.find(substring, pos + 1); // Move to the next position to allow overlapping\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<vector>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Map to convert number words to their corresponding integer values\n    map<string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Split the input string into words\n    stringstream ss(numbers);\n    vector<string> num_words;\n    string word;\n\n    while (ss >> word) {\n        num_words.push_back(word);\n    }\n\n    // Sort the words based on their corresponding integer values\n    sort(num_words.begin(), num_words.end(), [&](const string &a, const string &b) {\n        return num_map[a] < num_map[b];\n    });\n\n    // Join the sorted words into a single string\n    string result;\n    for (const string &num : num_words) {\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += num;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/20", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Sort the numbers to make it easier to find the closest pairs\n    sort(numbers.begin(), numbers.end());\n    \n    // Initialize variables to store the closest pair\n    float minDiff = FLT_MAX; // Use a large initial value\n    vector<float> closestPair;\n\n    // Iterate through the sorted numbers to find the closest pair\n    for (size_t i = 0; i < numbers.size() - 1; i++) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < minDiff) {\n            minDiff = diff;\n            closestPair = {numbers[i], numbers[i + 1]};\n        }\n    }\n\n    return closestPair;\n}\n"}
{"task_id": "CPP/21", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    float minVal = *min_element(numbers.begin(), numbers.end());\n    float maxVal = *max_element(numbers.begin(), numbers.end());\n    \n    vector<float> rescaled;\n    for (float num : numbers) {\n        float scaled = (num - minVal) / (maxVal - minVal);\n        rescaled.push_back(scaled);\n    }\n    \n    return rescaled;\n}\n"}
{"task_id": "CPP/22", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\n#include <typeinfo>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        // Check if the value is of type int\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint strlen(string str) {\n    int length = 0;\n    for (char c : str) {\n        length++;\n    }\n    return length;\n}\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; i--) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1; // In case n is 1, the largest divisor is 1\n}\n"}
{"task_id": "CPP/25", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    // Start with the smallest prime factor\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    // If n is still greater than 1, then it is a prime factor\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> countMap;\n    // Count occurrences of each number\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n    \n    vector<int> result;\n    // Add numbers that occur only once to the result\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) {\n        if (isupper(c)) {\n            c = tolower(c);\n        } else if (islower(c)) {\n            c = toupper(c);\n        }\n    }\n    return str;\n}\n"}
{"task_id": "CPP/28", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\";\n    for (const string& str : strings) {\n        result += str; // Concatenate each string to the result\n    }\n    return result; // Return the concatenated string\n}\n"}
{"task_id": "CPP/29", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered;\n    for (const string& str : strings) {\n        if (str.find(prefix) == 0) { // Check if the string starts with the prefix\n            filtered.push_back(str);\n        }\n    }\n    return filtered;\n}\n"}
{"task_id": "CPP/30", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positives;\n    for (float num : l) {\n        if (num > 0) {\n            positives.push_back(num);\n        }\n    }\n    return positives;\n}\n"}
{"task_id": "CPP/31", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    if (n <= 3) return true; // 2 and 3 are prime numbers\n\n    // Check for even numbers and multiples of 3\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    // Check for factors from 5 to the square root of n\n    for (long long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n"}
{"task_id": "CPP/32", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    /* \n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[2] * x^2 + .... xs[n] * x^n \n    */\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    /*\n    xs are coefficients of a polynomial. find_zero finds x such that poly(x) = 0. find_zero returns only one zero point, even if there are many. \n    Moreover, find_zero only takes list xs having even number of coefficients and largest non-zero coefficient as it guarantees a solution.\n    >>> round(find_zero([1, 2]), 2) #f(x) = 1 + 2x \n    -0.5 \n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 \n    1.0\n    */\n    \n    double left = -1000; // Starting point for the search\n    double right = 1000; // Ending point for the search\n    double mid;\n    \n    // Using binary search to find the root\n    while (right - left > 1e-7) { // Precision threshold\n        mid = (left + right) / 2;\n        if (poly(xs, mid) == 0) {\n            return mid; // Found exact zero\n        } else if (poly(xs, mid) > 0) {\n            right = mid; // Move left\n        } else {\n            left = mid; // Move right\n        }\n    }\n    \n    return (left + right) / 2; // Return the midpoint as the root\n}\n"}
{"task_id": "CPP/33", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> sorted_third;\n\n    // Collect elements at indices divisible by 3\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            sorted_third.push_back(l[i]);\n        }\n    }\n\n    // Sort the collected elements\n    sort(sorted_third.begin(), sorted_third.end());\n\n    // Replace elements in the original vector at indices divisible by 3\n    int sorted_index = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l[i] = sorted_third[sorted_index++];\n        }\n    }\n\n    return l;\n}\n"}
{"task_id": "CPP/34", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the vector to bring duplicates together\n    sort(l.begin(), l.end());\n    \n    // Use the unique function to remove duplicates\n    auto last = unique(l.begin(), l.end());\n    \n    // Resize the vector to contain only unique elements\n    l.erase(last, l.end());\n    \n    return l;\n}\n"}
{"task_id": "CPP/35", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    float maxVal = l[0]; // Initialize maxVal with the first element\n    for (int i = 1; i < l.size(); i++) {\n        if (l[i] > maxVal) {\n            maxVal = l[i]; // Update maxVal if current element is greater\n        }\n    }\n    return maxVal; // Return the maximum value found\n}\n"}
{"task_id": "CPP/36", "generation": "#include<stdio.h>\nusing namespace std;\n\nint countDigit7(int num) {\n    int count = 0;\n    while (num > 0) {\n        if (num % 10 == 7) {\n            count++;\n        }\n        num /= 10;\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int totalCount = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            totalCount += countDigit7(i);\n        }\n    }\n    return totalCount;\n}\n"}
{"task_id": "CPP/37", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Create a vector to hold the even indexed elements\n    vector<float> even_indices;\n    \n    // Extract even indexed elements\n    for (int i = 0; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    \n    // Sort the even indexed elements\n    sort(even_indices.begin(), even_indices.end());\n    \n    // Place the sorted even indexed elements back into the original vector\n    for (int i = 0, j = 0; i < l.size(); i += 2, j++) {\n        l[i] = even_indices[j];\n    }\n    \n    return l;\n}\n"}
{"task_id": "CPP/38", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_cyclic(string s){ \n    // returns encoded string by cycling groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l=s.length();\n    int num=(l+2)/3;\n    string x,output;\n    int i;\n    for (i=0;i*3<l;i++)\n    {\n        //cycle elements in each group. Unless group has fewer elements than 3.\n        x=s.substr(i*3,3);\n        if (x.length()==3) x=x.substr(1)+x[0];\n        output=output+x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s){ \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string. \n    */\n    int l = s.length();\n    string output;\n    int i;\n    for (i = 0; i * 3 < l; i++)\n    {\n        // Get the current group of three characters\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            // Shift the last character to the front\n            output += x[2]; // last character\n            output += x.substr(0, 2); // first two characters\n        } else {\n            // If the group has fewer than 3 characters, just append it\n            output += x;\n        }\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <stdio.h>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\n// Function to return the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    vector<int> fibs = {0, 1}; // Starting Fibonacci numbers\n    vector<int> prime_fibs; // To store prime Fibonacci numbers\n\n    // Generate Fibonacci numbers and check for primes\n    while (prime_fibs.size() < n) {\n        int next_fib = fibs[fibs.size() - 1] + fibs[fibs.size() - 2];\n        fibs.push_back(next_fib);\n\n        // Check if the Fibonacci number is prime\n        if (is_prime(next_fib)) {\n            prime_fibs.push_back(next_fib);\n        }\n    }\n\n    // Return the n-th prime Fibonacci number\n    return prime_fibs[n - 1];\n}\n"}
{"task_id": "CPP/40", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false; // Need at least 3 numbers to form a triplet\n\n    // Sort the array to use two-pointer technique\n    sort(l.begin(), l.end());\n\n    for (int i = 0; i < n - 2; i++) {\n        // Skip duplicates for the first element\n        if (i > 0 && l[i] == l[i - 1]) continue;\n\n        int left = i + 1;\n        int right = n - 1;\n\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true; // Found a triplet\n            } else if (sum < 0) {\n                left++; // Need a larger sum\n            } else {\n                right--; // Need a smaller sum\n            }\n        }\n    }\n    return false; // No triplet found\n}\n"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Each car from the left will collide with each car from the right\n    return n * n; // Total collisions = n (left) * n (right)\n}\n"}
{"task_id": "CPP/42", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (int i = 0; i < l.size(); i++) {\n        l[i] += 1; // Increment each element by 1\n    }\n    return l; // Return the modified vector\n}\n"}
{"task_id": "CPP/43", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen;\n    for (int num : l) {\n        // Check if the negative of the current number exists in the set\n        if (seen.count(-num)) {\n            return true; // Found a pair that sums to zero\n        }\n        seen.insert(num); // Add the current number to the set\n    }\n    return false; // No pairs found that sum to zero\n}\n"}
{"task_id": "CPP/44", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (base < 2 || base >= 10) {\n        return \"\"; // Invalid base\n    }\n    \n    string result = \"\";\n    do {\n        int remainder = x % base;\n        result = to_string(remainder) + result; // Prepend the remainder\n        x /= base;\n    } while (x > 0);\n    \n    return result;\n}\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h; // Area of triangle = 0.5 * base * height\n}\n"}
{"task_id": "CPP/46", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    int fib[n + 1];\n    fib[0] = 0;\n    fib[1] = 0;\n    fib[2] = 2;\n    fib[3] = 0;\n\n    for (int i = 4; i <= n; i++) {\n        fib[i] = fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4];\n    }\n\n    return fib[n];\n}\n"}
{"task_id": "CPP/47", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Calculate the size of the vector\n    int n = l.size();\n    \n    // If the size is odd, return the middle element\n    if (n % 2 != 0) {\n        return l[n / 2];\n    } else {\n        // If the size is even, return the average of the two middle elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n"}
{"task_id": "CPP/49", "generation": "#include<stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0) return 1; // 2^0 is 1\n    long long result = 1; // Use long long to avoid overflow\n    long long base = 2; // Base is 2\n\n    // Calculate 2^n % p using iterative method\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base\n        n /= 2; // Divide n by 2\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_shift(string s){\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i=0; i<s.length(); i++)\n    {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';   \n        out = out + (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s){\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i=0; i<s.length(); i++)\n    {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a'; // Adding 26 to ensure non-negative result\n        out = out + (char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        // Check if the character is a vowel (both lowercase and uppercase)\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n            c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            result += c; // Append non-vowel characters to the result\n        }\n    }\n    return result; // Return the string without vowels\n}\n"}
{"task_id": "CPP/52", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false; // Return false if any number is greater than or equal to the threshold\n        }\n    }\n    return true; // Return true if all numbers are below the threshold\n}\n"}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n"}
{"task_id": "CPP/54", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Use a set to store unique characters from both strings\n    set<char> chars0(s0.begin(), s0.end());\n    set<char> chars1(s1.begin(), s1.end());\n    \n    // Compare the sets of unique characters\n    return chars0 == chars1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) return 0; // Fibonacci of 0 is 0\n    if (n == 1) return 1; // Fibonacci of 1 is 1\n\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; i++) {\n        c = a + b; // Calculate the next Fibonacci number\n        a = b;     // Move to the next pair\n        b = c;\n    }\n    return b; // Return the n-th Fibonacci number\n}\n"}
{"task_id": "CPP/56", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // To keep track of the balance of brackets\n    for (char ch : brackets) {\n        if (ch == '<') {\n            balance++; // Increment for opening bracket\n        } else if (ch == '>') {\n            balance--; // Decrement for closing bracket\n        }\n        // If at any point balance goes negative, it means there's a closing bracket without a matching opening bracket\n        if (balance < 0) {\n            return false;\n        }\n    }\n    // At the end, balance should be zero for all opening brackets to be matched\n    return balance == 0;\n}\n"}
{"task_id": "CPP/57", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() < 2) return true; // A single element or empty vector is considered monotonic\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); i++) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false; // Found an increasing pair\n        } else if (l[i] < l[i - 1]) {\n            increasing = false; // Found a decreasing pair\n        }\n    }\n\n    return increasing || decreasing; // Return true if either increasing or decreasing\n}\n"}
{"task_id": "CPP/58", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort both vectors to prepare for finding common elements\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n    \n    vector<int> result;\n    // Use two pointers to find common elements\n    int i = 0, j = 0;\n    \n    while (i < l1.size() && j < l2.size()) {\n        if (l1[i] < l2[j]) {\n            i++;\n        } else if (l1[i] > l2[j]) {\n            j++;\n        } else {\n            // Found a common element\n            if (result.empty() || result.back() != l1[i]) {\n                result.push_back(l1[i]);\n            }\n            i++;\n            j++;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/59", "generation": "#include<stdio.h>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int largest = -1;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        largest = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest = i;\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        largest = n;\n    }\n\n    return largest;\n}\n"}
{"task_id": "CPP/60", "generation": "#include<stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2; // Using the formula for the sum of the first n natural numbers\n}\n"}
{"task_id": "CPP/61", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // To keep track of the balance of brackets\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++; // Increment for an opening bracket\n        } else if (ch == ')') {\n            balance--; // Decrement for a closing bracket\n        }\n        // If balance goes negative, it means there's a closing bracket without a matching opening bracket\n        if (balance < 0) {\n            return false;\n        }\n    }\n    // At the end, balance should be zero for all brackets to be matched\n    return balance == 0;\n}\n"}
{"task_id": "CPP/62", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    int degree = xs.size() - 1; // Degree of the polynomial\n\n    for (int i = 1; i < xs.size(); i++) {\n        // The derivative of a_i * x^i is i * a_i\n        result.push_back(i * xs[i]);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    int a = 0, b = 0, c = 1; // fibfib(0), fibfib(1), fibfib(2)\n    int result = 0;\n\n    for (int i = 3; i <= n; i++) {\n        result = a + b + c; // fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n        a = b; // Update fibfib(n-3)\n        b = c; // Update fibfib(n-2)\n        c = result; // Update fibfib(n-1)\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/64", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    // Convert the string to lowercase to handle both cases\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n    \n    // Check each character in the string\n    for (int i = 0; i < s.length(); i++) {\n        char c = s[i];\n        // Check for vowels\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n        // Check if 'y' is at the end of the string\n        if (c == 'y' && i == s.length() - 1) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string numStr = to_string(x);\n    int len = numStr.length();\n    \n    // If shift is greater than the number of digits, reverse the string\n    if (shift >= len) {\n        reverse(numStr.begin(), numStr.end());\n        return numStr;\n    }\n    \n    // Perform the circular shift\n    string shifted = numStr.substr(len - shift) + numStr.substr(0, len - shift);\n    return shifted;\n}\n"}
{"task_id": "CPP/66", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/67", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0, oranges = 0;\n    stringstream ss(s);\n    string word;\n\n    // Parse the string to find the number of apples and oranges\n    while (ss >> word) {\n        if (word == \"apples\") {\n            ss >> apples; // Get the number before \"apples\"\n        } else if (word == \"oranges\") {\n            ss >> oranges; // Get the number before \"oranges\"\n        }\n    }\n\n    // Calculate the number of mangoes\n    return n - apples - oranges;\n}\n"}
{"task_id": "CPP/68", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    vector<int> result;\n    int smallest_even = -1; // Initialize to -1 to indicate no even found\n    int smallest_index = -1; // Initialize to -1 to indicate no index found\n\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            if (smallest_even == -1 || arr[i] < smallest_even) {\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_even != -1) {\n        result.push_back(smallest_even);\n        result.push_back(smallest_index);\n    }\n\n    return result; // Return the result vector\n}\n"}
{"task_id": "CPP/69", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_map>\n#include<algorithm>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequencyMap;\n    \n    // Count the frequency of each number\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n    \n    int result = -1;\n    \n    // Check for the greatest integer that meets the criteria\n    for (const auto& pair : frequencyMap) {\n        int num = pair.first;\n        int freq = pair.second;\n        \n        // Check if the frequency is greater than or equal to the number itself\n        if (freq >= num) {\n            result = max(result, num);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/70", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    vector<int> result;\n    if (lst.empty()) {\n        return result; // Return empty if input is empty\n    }\n    \n    // Sort the input list\n    sort(lst.begin(), lst.end());\n    \n    // Use two pointers to pick elements from both ends\n    int left = 0;\n    int right = lst.size() - 1;\n    \n    // Alternate between the smallest and largest remaining elements\n    while (left <= right) {\n        if (left == right) {\n            result.push_back(lst[left]); // Add the last remaining element\n        } else {\n            result.push_back(lst[left]); // Add the smallest\n            result.push_back(lst[right]); // Add the largest\n        }\n        left++;\n        right--;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b > c && a + c > b && b + c > a) {\n        // Calculate the semi-perimeter\n        float s = (a + b + c) / 2;\n        // Calculate the area using Heron's formula\n        float area = sqrt(s * (s - a) * (s - b) * (s - c));\n        // Return the area rounded to 2 decimal points\n        return round(area * 100) / 100;\n    } else {\n        // Return -1 if the sides do not form a valid triangle\n        return -1;\n    }\n}\n"}
{"task_id": "CPP/72", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    int n = q.size();\n    \n    // Check if the vector is palindromic\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) {\n            return false; // Not balanced\n        }\n    }\n    \n    // Calculate the sum of the elements\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    \n    // Check if the sum is less than or equal to the maximum weight\n    return sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n"}
{"task_id": "CPP/74", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int totalChars1 = 0;\n    int totalChars2 = 0;\n\n    // Calculate total characters in lst1\n    for (const string& str : lst1) {\n        totalChars1 += str.size();\n    }\n\n    // Calculate total characters in lst2\n    for (const string& str : lst2) {\n        totalChars2 += str.size();\n    }\n\n    // Compare total characters and return the appropriate vector\n    if (totalChars1 < totalChars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nbool is_multiply_prime(int a) {\n    vector<int> primes;\n    for (int i = 2; i < 100; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n\n    for (int i = 0; i < primes.size(); i++) {\n        for (int j = i; j < primes.size(); j++) {\n            for (int k = j; k < primes.size(); k++) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/76", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n <= 1) return false; // n must be greater than 1 for valid powers\n    if (x < 1) return false; // x must be a positive integer\n\n    double power = log(x) / log(n); // Calculate the logarithm base n of x\n    return abs(power - round(power)) < 1e-9; // Check if power is an integer\n}\n"}
{"task_id": "CPP/77", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool iscube(int a) {\n    // Calculate the cube root of the absolute value of a\n    int cubeRoot = round(cbrt(abs(a)));\n    \n    // Check if the cube of the calculated cube root equals to a\n    return (cubeRoot * cubeRoot * cubeRoot == abs(a));\n}\n"}
{"task_id": "CPP/78", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint hex_key(string num) {\n    // Set of prime hexadecimal digits\n    const string primeHexDigits = \"2357BD\"; // B = 11, D = 13 in decimal\n    int count = 0;\n\n    // Iterate through each character in the input string\n    for (char c : num) {\n        // Check if the character is in the set of prime hexadecimal digits\n        if (primeHexDigits.find(c) != string::npos) {\n            count++;\n        }\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    string binary = \"\";\n    \n    // Convert decimal to binary\n    while (decimal > 0) {\n        binary = to_string(decimal % 2) + binary; // Prepend the binary digit\n        decimal /= 2; // Divide by 2 to get the next digit\n    }\n    \n    // Add the \"db\" prefix and suffix\n    return \"db\" + binary + \"db\";\n}\n"}
{"task_id": "CPP/80", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n    \n    // Iterate through the string and check every 3 consecutive characters\n    for (int i = 0; i <= s.length() - 3; i++) {\n        // Check if the three characters are distinct\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false; // Found non-distinct characters\n        }\n    }\n    \n    return true; // All sets of 3 characters are distinct\n}\n"}
{"task_id": "CPP/81", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letterGrades;\n    \n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letterGrades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letterGrades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letterGrades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letterGrades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letterGrades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letterGrades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letterGrades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letterGrades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letterGrades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letterGrades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letterGrades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letterGrades.push_back(\"D-\");\n        } else {\n            letterGrades.push_back(\"E\");\n        }\n    }\n    \n    return letterGrades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\nbool prime_length(string str) {\n    int length = str.length();\n    return is_prime(length);\n}\n"}
{"task_id": "CPP/83", "generation": "#include<stdio.h>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n <= 0) return 0; // No n-digit numbers if n is not positive\n\n    // Count of n-digit numbers that start with 1\n    int start_with_one = 1; // Only one way to start with 1 (1xxxx...x)\n    int total_n_digit_numbers = 9; // The first digit can be from 1 to 9\n\n    // For n > 1, the remaining (n-1) digits can be anything from 0 to 9\n    if (n > 1) {\n        start_with_one *= 10 * (1 << (n - 2)); // 10^(n-1) for the rest of the digits\n    }\n\n    // Count of n-digit numbers that end with 1\n    int end_with_one = 0;\n    if (n == 1) {\n        end_with_one = 1; // Only the number 1\n    } else {\n        end_with_one = 9 * (1 << (n - 2)); // 9 options for the first digit (2-9) and 10 options for the (n-1) digits\n    }\n\n    // Total count of n-digit numbers that start or end with 1\n    return start_with_one + end_with_one;\n}\n"}
{"task_id": "CPP/84", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    \n    // Calculate the sum of digits\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to sum\n        N /= 10;       // Remove the last digit\n    }\n    \n    // Convert the sum to binary\n    string binary = \"\";\n    if (sum == 0) {\n        return \"0\"; // Handle the case where the sum is 0\n    }\n    \n    while (sum > 0) {\n        binary = to_string(sum % 2) + binary; // Prepend the binary digit\n        sum /= 2; // Divide by 2 to get the next digit\n    }\n    \n    return binary; // Return the binary representation of the sum\n}\n"}
{"task_id": "CPP/85", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2 to get odd indices\n        if (lst[i] % 2 == 0) { // Check if the element is even\n            sum += lst[i]; // Add to sum if it's even\n        }\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/86", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result = \"\";\n    string currentWord = \"\";\n    \n    for (char c : s) {\n        if (c == ' ') {\n            // If we encounter a space, sort the current word and add it to the result\n            if (!currentWord.empty()) {\n                sort(currentWord.begin(), currentWord.end());\n                result += currentWord;\n                currentWord = \"\";\n            }\n            result += ' '; // Add the space to the result\n        } else {\n            currentWord += c; // Build the current word\n        }\n    }\n    \n    // Sort and add the last word if it exists\n    if (!currentWord.empty()) {\n        sort(currentWord.begin(), currentWord.end());\n        result += currentWord;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/87", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n\n    // Iterate through the 2D vector\n    for (int i = 0; i < lst.size(); i++) {\n        for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j}); // Store the coordinates\n            }\n        }\n    }\n\n    // Sort the coordinates by row (ascending) and then by column (descending)\n    sort(coordinates.begin(), coordinates.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort by column in descending order\n        }\n        return a[0] < b[0]; // Sort by row in ascending order\n    });\n\n    return coordinates;\n}\n"}
{"task_id": "CPP/88", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the array is empty or has only one element\n    if (array.size() <= 1) {\n        return array; // Return the array as is\n    }\n\n    // Calculate the sum of the first and last elements\n    int sum = array.front() + array.back();\n\n    // Sort the array based on the sum being odd or even\n    if (sum % 2 == 0) {\n        // Even sum: sort in descending order\n        sort(array.begin(), array.end(), greater<int>());\n    } else {\n        // Odd sum: sort in ascending order\n        sort(array.begin(), array.end());\n    }\n\n    return array; // Return the sorted array\n}\n"}
{"task_id": "CPP/89", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string result = \"\";\n    for (char c : s) {\n        // Check if the character is a lowercase letter\n        if (c >= 'a' && c <= 'z') {\n            // Rotate the character by 4 positions (2 * 2)\n            char newChar = c + 4;\n            // Wrap around if it goes past 'z'\n            if (newChar > 'z') {\n                newChar -= 26;\n            }\n            result += newChar;\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/90", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    // Remove duplicates by using a set\n    set<int> unique_elements(lst.begin(), lst.end());\n    \n    // If there are less than 2 unique elements, return None\n    if (unique_elements.size() < 2) {\n        return -1; // Using -1 to indicate None as per C++ convention\n    }\n    \n    // Convert the set back to a vector and sort it\n    vector<int> sorted_unique(unique_elements.begin(), unique_elements.end());\n    \n    // Return the second smallest element\n    return sorted_unique[1];\n}\n"}
{"task_id": "CPP/91", "generation": "#include<stdio.h>\n#include<string>\n#include<vector>\nusing namespace std;\n\nint is_bored(string S) {\n    int boredomCount = 0;\n    string delimiters = \".!?\";\n    size_t start = 0, end;\n\n    while ((end = S.find_first_of(delimiters, start)) != string::npos) {\n        string sentence = S.substr(start, end - start);\n        if (!sentence.empty() && sentence.find(\"I \") == 0) {\n            boredomCount++;\n        }\n        start = end + 1; // Move past the delimiter\n    }\n\n    // Check the last sentence if there is no delimiter at the end\n    string lastSentence = S.substr(start);\n    if (!lastSentence.empty() && lastSentence.find(\"I \") == 0) {\n        boredomCount++;\n    }\n\n    return boredomCount;\n}\n"}
{"task_id": "CPP/92", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n    \n    // Convert to integers\n    int int_a = static_cast<int>(a);\n    int int_b = static_cast<int>(b);\n    int int_c = static_cast<int>(c);\n    \n    // Check if one number is equal to the sum of the other two\n    return (int_a == int_b + int_c) || (int_b == int_a + int_c) || (int_c == int_a + int_b);\n}\n"}
{"task_id": "CPP/93", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    string result = \"\";\n    for (char c : message) {\n        // Swap case\n        if (isalpha(c)) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n            // Replace vowels\n            switch (tolower(c)) {\n                case 'a':\n                    c = 'c'; // 'a' -> 'c'\n                    break;\n                case 'e':\n                    c = 'g'; // 'e' -> 'g'\n                    break;\n                case 'i':\n                    c = 'k'; // 'i' -> 'k'\n                    break;\n                case 'o':\n                    c = 'q'; // 'o' -> 'q'\n                    break;\n                case 'u':\n                    c = 'w'; // 'u' -> 'w'\n                    break;\n                default:\n                    break;\n            }\n        }\n        result += c;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/94", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and return the sum of its digits\nint skjkasdkd(vector<int> lst) {\n    int largestPrime = -1;\n\n    // Iterate through the list to find the largest prime\n    for (int num : lst) {\n        if (isPrime(num) && num > largestPrime) {\n            largestPrime = num;\n        }\n    }\n\n    // If no prime number was found, return 0\n    if (largestPrime == -1) return 0;\n\n    // Return the sum of digits of the largest prime\n    return sumOfDigits(largestPrime);\n}\n"}
{"task_id": "CPP/95", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<cctype> // for islower and isupper\nusing namespace std;\n\nbool check_dict_case(map<string,string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n    \n    // Iterate through each key in the map\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n        \n        // Check if the key is not a string or contains non-alphabetic characters\n        if (!std::all_of(key.begin(), key.end(), ::isalpha)) {\n            return false;\n        }\n        \n        // Check if the key is not all lower case or all upper case\n        if (!std::all_of(key.begin(), key.end(), ::islower) && \n            !std::all_of(key.begin(), key.end(), ::isupper)) {\n            return false;\n        }\n    }\n    \n    return true; // All checks passed\n}\n"}
{"task_id": "CPP/96", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool isPrime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        if (isPrime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the unit digits of both numbers\n    int unitDigitA = abs(a) % 10; // Use abs to handle negative numbers\n    int unitDigitB = abs(b) % 10; // Use abs to handle negative numbers\n    \n    // Return the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n"}
{"task_id": "CPP/98", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    for (int i = 0; i < s.length(); i += 2) { // Check only even indices\n        char c = s[i];\n        if (c >= 'A' && c <= 'Z') { // Check if the character is an uppercase vowel\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/99", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nint closest_integer(string value) {\n    double number = stod(value); // Convert string to double\n    int lower = floor(number);    // Get the lower integer\n    int upper = ceil(number);     // Get the upper integer\n\n    // Check the distance from the number to the lower and upper integers\n    double distanceToLower = abs(number - lower);\n    double distanceToUpper = abs(number - upper);\n\n    // If the distances are equal, round away from zero\n    if (distanceToLower == distanceToUpper) {\n        if (number > 0) {\n            return upper; // Round up for positive numbers\n        } else {\n            return lower; // Round down for negative numbers\n        }\n    }\n\n    // Return the closest integer\n    return (distanceToLower < distanceToUpper) ? lower : upper;\n}\n"}
{"task_id": "CPP/100", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    int currentStones = n; // Start with n stones at the first level\n\n    for (int i = 0; i < n; i++) {\n        stones.push_back(currentStones); // Add the current level stones to the vector\n        // Determine the next number of stones based on the parity of currentStones\n        if (currentStones % 2 == 0) {\n            currentStones += 2; // Next even number\n        } else {\n            currentStones += 2; // Next odd number\n        }\n    }\n\n    return stones;\n}\n"}
{"task_id": "CPP/101", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    stringstream ss(s);\n    string word;\n\n    // Replace commas with spaces for easier splitting\n    replace(s.begin(), s.end(), ',', ' ');\n\n    // Split the string by spaces\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    return words;\n}\n"}
{"task_id": "CPP/102", "generation": "#include<stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1;\n    }\n    \n    // If y is even, return y\n    if (y % 2 == 0) {\n        return y;\n    } else {\n        // If y is odd, return y - 1 if it's within the range\n        if (y - 1 >= x) {\n            return y - 1;\n        } else {\n            return -1;\n        }\n    }\n}\n"}
{"task_id": "CPP/103", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    \n    // Calculate the average\n    int sum = 0;\n    for (int i = n; i <= m; i++) {\n        sum += i;\n    }\n    int count = m - n + 1;\n    int average = sum / count; // Integer division\n\n    // Round down the average\n    int roundedAverage = floor(average);\n\n    // Convert to binary\n    string binary = \"\";\n    while (roundedAverage > 0) {\n        binary = to_string(roundedAverage % 2) + binary;\n        roundedAverage /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary; // Handle case when average is 0\n}\n"}
{"task_id": "CPP/104", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool hasEvenDigit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true; // Found an even digit\n        }\n        num /= 10;\n    }\n    return false; // No even digits found\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    sort(result.begin(), result.end()); // Sort the result in increasing order\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Create a map to convert numbers to their corresponding names\n    map<int, string> numToName = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"},\n        {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"},\n        {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Filter the array to only include numbers between 1 and 9\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Sort the filtered array\n    sort(filtered.begin(), filtered.end());\n\n    // Reverse the sorted array\n    reverse(filtered.begin(), filtered.end());\n\n    // Create the result vector to hold the names\n    vector<string> result;\n    for (int num : filtered) {\n        result.push_back(numToName[num]);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            // Calculate factorial for even i\n            int factorial = 1;\n            for (int j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else {\n            // Calculate sum from 1 to i for odd i\n            result[i - 1] = (i * (i + 1)) / 2; // Sum of first i natural numbers\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; i++) {\n        string num_str = to_string(i);\n        string reversed_str = string(num_str.rbegin(), num_str.rend());\n\n        if (num_str == reversed_str) { // Check if the number is a palindrome\n            if (i % 2 == 0) {\n                even_count++; // Increment even count\n            } else {\n                odd_count++; // Increment odd count\n            }\n        }\n    }\n\n    return {even_count, odd_count}; // Return the counts as a vector\n}\n"}
{"task_id": "CPP/108", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    while (num != 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(abs(num)) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true; // An empty vector is considered sorted.\n\n    int n = arr.size();\n    int count = 0; // To count the number of \"drops\" in the array\n\n    // Count the number of times the current element is greater than the next element\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            count++;\n        }\n    }\n\n    // If there are more than one drop, we cannot sort the array with right shifts\n    return count <= 1;\n}\n"}
{"task_id": "CPP/110", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    bool hasEvenInLst2 = false;\n    \n    // Check if lst1 can be made all even\n    for (int num : lst1) {\n        if (num % 2 != 0) { // If there's an odd number in lst1\n            // Check if there's an even number in lst2 to exchange\n            for (int num2 : lst2) {\n                if (num2 % 2 == 0) {\n                    hasEvenInLst2 = true;\n                    break;\n                }\n            }\n            if (!hasEvenInLst2) {\n                return \"NO\"; // No even number to exchange with\n            }\n        }\n    }\n    \n    return \"YES\"; // All odd numbers in lst1 can be exchanged with even numbers in lst2\n}\n"}
{"task_id": "CPP/111", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nmap<string, int> histogram(string test) {\n    map<string, int> countMap;\n    stringstream ss(test);\n    string word;\n    \n    // Count occurrences of each letter\n    while (ss >> word) {\n        countMap[word]++;\n    }\n    \n    // Find the maximum occurrence\n    int maxCount = 0;\n    for (const auto& pair : countMap) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n    \n    // Create a result map for letters with the maximum occurrence\n    map<string, int> result;\n    for (const auto& pair : countMap) {\n        if (pair.second == maxCount) {\n            result[pair.first] = pair.second;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/112", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Create a set of characters to delete for faster lookup\n    unordered_set<char> charsToDelete(c.begin(), c.end());\n    \n    // Build the result string by skipping characters in the set\n    string result;\n    for (char ch : s) {\n        if (charsToDelete.find(ch) == charsToDelete.end()) {\n            result += ch;\n        }\n    }\n    \n    // Check if the result string is a palindrome\n    string reversedResult = result;\n    reverse(reversedResult.begin(), reversedResult.end());\n    bool isPalindrome = (result == reversedResult);\n    \n    // Prepare the output vector\n    vector<string> output;\n    output.push_back(result);\n    output.push_back(isPalindrome ? \"True\" : \"False\");\n    \n    return output;\n}\n"}
{"task_id": "CPP/113", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (int i = 0; i < lst.size(); i++) {\n        int odd_count = 0;\n        \n        // Count odd digits in the current string\n        for (char c : lst[i]) {\n            if ((c - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n        \n        // Create the output string with the counted odd digits\n        string output = \"the number of odd elements \" + to_string(odd_count) + \n                        \"n the str\" + to_string(i) + \n                        \"ng \" + to_string(i) + \n                        \" of the \" + to_string(i) + \n                        \"nput.\";\n        \n        result.push_back(output);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long minSum = nums[0];\n    long long currentSum = 0;\n\n    for (long long num : nums) {\n        currentSum += num;\n        if (currentSum < minSum) {\n            minSum = currentSum;\n        }\n        if (currentSum > 0) {\n            currentSum = 0; // Reset current sum if it becomes positive\n        }\n    }\n\n    return minSum;\n}\n"}
{"task_id": "CPP/115", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int totalLowerings = 0;\n\n    for (const auto& row : grid) {\n        int waterUnits = 0;\n\n        // Count the number of water units (1s) in the current row\n        for (int cell : row) {\n            waterUnits += cell;\n        }\n\n        // Calculate the number of times we need to lower the bucket for this row\n        if (waterUnits > 0) {\n            totalLowerings += (waterUnits + capacity - 1) / capacity; // Equivalent to ceil(waterUnits / capacity)\n        }\n    }\n\n    return totalLowerings;\n}\n"}
{"task_id": "CPP/116", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> arr) {\n    // Custom comparator for sorting\n    sort(arr.begin(), arr.end(), [](int a, int b) {\n        // Count the number of 1s in the binary representation\n        int countA = __builtin_popcount(a);\n        int countB = __builtin_popcount(b);\n        \n        // First compare by the number of 1s, then by the value itself\n        if (countA == countB) {\n            return a < b; // Sort by value if counts are equal\n        }\n        return countA < countB; // Sort by number of 1s\n    });\n    \n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word;\n    \n    // Split the string into words\n    for (char c : s) {\n        if (c == ' ') {\n            if (!word.empty()) {\n                // Count consonants in the word\n                int consonant_count = 0;\n                for (char ch : word) {\n                    if (isalpha(ch) && !strchr(\"aeiouAEIOU\", ch)) {\n                        consonant_count++;\n                    }\n                }\n                // Check if the word has exactly n consonants\n                if (consonant_count == n) {\n                    result.push_back(word);\n                }\n                word.clear(); // Clear the word for the next one\n            }\n        } else {\n            word += c; // Build the current word\n        }\n    }\n    \n    // Check the last word if there is no trailing space\n    if (!word.empty()) {\n        int consonant_count = 0;\n        for (char ch : word) {\n            if (isalpha(ch) && !strchr(\"aeiouAEIOU\", ch)) {\n                consonant_count++;\n            }\n        }\n        if (consonant_count == n) {\n            result.push_back(word);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    // Define a set of vowels for easy checking\n    string vowels = \"aeiouAEIOU\";\n    \n    // Initialize an empty string to hold the closest vowel\n    string closestVowel = \"\";\n    \n    // Iterate through the string from the end to the beginning\n    for (int i = word.length() - 1; i > 0; i--) {\n        // Check if the current character is a consonant\n        if (isalpha(word[i]) && vowels.find(word[i]) == string::npos) {\n            // Look for the next character to the left\n            for (int j = i - 1; j > 0; j--) {\n                // Check if the character is a vowel\n                if (vowels.find(word[j]) != string::npos) {\n                    // If we found a vowel, set it as the closest vowel\n                    closestVowel = word[j];\n                    return closestVowel; // Return immediately after finding the first valid vowel\n                }\n                // If we hit another consonant, break the inner loop\n                if (isalpha(word[j]) && vowels.find(word[j]) == string::npos) {\n                    break;\n                }\n            }\n        }\n    }\n    \n    // Return empty string if no vowel was found\n    return \"\";\n}\n"}
{"task_id": "CPP/119", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0];\n    string s2 = lst[1];\n\n    // Function to count the balance of parentheses\n    auto countBalance = [](const string& s) {\n        int balance = 0;\n        for (char c : s) {\n            if (c == '(') {\n                balance++;\n            } else {\n                balance--;\n            }\n        }\n        return balance;\n    };\n\n    // Count balance for both strings\n    int balance1 = countBalance(s1);\n    int balance2 = countBalance(s2);\n\n    // Check if concatenating in both orders can result in a good string\n    // Concatenating s1 then s2\n    if (balance1 + balance2 == 0) {\n        return \"Yes\";\n    }\n\n    // Concatenating s2 then s1\n    if (balance2 + balance1 == 0) {\n        return \"Yes\";\n    }\n\n    // Check if we can balance the parentheses\n    int open1 = count(s1.begin(), s1.end(), '(');\n    int close1 = count(s1.begin(), s1.end(), ')');\n    int open2 = count(s2.begin(), s2.end(), '(');\n    int close2 = count(s2.begin(), s2.end(), ')');\n\n    // Check if we can balance the parentheses by checking the counts\n    if (open1 + open2 >= close1 + close2 && close1 + close2 >= open1 + open2) {\n        return \"Yes\";\n    }\n\n    return \"No\";\n}\n"}
{"task_id": "CPP/120", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Create a vector to hold the maximum k numbers\n    vector<int> result(arr.begin(), arr.begin() + k);\n    \n    // Sort the result in ascending order before returning\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) { // Iterate over even positions\n        if (lst[i] % 2 != 0) { // Check if the element is odd\n            sum += lst[i]; // Add to sum if it's odd\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++) {\n        if (arr[i] >= -99 && arr[i] <= 99) { // Check if the element has at most two digits\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    \n    // Generate the Collatz sequence\n    while (n != 1) {\n        if (n % 2 != 0) { // Check if n is odd\n            odd_numbers.push_back(n);\n        }\n        // Apply the Collatz rules\n        if (n % 2 == 0) {\n            n = n / 2; // If n is even\n        } else {\n            n = 3 * n + 1; // If n is odd\n        }\n    }\n    \n    // Add 1 to the list since the sequence always ends with 1\n    odd_numbers.push_back(1);\n    \n    // Sort the odd numbers in increasing order\n    sort(odd_numbers.begin(), odd_numbers.end());\n    \n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) return false;\n\n    // Check if the format is correct (mm-dd-yyyy)\n    if (date[2] != '-' || date[5] != '-') return false;\n\n    // Split the date into components\n    int month, day, year;\n    char dash1, dash2;\n    stringstream ss(date);\n    ss >> month >> dash1 >> day >> dash2 >> year;\n\n    // Check if the stream was successful and if the dashes are correct\n    if (ss.fail() || dash1 != '-' || dash2 != '-') return false;\n\n    // Check month range\n    if (month < 1 || month > 12) return false;\n\n    // Check day range based on month\n    if (month == 2) {\n        // Check for leap year\n        bool isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n        if (day < 1 || day > (isLeapYear ? 29 : 28)) return false;\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        if (day < 1 || day > 30) return false;\n    } else {\n        if (day < 1 || day > 31) return false;\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<sstream>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    \n    // Check for whitespace\n    if (txt.find(' ') != string::npos) {\n        // Split by whitespace\n        stringstream ss(txt);\n        string word;\n        while (ss >> word) {\n            result.push_back(word);\n        }\n        return result;\n    }\n    \n    // Check for commas\n    if (txt.find(',') != string::npos) {\n        // Split by commas\n        stringstream ss(txt);\n        string word;\n        while (getline(ss, word, ',')) {\n            result.push_back(word);\n        }\n        return result;\n    }\n    \n    // If no whitespace or commas, count lowercase letters in odd positions\n    int count = 0;\n    for (char c : txt) {\n        if (c >= 'a' && c <= 'z') {\n            int position = c - 'a'; // 0-based index\n            if (position % 2 == 1) { // Check if the position is odd\n                count++;\n            }\n        }\n    }\n    \n    // Return the count as a string in a vector\n    return {to_string(count)};\n}\n"}
{"task_id": "CPP/126", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    unordered_map<int, int> countMap;\n    \n    for (int i = 0; i < lst.size(); i++) {\n        // Count occurrences of each number\n        countMap[lst[i]]++;\n        // If any number appears more than twice, return false\n        if (countMap[lst[i]] > 2) {\n            return false;\n        }\n        // Check if the current number is less than the previous number\n        if (i > 0 && lst[i] < lst[i - 1]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    // Determine the start and end of the intersection\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n\n    // Calculate the length of the intersection\n    int length = end - start;\n\n    // Check if the intervals intersect\n    if (length <= 0) {\n        return \"NO\"; // No intersection\n    }\n\n    // Check if the length of the intersection is prime\n    if (isPrime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768; // Return -32768 for empty array\n    }\n\n    int sum_magnitudes = 0;\n    int product_sign = 1; // Start with a neutral product sign\n\n    for (int num : arr) {\n        if (num > 0) {\n            sum_magnitudes += num; // Add magnitude of positive numbers\n        } else if (num < 0) {\n            sum_magnitudes += -num; // Add magnitude of negative numbers\n            product_sign *= -1; // Flip the sign for negative numbers\n        } else {\n            product_sign = 0; // If there's a zero, the product sign becomes zero\n            break; // No need to continue if we have a zero\n        }\n    }\n\n    return sum_magnitudes * product_sign; // Return the final result\n}\n"}
{"task_id": "CPP/129", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvoid dfs(vector<vector<int>>& grid, int x, int y, int k, vector<int>& currentPath, vector<int>& minPath) {\n    // If we have reached the desired path length\n    if (currentPath.size() == k) {\n        if (minPath.empty() || currentPath < minPath) {\n            minPath = currentPath; // Update the minimum path\n        }\n        return;\n    }\n\n    // Directions for moving up, down, left, right\n    vector<pair<int, int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n    // Explore neighbors\n    for (auto& dir : directions) {\n        int newX = x + dir.first;\n        int newY = y + dir.second;\n\n        // Check if the new position is within bounds\n        if (newX >= 0 && newX < grid.size() && newY >= 0 && newY < grid[0].size()) {\n            currentPath.push_back(grid[newX][newY]); // Add the value to the current path\n            dfs(grid, newX, newY, k, currentPath, minPath); // Recursive DFS call\n            currentPath.pop_back(); // Backtrack\n        }\n    }\n}\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    vector<int> minPath; // To store the minimum path found\n    int n = grid.size();\n\n    // Try starting from each cell in the grid\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            vector<int> currentPath = {grid[i][j]}; // Start path with the current cell\n            dfs(grid, i, j, k, currentPath, minPath); // Start DFS from the current cell\n        }\n    }\n\n    return minPath; // Return the minimum path found\n}\n"}
{"task_id": "CPP/130", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> tribonacci(n + 1);\n    \n    // Base cases\n    tribonacci[0] = 1; // tri(0)\n    if (n >= 1) tribonacci[1] = 3; // tri(1)\n    if (n >= 2) tribonacci[2] = 2; // tri(2)\n\n    // Fill the tribonacci sequence for n >= 3\n    for (int i = 3; i <= n; i++) {\n        if (i % 2 == 0) {\n            tribonacci[i] = 1 + (i / 2);\n        } else {\n            tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i + 1];\n        }\n    }\n\n    return tribonacci;\n}\n"}
{"task_id": "CPP/131", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOdd = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply the product by the odd digit\n            hasOdd = true; // Mark that we have at least one odd digit\n        }\n        n /= 10; // Remove the last digit\n    }\n\n    return hasOdd ? product : 0; // Return product if there's at least one odd digit, otherwise return 0\n}\n"}
{"task_id": "CPP/132", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int balance = 0; // To track the balance of brackets\n    bool hasNested = false; // To check if there is any nested bracket\n\n    for (char ch : str) {\n        if (ch == '[') {\n            balance++;\n            // If we have more than one open bracket, we have a nested structure\n            if (balance > 1) {\n                hasNested = true;\n            }\n        } else if (ch == ']') {\n            balance--;\n            // If balance goes negative, it means there are unmatched closing brackets\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n\n    // Valid if balance is zero (all brackets matched) and hasNested is true\n    return balance == 0 && hasNested;\n}\n"}
{"task_id": "CPP/133", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int rounded = ceil(num); // Round up to the nearest integer\n        sum += rounded * rounded; // Add the square of the rounded number to the sum\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/134", "generation": "#include<stdio.h>\n#include<string>\n#include<cctype> // for isalpha function\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Trim trailing spaces\n    size_t end = txt.find_last_not_of(' ');\n    if (end == string::npos) {\n        return false; // String is empty or only contains spaces\n    }\n    \n    // Get the last character\n    char lastChar = txt[end];\n\n    // Check if the last character is an alphabetical character\n    if (isalpha(lastChar)) {\n        // Check if the last character is part of a word\n        if (end == 0 || txt[end - 1] == ' ') {\n            return true; // Last character is a letter and not part of a word\n        }\n    }\n    \n    return false; // Last character is not a letter or is part of a word\n}\n"}
{"task_id": "CPP/135", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int largestIndex = -1; // Initialize to -1, which will be returned if no such element is found\n\n    // Iterate through the array starting from the second element\n    for (int i = 1; i < arr.size(); i++) {\n        // Check if the current element is less than the previous element\n        if (arr[i] < arr[i - 1]) {\n            largestIndex = i; // Update the largest index found\n        }\n    }\n\n    return largestIndex; // Return the largest index found, or -1 if none was found\n}\n"}
{"task_id": "CPP/136", "generation": "#include<stdio.h>\n#include<vector>\n#include<limits.h> // For INT_MIN and INT_MAX\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = INT_MIN; // Initialize to the smallest possible integer\n    int smallest_positive = INT_MAX; // Initialize to the largest possible integer\n\n    for (int num : lst) {\n        if (num < 0) {\n            if (num > largest_negative) {\n                largest_negative = num; // Update largest negative\n            }\n        } else if (num > 0) {\n            if (num < smallest_positive) {\n                smallest_positive = num; // Update smallest positive\n            }\n        }\n    }\n\n    // If no negative number was found, set to 0\n    if (largest_negative == INT_MIN) {\n        largest_negative = 0;\n    }\n    \n    // If no positive number was found, set to 0\n    if (smallest_positive == INT_MAX) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n#include <sstream>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Helper function to convert boost::any to double\n    auto to_double = [](boost::any value) -> double {\n        if (value.type() == typeid(int)) {\n            return boost::any_cast<int>(value);\n        } else if (value.type() == typeid(float)) {\n            return boost::any_cast<float>(value);\n        } else if (value.type() == typeid(string)) {\n            string str = boost::any_cast<string>(value);\n            // Replace ',' with '.' for proper float conversion\n            replace(str.begin(), str.end(), ',', '.');\n            return stod(str);\n        }\n        throw std::invalid_argument(\"Unsupported type\");\n    };\n\n    // Convert both values to double for comparison\n    double num1 = to_double(a);\n    double num2 = to_double(b);\n\n    // Compare the two numbers\n    if (num1 == num2) {\n        return \"None\";\n    } else {\n        // Return the larger value in its original type\n        if (num1 > num2) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is less than 8, as the smallest sum of 4 positive even numbers (2 + 2 + 2 + 2) is 8\n    if (n < 8) {\n        return false;\n    }\n    // Check if n is even, as the sum of even numbers is always even\n    return n % 2 == 0;\n}\n"}
{"task_id": "CPP/139", "generation": "#include<stdio.h>\nusing namespace std;\n\nlong long factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i > 0; i--) {\n        result *= factorial(i);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/140", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int spaceCount = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            spaceCount++;\n        } else {\n            if (spaceCount > 2) {\n                result += '-'; // Replace more than 2 spaces with a single '-'\n            } else if (spaceCount == 1) {\n                result += '_'; // Replace single space with '_'\n            } else if (spaceCount == 2) {\n                result += \"__\"; // Replace two consecutive spaces with '__'\n            }\n            result += c; // Add the current character\n            spaceCount = 0; // Reset space count\n        }\n    }\n\n    // Handle trailing spaces if any\n    if (spaceCount > 2) {\n        result += '-';\n    } else if (spaceCount == 1) {\n        result += '_';\n    } else if (spaceCount == 2) {\n        result += \"__\";\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include<stdio.h>\n#include<string>\n#include<regex>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check for exactly one dot\n    size_t dotPos = file_name.find('.');\n    if (dotPos == string::npos || file_name.find('.', dotPos + 1) != string::npos) {\n        return \"No\";\n    }\n\n    // Split the file name into name and extension\n    string namePart = file_name.substr(0, dotPos);\n    string extPart = file_name.substr(dotPos + 1);\n\n    // Check if the name part is not empty and starts with a letter\n    if (namePart.empty() || !isalpha(namePart[0])) {\n        return \"No\";\n    }\n\n    // Check for valid extensions\n    if (extPart != \"txt\" && extPart != \"exe\" && extPart != \"dll\") {\n        return \"No\";\n    }\n\n    // Count digits in the name part\n    int digitCount = 0;\n    for (char c : namePart) {\n        if (isdigit(c)) {\n            digitCount++;\n        }\n    }\n\n    // Check if there are more than three digits\n    if (digitCount > 3) {\n        return \"No\";\n    }\n\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i]; // Square the integer if index is a multiple of 3\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i]; // Cube the integer if index is a multiple of 4 and not a multiple of 3\n        } else {\n            sum += lst[i]; // Add the integer as is if index is not a multiple of 3 or 4\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include<stdio.h>\n#include<string>\n#include<vector>\n#include<sstream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    vector<string> result;\n\n    // Split the sentence into words\n    while (ss >> word) {\n        // Check if the length of the word is prime\n        if (isPrime(word.length())) {\n            result.push_back(word);\n        }\n    }\n\n    // Join the words back into a single string\n    string output;\n    for (size_t i = 0; i < result.size(); i++) {\n        output += result[i];\n        if (i < result.size() - 1) {\n            output += \" \"; // Add space between words\n        }\n    }\n\n    return output;\n}\n"}
{"task_id": "CPP/144", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Split the fractions into numerator and denominator\n    int numX, denX, numN, denN;\n    char slash;\n\n    // Parse the first fraction x\n    stringstream ssX(x);\n    ssX >> numX >> slash >> denX;\n\n    // Parse the second fraction n\n    stringstream ssN(n);\n    ssN >> numN >> slash >> denN;\n\n    // Calculate the product of the fractions\n    // x * n = (numX / denX) * (numN / denN) = (numX * numN) / (denX * denN)\n    int numeratorProduct = numX * numN;\n    int denominatorProduct = denX * denN;\n\n    // Check if the product is a whole number\n    // A fraction is a whole number if its numerator is divisible by its denominator\n    return (numeratorProduct % denominatorProduct == 0);\n}\n"}
{"task_id": "CPP/145", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n// Function to calculate the sum of digits of a number\nint digit_sum(int num) {\n    int sum = 0;\n    // Handle negative numbers by taking the absolute value\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Function to sort the vector based on the sum of digits\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of pairs to store the original index along with the number\n    vector<pair<int, int>> indexed_nums;\n    for (int i = 0; i < nums.size(); i++) {\n        indexed_nums.push_back({nums[i], i});\n    }\n    \n    // Sort the vector based on the sum of digits and original index\n    sort(indexed_nums.begin(), indexed_nums.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        int sum_a = digit_sum(a.first);\n        int sum_b = digit_sum(b.first);\n        // If sums are equal, sort by original index\n        if (sum_a == sum_b) {\n            return a.second < b.second;\n        }\n        return sum_a < sum_b;\n    });\n    \n    // Extract the sorted numbers into a result vector\n    vector<int> result;\n    for (const auto& p : indexed_nums) {\n        result.push_back(p.first);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/146", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        if (num > 10) {\n            string numStr = to_string(num);\n            char firstDigit = numStr[0];\n            char lastDigit = numStr[numStr.size() - 1];\n            \n            if ((firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || firstDigit == '7' || firstDigit == '9') &&\n                (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' || lastDigit == '7' || lastDigit == '9')) {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    // Fill the vector a with the given formula\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    int count = 0;\n\n    // Check all combinations of triples (i, j, k) where i < j < k\n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            for (int k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/148", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Check if the input planets are valid\n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n    \n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {}; // Return empty vector if either planet is invalid\n    }\n    \n    // Get the indices of the planets\n    int index1 = distance(planets.begin(), it1);\n    int index2 = distance(planets.begin(), it2);\n    \n    // Ensure index1 is less than index2\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Collect planets between planet1 and planet2\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& str) {\n        return str.length() % 2 != 0;\n    }), lst.end());\n\n    // Sort the remaining strings first by length, then alphabetically\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Sort alphabetically if lengths are equal\n        }\n        return a.length() < b.length(); // Sort by length\n    });\n\n    return lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\nint x_or_y(int n, int x, int y) {\n    if (isPrime(n)) {\n        return x; // Return x if n is prime\n    } else {\n        return y; // Return y if n is not prime\n    }\n}\n"}
{"task_id": "CPP/151", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    for (float num : lst) {\n        // Check if the number is a non-negative integer and odd\n        if (num >= 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<int>(num) * static_cast<int>(num); // Add the square of the odd number\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/152", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    for (size_t i = 0; i < game.size(); i++) {\n        result.push_back(abs(game[i] - guess[i]));\n    }\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = -1; // Initialize max strength to a low value\n    string strongest_extension = \"\"; // To store the strongest extension\n\n    for (const string& extension : extensions) {\n        int CAP = 0; // Count of uppercase letters\n        int SM = 0;  // Count of lowercase letters\n\n        // Calculate the strength of the current extension\n        for (char c : extension) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n\n        int strength = CAP - SM; // Calculate strength\n\n        // Update if this extension is stronger or if it's the first one\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension; // Return the result in the required format\n}\n"}
{"task_id": "CPP/154", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Check if b is longer than a, if so, it can't be a substring\n    if (b.length() > a.length()) {\n        return false;\n    }\n    \n    // Create a new string that is the concatenation of b with itself\n    string b_rotated = b + b;\n    \n    // Check if b or any of its rotations is a substring of a\n    return b_rotated.find(a) != string::npos;\n}\n"}
{"task_id": "CPP/155", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    vector<int> count(2, 0); // count[0] for even, count[1] for odd\n    num = abs(num); // Consider absolute value to handle negative numbers\n\n    while (num > 0) {\n        int digit = num % 10; // Get the last digit\n        if (digit % 2 == 0) {\n            count[0]++; // Increment even count\n        } else {\n            count[1]++; // Increment odd count\n        }\n        num /= 10; // Remove the last digit\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/156", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the Roman numeral symbols and their corresponding values\n    vector<pair<int, string>> romanNumerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string result = \"\";\n    \n    // Iterate through the roman numerals\n    for (const auto& pair : romanNumerals) {\n        while (number >= pair.first) {\n            result += pair.second; // Append the Roman numeral\n            number -= pair.first;  // Decrease the number\n        }\n    }\n    \n    return result; // Return the resulting Roman numeral string\n}\n"}
{"task_id": "CPP/157", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to identify the longest side\n    float x = max(a, max(b, c));\n    float y = min(max(a, b), min(max(b, c), max(a, c)));\n    float z = a + b + c - x - y; // The remaining side\n\n    // Check the Pythagorean theorem\n    return (x * x == y * y + z * z);\n}\n"}
{"task_id": "CPP/158", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string maxWord = \"\";\n    int maxUniqueCount = 0;\n\n    for (const string& word : words) {\n        unordered_set<char> uniqueChars(word.begin(), word.end());\n        int uniqueCount = uniqueChars.size();\n\n        if (uniqueCount > maxUniqueCount || \n           (uniqueCount == maxUniqueCount && word < maxWord)) {\n            maxUniqueCount = uniqueCount;\n            maxWord = word;\n        }\n    }\n\n    return maxWord;\n}\n"}
{"task_id": "CPP/159", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int totalEaten = number;\n    int carrotsToEat = min(need, remaining);\n    \n    totalEaten += carrotsToEat;\n    int carrotsLeft = remaining - carrotsToEat;\n    \n    return {totalEaten, carrotsLeft};\n}\n"}
{"task_id": "CPP/160", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    int result = operand[0]; // Start with the first operand\n\n    for (size_t i = 0; i < operato.size(); i++) {\n        if (operato[i] == \"+\") {\n            result += operand[i + 1];\n        } else if (operato[i] == \"-\") {\n            result -= operand[i + 1];\n        } else if (operato[i] == \"*\") {\n            result *= operand[i + 1];\n        } else if (operato[i] == \"//\") {\n            result /= operand[i + 1]; // Assuming operand[i + 1] is not zero\n        } else if (operato[i] == \"**\") {\n            result = pow(result, operand[i + 1]);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetter = false;\n    \n    // Check if there are any letters in the string\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n    \n    if (hasLetter) {\n        // Reverse case for letters\n        for (char &c : s) {\n            if (isalpha(c)) {\n                c = islower(c) ? toupper(c) : tolower(c);\n            }\n        }\n    } else {\n        // Reverse the string if no letters are present\n        reverse(s.begin(), s.end());\n    }\n    \n    return s;\n}\n"}
{"task_id": "CPP/162", "generation": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\"; // Return empty string instead of None for C++\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    char md5String[33];\n    for (int i = 0; i < 16; i++) {\n        sprintf(&md5String[i * 2], \"%02x\", (unsigned int)digest[i]);\n    }\n\n    return string(md5String);\n}\n"}
{"task_id": "CPP/163", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> even_digits = {0, 2, 4, 6, 8}; // List of even digits\n    vector<int> result;\n\n    // Ensure a is less than or equal to b\n    if (a > b) {\n        swap(a, b);\n    }\n\n    // Iterate through the even digits and check if they are within the range [a, b]\n    for (int digit : even_digits) {\n        if (digit >= a && digit <= b) {\n            result.push_back(digit);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/0", "generation": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the numbers to make it easier to find close elements\n    sort(numbers.begin(), numbers.end());\n    \n    // Check for any two consecutive numbers if their difference is less than the threshold\n    for (int i = 1; i < numbers.size(); i++) {\n        if (fabs(numbers[i] - numbers[i - 1]) < threshold) {\n            return true; // Found two numbers closer than the threshold\n        }\n    }\n    \n    return false; // No two numbers are closer than the threshold\n}\n"}
{"task_id": "CPP/1", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    // Remove spaces from the input string\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n\n    for (char ch : paren_string) {\n        if (ch == '(') {\n            if (balance == 0) {\n                current_group.clear(); // Start a new group\n            }\n            current_group += ch;\n            balance++;\n        } else if (ch == ')') {\n            current_group += ch;\n            balance--;\n            if (balance == 0) {\n                result.push_back(current_group); // Add the completed group to the result\n            }\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat truncate_number(float number) {\n    int integerPart = static_cast<int>(number); // Get the integer part\n    float decimalPart = number - integerPart; // Calculate the decimal part\n    return decimalPart; // Return the decimal part\n}\n"}
{"task_id": "CPP/3", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with zero balance\n    for (int operation : operations) {\n        balance += operation; // Update balance with each operation\n        if (balance < 0) { // Check if balance falls below zero\n            return true; // Return true if it does\n        }\n    }\n    return false; // Return false if balance never falls below zero\n}\n"}
{"task_id": "CPP/4", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    float sum = 0.0;\n    int n = numbers.size();\n    \n    // Calculate the mean\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / n;\n\n    // Calculate the Mean Absolute Deviation\n    float mad_sum = 0.0;\n    for (float num : numbers) {\n        mad_sum += abs(num - mean);\n    }\n    \n    return mad_sum / n; // Return the average of absolute deviations\n}\n"}
{"task_id": "CPP/5", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    for (size_t i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) { // Avoid adding delimiter after the last element\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    string::size_type start = 0, end;\n\n    while ((end = paren_string.find(' ', start)) != string::npos) {\n        string group = paren_string.substr(start, end - start);\n        int max_depth = 0, current_depth = 0;\n\n        for (char ch : group) {\n            if (ch == '(') {\n                current_depth++;\n                max_depth = max(max_depth, current_depth);\n            } else if (ch == ')') {\n                current_depth--;\n            }\n        }\n        \n        result.push_back(max_depth);\n        start = end + 1; // Move to the next group\n    }\n\n    // Handle the last group after the last space\n    string group = paren_string.substr(start);\n    int max_depth = 0, current_depth = 0;\n\n    for (char ch : group) {\n        if (ch == '(') {\n            current_depth++;\n            max_depth = max(max_depth, current_depth);\n        } else if (ch == ')') {\n            current_depth--;\n        }\n    }\n\n    result.push_back(max_depth);\n    \n    return result;\n}\n"}
{"task_id": "CPP/7", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filteredStrings;\n    for (const string& str : strings) {\n        if (str.find(substring) != string::npos) {\n            filteredStrings.push_back(str);\n        }\n    }\n    return filteredStrings;\n}\n"}
{"task_id": "CPP/8", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    // If the vector is empty, we should return (0, 1)\n    if (numbers.empty()) {\n        product = 1; // product should be 1 for an empty vector\n    }\n\n    return {sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> result;\n    int current_max = INT_MIN; // Initialize current_max to the smallest integer\n\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num; // Update current_max if the current number is greater\n        }\n        result.push_back(current_max); // Append the current maximum to the result\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/10", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome(\"\") \n    \"\" \n    >>> make_palindrome(\"cat\") \n    \"catac\" \n    >>> make_palindrome(\"cata\") \n    \"catac\" \n    */\n    int n = str.length();\n    // Find the longest palindromic suffix\n    for (int i = n; i >= 0; i--) {\n        if (is_palindrome(str.substr(i))) {\n            // Append the reverse of the prefix to the original string\n            return str + string(str.begin(), str.begin() + i);\n        }\n    }\n    return str; // In case the string is already a palindrome\n}\n"}
{"task_id": "CPP/11", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    int length = a.length();\n    \n    // Ensure both strings are of the same length by padding the shorter one with leading zeros\n    if (a.length() < b.length()) {\n        a.insert(0, b.length() - a.length(), '0');\n    } else if (b.length() < a.length()) {\n        b.insert(0, a.length() - b.length(), '0');\n    }\n    \n    // Perform XOR operation\n    for (int i = 0; i < a.length(); i++) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"None\"; // Return \"None\" if the input vector is empty\n    }\n    \n    string longestString = strings[0]; // Initialize with the first string\n    for (const string& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str; // Update if a longer string is found\n        }\n    }\n    \n    return longestString; // Return the longest string found\n}\n"}
{"task_id": "CPP/13", "generation": "#include<stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (int i = 1; i <= str.length(); i++) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        ss << i;\n        if (i < n) {\n            ss << \" \"; // Add space only if it's not the last number\n        }\n    }\n    return ss.str();\n}\n"}
{"task_id": "CPP/16", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nint count_distinct_characters(string str) { \n    set<char> distinctChars; // Using a set to store distinct characters\n    for (char c : str) {\n        distinctChars.insert(tolower(c)); // Convert to lowercase and insert into the set\n    }\n    return distinctChars.size(); // The size of the set gives the count of distinct characters\n}\n"}
{"task_id": "CPP/17", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    stringstream ss(music_string);\n    string note;\n\n    while (ss >> note) {\n        if (note == \"o\") {\n            beats.push_back(4); // whole note\n        } else if (note == \"o|\") {\n            beats.push_back(2); // half note\n        } else if (note == \".|\") {\n            beats.push_back(1); // quarter note\n        }\n    }\n\n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (substring.empty()) return 0; // If the substring is empty, return 0\n    int count = 0;\n    size_t pos = 0;\n    \n    // Loop to find all occurrences of the substring\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++; // Increment count for each found occurrence\n        pos++; // Move to the next position to allow overlapping matches\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<vector>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Map to convert string numbers to their corresponding integer values\n    map<string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Split the input string into individual words\n    stringstream ss(numbers);\n    vector<string> num_list;\n    string num;\n    \n    while (ss >> num) {\n        num_list.push_back(num);\n    }\n\n    // Sort the numbers based on their integer values\n    sort(num_list.begin(), num_list.end(), [&](const string &a, const string &b) {\n        return num_map[a] < num_map[b];\n    });\n\n    // Join the sorted numbers back into a single string\n    string result;\n    for (const string &n : num_list) {\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += n;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/20", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Sort the numbers to easily find the closest pair\n    sort(numbers.begin(), numbers.end());\n    \n    // Initialize the minimum difference to a large value\n    float minDiff = FLT_MAX;\n    vector<float> closestPair;\n\n    // Iterate through the sorted numbers to find the closest pair\n    for (int i = 0; i < numbers.size() - 1; i++) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < minDiff) {\n            minDiff = diff;\n            closestPair = {numbers[i], numbers[i + 1]};\n        }\n    }\n\n    return closestPair;\n}\n"}
{"task_id": "CPP/21", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    float minVal = *min_element(numbers.begin(), numbers.end());\n    float maxVal = *max_element(numbers.begin(), numbers.end());\n    \n    vector<float> rescaled;\n    for (float num : numbers) {\n        float scaledValue = (num - minVal) / (maxVal - minVal);\n        rescaled.push_back(scaledValue);\n    }\n    \n    return rescaled;\n}\n"}
{"task_id": "CPP/22", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\n#include <iostream>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        try {\n            // Attempt to cast the value to an int\n            int intValue = boost::any_cast<int>(value);\n            result.push_back(intValue); // If successful, add to result\n        } catch (const boost::bad_any_cast&) {\n            // If the cast fails, we simply ignore this value\n        }\n    }\n    return result;\n}\n\n// Example usage\n"}
{"task_id": "CPP/23", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint strlen(string str) {\n    int length = 0;\n    for (char c : str) {\n        length++;\n    }\n    return length;\n}\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; i--) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1; // In case n is 1, the largest divisor is 1\n}\n"}
{"task_id": "CPP/25", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    // Start checking for factors from 2 to sqrt(n)\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    // If n is still greater than 1, then it is a prime factor\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> countMap;\n    // Count occurrences of each number\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n    \n    vector<int> result;\n    // Add numbers that occur only once to the result\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) {\n        if (isupper(c)) {\n            c = tolower(c);\n        } else if (islower(c)) {\n            c = toupper(c);\n        }\n    }\n    return str;\n}\n"}
{"task_id": "CPP/28", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\";\n    for (const string& str : strings) {\n        result += str;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/29", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered;\n    for (const string& str : strings) {\n        if (str.find(prefix) == 0) { // Check if the string starts with the prefix\n            filtered.push_back(str);\n        }\n    }\n    return filtered;\n}\n"}
{"task_id": "CPP/30", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positives;\n    for (float num : l) {\n        if (num > 0) {\n            positives.push_back(num);\n        }\n    }\n    return positives;\n}\n"}
{"task_id": "CPP/31", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    if (n <= 3) return true; // 2 and 3 are prime numbers\n\n    // Check for even numbers and multiples of 3\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    // Check for factors from 5 to sqrt(n)\n    for (long long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n"}
{"task_id": "CPP/32", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    /* \n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[2] * x^2 + .... xs[n] * x^n \n    */\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    /*\n    xs are coefficients of a polynomial. find_zero finds x such that poly(x) = 0. find_zero returns only one zero point, even if there are many. \n    Moreover, find_zero only takes list xs having even number of coefficients and largest non zero coefficient as it guarantees a solution.\n    >>> round(find_zero([1, 2]), 2) #f(x) = 1 + 2x \n    -0.5 \n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 \n    1.0\n    */\n    \n    // Using the bisection method to find a root\n    double left = -1000; // Starting left boundary\n    double right = 1000; // Starting right boundary\n    double mid;\n\n    // Ensure we have a sign change in the interval\n    while (poly(xs, left) * poly(xs, right) > 0) {\n        left -= 1000; // Expand the search interval\n        right += 1000;\n    }\n\n    // Bisection method\n    for (int i = 0; i < 100; i++) { // Limit iterations for convergence\n        mid = (left + right) / 2;\n        if (poly(xs, mid) == 0) {\n            return mid; // Found exact root\n        } else if (poly(xs, mid) * poly(xs, left) < 0) {\n            right = mid; // Root is in left half\n        } else {\n            left = mid; // Root is in right half\n        }\n    }\n\n    return mid; // Return the midpoint as an approximation of the root\n}\n"}
{"task_id": "CPP/33", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> sorted_thirds;\n    \n    // Collect values at indices divisible by 3\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            sorted_thirds.push_back(l[i]);\n        }\n    }\n    \n    // Sort the collected values\n    sort(sorted_thirds.begin(), sorted_thirds.end());\n    \n    // Replace values at indices divisible by 3 with sorted values\n    int sorted_index = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l[i] = sorted_thirds[sorted_index++];\n        }\n    }\n    \n    return l;\n}\n"}
{"task_id": "CPP/34", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Use the unique function to remove duplicates\n    auto last = unique(l.begin(), l.end());\n    \n    // Resize the vector to contain only unique elements\n    l.erase(last, l.end());\n    \n    return l;\n}\n"}
{"task_id": "CPP/35", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    float maxVal = l[0]; // Initialize maxVal with the first element\n    for (int i = 1; i < l.size(); i++) { // Start from the second element\n        if (l[i] > maxVal) { // Compare with maxVal\n            maxVal = l[i]; // Update maxVal if current element is greater\n        }\n    }\n    return maxVal; // Return the maximum value found\n}\n"}
{"task_id": "CPP/36", "generation": "#include<stdio.h>\nusing namespace std;\n\nint countDigit7(int num) {\n    int count = 0;\n    while (num > 0) {\n        if (num % 10 == 7) {\n            count++;\n        }\n        num /= 10;\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int totalCount = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            totalCount += countDigit7(i);\n        }\n    }\n    return totalCount;\n}\n"}
{"task_id": "CPP/37", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Create a vector to hold the even indexed elements\n    vector<float> even_indices;\n    \n    // Extract even indexed elements\n    for (int i = 0; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    \n    // Sort the even indexed elements\n    sort(even_indices.begin(), even_indices.end());\n    \n    // Place the sorted even indexed elements back into the original vector\n    for (int i = 0; i < even_indices.size(); i++) {\n        l[i * 2] = even_indices[i];\n    }\n    \n    // Return the modified vector\n    return l;\n}\n"}
{"task_id": "CPP/38", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_cyclic(string s){ \n    // returns encoded string by cycling groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++)\n    {\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output = output + x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s){ \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string. \n    */\n    int l = s.length();\n    string output;\n    int i;\n    for (i = 0; i * 3 < l; i++)\n    {\n        // Get the group of three characters\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            // Shift the last character to the front\n            output += x[x.length() - 1]; // last character\n            output += x.substr(0, x.length() - 1); // first two characters\n        } else {\n            // If the group has fewer than 3 characters, just append it as is\n            output += x;\n        }\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to return the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    vector<int> fib = {0, 1}; // Starting values for Fibonacci sequence\n    int count = 0; // Count of prime Fibonacci numbers\n    int i = 2; // Index for generating Fibonacci numbers\n\n    while (count < n) {\n        // Generate the next Fibonacci number\n        fib.push_back(fib[i - 1] + fib[i - 2]);\n        i++;\n\n        // Check if the new Fibonacci number is prime\n        if (is_prime(fib.back())) {\n            count++;\n            // If we have found the n-th prime Fibonacci number, return it\n            if (count == n) {\n                return fib.back();\n            }\n        }\n    }\n    return -1; // This line should never be reached if n is valid\n}\n"}
{"task_id": "CPP/40", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false; // Need at least 3 elements to form a triplet\n\n    // Sort the array to use two-pointer technique\n    sort(l.begin(), l.end());\n\n    for (int i = 0; i < n - 2; i++) {\n        // Skip duplicate elements to avoid counting the same triplet\n        if (i > 0 && l[i] == l[i - 1]) continue;\n\n        int left = i + 1;\n        int right = n - 1;\n\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true; // Found a triplet that sums to zero\n            } else if (sum < 0) {\n                left++; // Move left pointer to increase the sum\n            } else {\n                right--; // Move right pointer to decrease the sum\n            }\n        }\n    }\n    return false; // No triplet found\n}\n"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    return n * n; // Each car from the first set collides with each car from the second set\n}\n"}
{"task_id": "CPP/42", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (int i = 0; i < l.size(); i++) {\n        l[i] += 1; // Increment each element by 1\n    }\n    return l; // Return the modified vector\n}\n"}
{"task_id": "CPP/43", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.count(-num)) {\n            return true; // Found a pair that sums to zero\n        }\n        seen.insert(num);\n    }\n    return false; // No pairs found that sum to zero\n}\n"}
{"task_id": "CPP/44", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (base < 2 || base >= 10) {\n        return \"\"; // Invalid base\n    }\n    \n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result; // Prepend the remainder\n        x /= base; // Divide x by the base\n    }\n    \n    return result.empty() ? \"0\" : result; // Handle the case when x is 0\n}\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h; // Area of triangle = 0.5 * base * height\n}\n"}
{"task_id": "CPP/46", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    int fib[n + 1];\n    fib[0] = 0;\n    fib[1] = 0;\n    fib[2] = 2;\n    fib[3] = 0;\n\n    for (int i = 4; i <= n; i++) {\n        fib[i] = fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4];\n    }\n\n    return fib[n];\n}\n"}
{"task_id": "CPP/47", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector to find the median\n    sort(l.begin(), l.end());\n    int n = l.size();\n    \n    // If the size of the vector is odd, return the middle element\n    if (n % 2 != 0) {\n        return l[n / 2];\n    } else {\n        // If the size is even, return the average of the two middle elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.size() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n"}
{"task_id": "CPP/49", "generation": "#include<stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0) return 1; // 2^0 is 1\n    long long result = 1; // Use long long to avoid overflow\n    long long base = 2; // Base is 2\n\n    // Calculate 2^n % p using modular exponentiation\n    while (n > 0) {\n        if (n % 2 == 1) { // If n is odd\n            result = (result * base) % p;\n        }\n        base = (base * base) % p; // Square the base\n        n /= 2; // Divide n by 2\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_shift(string s){\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i=0; i<s.length(); i++)\n    {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';   \n        out = out + (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s){\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i=0; i<s.length(); i++)\n    {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';   \n        out = out + (char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        // Check if the character is not a vowel (both lowercase and uppercase)\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n            c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            result += c; // Append non-vowel characters to the result\n        }\n    }\n    return result; // Return the string without vowels\n}\n"}
{"task_id": "CPP/52", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false; // If any number is greater than or equal to the threshold, return false\n        }\n    }\n    return true; // All numbers are below the threshold\n}\n"}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n"}
{"task_id": "CPP/54", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create a set to store unique characters from both strings\n    unordered_set<char> chars0(s0.begin(), s0.end());\n    unordered_set<char> chars1(s1.begin(), s1.end());\n\n    // Check if both sets have the same size and the same elements\n    return chars0 == chars1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) return 0; // Fibonacci of 0 is 0\n    if (n == 1) return 1; // Fibonacci of 1 is 1\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; i++) {\n        c = a + b; // Calculate the next Fibonacci number\n        a = b;     // Move to the next pair\n        b = c;\n    }\n    return b; // Return the n-th Fibonacci number\n}\n"}
{"task_id": "CPP/56", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // To keep track of the balance of brackets\n    for (char ch : brackets) {\n        if (ch == '<') {\n            balance++; // Increment for opening bracket\n        } else if (ch == '>') {\n            balance--; // Decrement for closing bracket\n        }\n        // If balance goes negative, it means there's a closing bracket without a matching opening bracket\n        if (balance < 0) {\n            return false;\n        }\n    }\n    // At the end, balance should be zero for all brackets to be matched\n    return balance == 0;\n}\n"}
{"task_id": "CPP/57", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() < 2) return true; // A single element or empty vector is considered monotonic\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); i++) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false; // Found an increasing pair\n        } else if (l[i] < l[i - 1]) {\n            increasing = false; // Found a decreasing pair\n        }\n    }\n\n    return increasing || decreasing; // Return true if either increasing or decreasing\n}\n"}
{"task_id": "CPP/58", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Use a set to store unique elements\n    set<int> set1(l1.begin(), l1.end());\n    set<int> set2(l2.begin(), l2.end());\n    \n    // Vector to store the common elements\n    vector<int> commonElements;\n    \n    // Iterate through the first set and check if elements are in the second set\n    for (const int& element : set1) {\n        if (set2.find(element) != set2.end()) {\n            commonElements.push_back(element);\n        }\n    }\n    \n    // Sort the result (though sets are inherently sorted, this ensures order)\n    sort(commonElements.begin(), commonElements.end());\n    \n    return commonElements;\n}\n"}
{"task_id": "CPP/59", "generation": "#include<stdio.h>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int largest = -1;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        largest = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest = i;\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        largest = n;\n    }\n\n    return largest;\n}\n"}
{"task_id": "CPP/60", "generation": "#include<stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2; // Using the formula for the sum of the first n natural numbers\n}\n"}
{"task_id": "CPP/61", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // To keep track of the balance of brackets\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++; // Increment for opening bracket\n        } else if (ch == ')') {\n            balance--; // Decrement for closing bracket\n        }\n        // If balance goes negative, it means there's a closing bracket without a matching opening bracket\n        if (balance < 0) {\n            return false;\n        }\n    }\n    // At the end, balance should be zero for all brackets to be matched\n    return balance == 0;\n}\n"}
{"task_id": "CPP/62", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    int degree = xs.size() - 1; // The degree of the polynomial\n\n    for (int i = 1; i <= degree; i++) {\n        // The derivative of a_i * x^i is i * a_i\n        result.push_back(i * xs[i]);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    int a = 0, b = 0, c = 1; // fibfib(0), fibfib(1), fibfib(2)\n    int result = 0;\n\n    for (int i = 3; i <= n; i++) {\n        result = a + b + c; // fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n        a = b; // move to the next\n        b = c; // move to the next\n        c = result; // update c to the latest result\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/64", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    int n = s.length();\n    \n    // Convert string to lowercase to handle case insensitivity\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n    \n    // Check for vowels in the string\n    for (int i = 0; i < n; i++) {\n        if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {\n            count++;\n        }\n    }\n    \n    // Check if the last character is 'y' and count it as a vowel\n    if (n > 0 && s[n - 1] == 'y') {\n        count++;\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string numStr = to_string(x);\n    int len = numStr.length();\n    \n    // If shift is greater than the number of digits, reverse the string\n    if (shift >= len) {\n        reverse(numStr.begin(), numStr.end());\n        return numStr;\n    }\n    \n    // Perform the circular shift\n    string shifted = numStr.substr(len - shift) + numStr.substr(0, len - shift);\n    return shifted;\n}\n"}
{"task_id": "CPP/66", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add the ASCII value of the uppercase character\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/67", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0, oranges = 0;\n    stringstream ss(s);\n    string word;\n\n    // Parse the string to find the number of apples and oranges\n    while (ss >> word) {\n        if (word == \"apples\") {\n            ss >> apples; // Get the number before \"apples\"\n        } else if (word == \"oranges\") {\n            ss >> oranges; // Get the number before \"oranges\"\n        }\n    }\n\n    // Calculate the number of mangoes\n    return n - apples - oranges;\n}\n"}
{"task_id": "CPP/68", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    vector<int> result;\n    int smallestEvenValue = -1; // Initialize to -1 to indicate no even value found\n    int smallestIndex = -1;\n\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            if (smallestEvenValue == -1 || arr[i] < smallestEvenValue) {\n                smallestEvenValue = arr[i];\n                smallestIndex = i;\n            }\n        }\n    }\n\n    if (smallestEvenValue != -1) {\n        result.push_back(smallestEvenValue);\n        result.push_back(smallestIndex);\n    }\n\n    return result; // Return the result vector\n}\n"}
{"task_id": "CPP/69", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_map>\n#include<algorithm>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequencyMap;\n    \n    // Count the frequency of each number\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n    \n    int result = -1;\n    \n    // Check for the greatest integer that meets the condition\n    for (const auto& entry : frequencyMap) {\n        int num = entry.first;\n        int freq = entry.second;\n        \n        if (num <= freq) {\n            result = max(result, num);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/70", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    vector<int> result;\n    if (lst.empty()) {\n        return result; // Return empty vector if input is empty\n    }\n    \n    // Sort the input list\n    sort(lst.begin(), lst.end());\n    \n    // Use two pointers to select minimum and maximum alternately\n    int left = 0; // Pointer for minimum\n    int right = lst.size() - 1; // Pointer for maximum\n    \n    while (left <= right) {\n        // Add minimum value\n        result.push_back(lst[left]);\n        left++;\n        \n        // Check if there are still elements to add\n        if (left <= right) {\n            // Add maximum value\n            result.push_back(lst[right]);\n            right--;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b > c && a + c > b && b + c > a) {\n        // Calculate the semi-perimeter\n        float s = (a + b + c) / 2;\n        // Calculate the area using Heron's formula\n        float area = sqrt(s * (s - a) * (s - b) * (s - c));\n        // Return the area rounded to 2 decimal points\n        return round(area * 100) / 100;\n    }\n    // Return -1 if the sides do not form a valid triangle\n    return -1;\n}\n"}
{"task_id": "CPP/72", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    int n = q.size();\n    \n    // Check if the vector is palindromic\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) {\n            return false; // Not balanced\n        }\n    }\n    \n    // Calculate the sum of elements\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    \n    // Check if the sum is less than or equal to the maximum weight\n    return sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n"}
{"task_id": "CPP/74", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int totalChars1 = 0;\n    int totalChars2 = 0;\n\n    // Calculate total characters in lst1\n    for (const string& str : lst1) {\n        totalChars1 += str.size();\n    }\n\n    // Calculate total characters in lst2\n    for (const string& str : lst2) {\n        totalChars2 += str.size();\n    }\n\n    // Compare total characters and return the appropriate vector\n    if (totalChars1 < totalChars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nbool is_multiply_prime(int a) {\n    vector<int> primes;\n    \n    // Collect all prime numbers less than 100\n    for (int i = 2; i < 100; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n\n    // Check for combinations of three primes\n    for (int i = 0; i < primes.size(); i++) {\n        for (int j = i; j < primes.size(); j++) {\n            for (int k = j; k < primes.size(); k++) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n"}
{"task_id": "CPP/76", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n <= 1) {\n        return false; // n must be greater than 1 for it to be a base of a power\n    }\n    if (x < 1) {\n        return false; // x must be at least 1 to be a power of n\n    }\n    \n    // Calculate the power of n until it exceeds x\n    int power = 1; // n^0 = 1\n    while (power < x) {\n        power *= n; // Calculate n^k\n    }\n    \n    return power == x; // Check if we found the exact power\n}\n"}
{"task_id": "CPP/77", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool iscube(int a) {\n    // Calculate the cube root of the absolute value of a\n    int cubeRoot = round(pow(abs(a), 1.0 / 3.0));\n    \n    // Check if the cube of the calculated cube root equals the absolute value of a\n    return (cubeRoot * cubeRoot * cubeRoot == abs(a));\n}\n"}
{"task_id": "CPP/78", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint hex_key(string num) {\n    // Set of prime hexadecimal digits\n    const string primeHexDigits = \"2357BD\"; // B = 11, D = 13 in decimal\n    int count = 0;\n\n    // Iterate through each character in the input string\n    for (char c : num) {\n        // Check if the character is in the set of prime hexadecimal digits\n        if (primeHexDigits.find(c) != string::npos) {\n            count++;\n        }\n    }\n\n    return count; // Return the count of prime hexadecimal digits\n}\n"}
{"task_id": "CPP/79", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    string binary = \"\";\n    \n    // Handle the case when decimal is 0\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    // Convert decimal to binary\n    while (decimal > 0) {\n        binary = to_string(decimal % 2) + binary; // Prepend the binary digit\n        decimal /= 2; // Divide by 2 to get the next digit\n    }\n\n    // Add the \"db\" prefix and suffix\n    return \"db\" + binary + \"db\";\n}\n"}
{"task_id": "CPP/80", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is at least 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Iterate through the string and check every 3 consecutive characters\n    for (int i = 0; i <= s.length() - 3; i++) {\n        // Check if the three consecutive characters are distinct\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false; // Not happy if any two are the same\n        }\n    }\n\n    return true; // All checks passed, the string is happy\n}\n"}
{"task_id": "CPP/81", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letterGrades;\n    \n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letterGrades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letterGrades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letterGrades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letterGrades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letterGrades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letterGrades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letterGrades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letterGrades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letterGrades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letterGrades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letterGrades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letterGrades.push_back(\"D-\");\n        } else {\n            letterGrades.push_back(\"E\");\n        }\n    }\n    \n    return letterGrades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it is prime\n}\n\nbool prime_length(string str) {\n    int length = str.length();\n    return isPrime(length);\n}\n"}
{"task_id": "CPP/83", "generation": "#include<stdio.h>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n <= 0) return 0; // No n-digit numbers if n is non-positive\n\n    // Count of n-digit numbers that start with 1\n    int start_with_one = 1; // Only one way to start with 1 (1xxxx...x)\n    int remaining_digits = n - 1; // Remaining digits can be anything from 0-9\n    start_with_one *= 9; // The first digit can be 1, and the rest can be 0-9 (9 options)\n\n    // Count of n-digit numbers that end with 1\n    int end_with_one = 0; // We will calculate this separately\n    if (n == 1) {\n        end_with_one = 1; // Only the number 1 itself\n    } else {\n        // The first digit can be anything from 1-9 (9 options)\n        // The last digit is fixed as 1\n        end_with_one = 9 * (10^(n - 2)); // 9 options for the first digit and 10 options for each of the remaining digits\n    }\n\n    // Total count of n-digit numbers that start or end with 1\n    return start_with_one + end_with_one;\n}\n"}
{"task_id": "CPP/84", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    \n    // Calculate the sum of the digits of N\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to sum\n        N /= 10;       // Remove the last digit\n    }\n    \n    // Convert the sum to binary\n    string binary = \"\";\n    if (sum == 0) {\n        return \"0\"; // Handle the case where the sum is 0\n    }\n    \n    while (sum > 0) {\n        binary = to_string(sum % 2) + binary; // Prepend the binary digit\n        sum /= 2; // Divide sum by 2\n    }\n    \n    return binary; // Return the binary representation of the sum\n}\n"}
{"task_id": "CPP/85", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2 to get odd indices\n        if (lst[i] % 2 == 0) { // Check if the element is even\n            sum += lst[i]; // Add to sum if it's even\n        }\n    }\n    return sum; // Return the total sum of even elements at odd indices\n}\n"}
{"task_id": "CPP/86", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result = \"\";\n    string word = \"\";\n    \n    for (char c : s) {\n        if (c == ' ') {\n            // If we encounter a space, sort the current word and add it to the result\n            if (!word.empty()) {\n                sort(word.begin(), word.end());\n                result += word + ' ';\n                word = \"\"; // Reset the word\n            }\n            result += ' '; // Add the space to the result\n        } else {\n            word += c; // Build the current word\n        }\n    }\n    \n    // Sort and add the last word if there is one\n    if (!word.empty()) {\n        sort(word.begin(), word.end());\n        result += word;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/87", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n\n    // Iterate through the 2D vector\n    for (int i = 0; i < lst.size(); i++) {\n        for (int j = 0; j < lst[i].size(); j++) {\n            // Check if the current element is equal to x\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j}); // Store the coordinates\n            }\n        }\n    }\n\n    // Sort the coordinates by row (ascending) and then by column (descending)\n    sort(coordinates.begin(), coordinates.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort by column in descending order\n        }\n        return a[0] < b[0]; // Sort by row in ascending order\n    });\n\n    return coordinates;\n}\n"}
{"task_id": "CPP/88", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the array is empty or has only one element\n    if (array.size() <= 1) {\n        return array; // Return the array as is\n    }\n\n    // Calculate the sum of the first and last elements\n    int sum = array.front() + array.back();\n\n    // Sort the array based on the sum's parity\n    if (sum % 2 == 0) {\n        // If the sum is even, sort in descending order\n        sort(array.begin(), array.end(), greater<int>());\n    } else {\n        // If the sum is odd, sort in ascending order\n        sort(array.begin(), array.end());\n    }\n\n    return array; // Return the sorted array\n}\n"}
{"task_id": "CPP/89", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string encrypted = \"\";\n    for (char c : s) {\n        // Check if the character is a lowercase letter\n        if (c >= 'a' && c <= 'z') {\n            // Shift the character by 2 positions down the alphabet\n            char newChar = (c - 'a' + 4) % 26 + 'a'; // 2 * 2 = 4\n            encrypted += newChar;\n        }\n    }\n    return encrypted;\n}\n"}
{"task_id": "CPP/90", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    // Remove duplicates by converting the vector to a set\n    set<int> unique_elements(lst.begin(), lst.end());\n    \n    // If there are less than 2 unique elements, return None\n    if (unique_elements.size() < 2) {\n        return -1; // Using -1 to indicate None, as per the problem statement\n    }\n    \n    // Convert the set back to a vector and sort it\n    vector<int> sorted_unique(unique_elements.begin(), unique_elements.end());\n    \n    // Return the second smallest element\n    return sorted_unique[1];\n}\n"}
{"task_id": "CPP/91", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nint is_bored(string S) {\n    int boredomCount = 0;\n    stringstream ss(S);\n    string sentence;\n\n    // Split the string into sentences based on delimiters\n    while (getline(ss, sentence, '.')) {\n        if (sentence.empty()) continue;\n        if (sentence.back() == '?' || sentence.back() == '!') {\n            sentence.pop_back(); // Remove the last character if it's a delimiter\n        }\n        // Trim leading spaces\n        size_t start = sentence.find_first_not_of(\" \");\n        if (start != string::npos) {\n            sentence = sentence.substr(start);\n        }\n        // Check if the sentence starts with \"I\"\n        if (sentence.rfind(\"I \", 0) == 0) { // Check if it starts with \"I \"\n            boredomCount++;\n        }\n    }\n\n    return boredomCount;\n}\n"}
{"task_id": "CPP/92", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n    \n    // Check if one number is equal to the sum of the other two\n    return (a == b + c) || (b == a + c) || (c == a + b);\n}\n"}
{"task_id": "CPP/93", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    string result = \"\";\n    for (char c : message) {\n        // Swap case\n        if (isalpha(c)) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n            // Replace vowels\n            if (c == 'A' || c == 'a') {\n                c = 'C'; // 'A' -> 'C'\n            } else if (c == 'E' || c == 'e') {\n                c = 'G'; // 'E' -> 'G'\n            } else if (c == 'I' || c == 'i') {\n                c = 'K'; // 'I' -> 'K'\n            } else if (c == 'O' || c == 'o') {\n                c = 'Q'; // 'O' -> 'Q'\n            } else if (c == 'U' || c == 'u') {\n                c = 'W'; // 'U' -> 'W'\n            }\n        }\n        result += c;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n\n"}
{"task_id": "CPP/95", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<cctype> // for islower and isupper\nusing namespace std;\n\nbool check_dict_case(map<string,string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n    \n    // Iterate through each key in the map\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n        \n        // Check if the key is not a string or contains invalid characters\n        if (!std::all_of(key.begin(), key.end(), [](unsigned char c) { return std::isalpha(c); })) {\n            return false;\n        }\n        \n        // Check if the key is not all lower case or all upper case\n        if (!std::all_of(key.begin(), key.end(), ::islower) && \n            !std::all_of(key.begin(), key.end(), ::isupper)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/96", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    \n    // Function to check if a number is prime\n    auto is_prime = [](int num) {\n        if (num < 2) return false;\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    };\n    \n    // Find all prime numbers less than n\n    for (int i = 2; i < n; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    \n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the unit digits of both integers\n    int unitDigitA = abs(a) % 10; // Use abs to handle negative numbers\n    int unitDigitB = abs(b) % 10; // Use abs to handle negative numbers\n    \n    // Return the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n"}
{"task_id": "CPP/98", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    for (int i = 0; i < s.length(); i += 2) { // Iterate over even indices\n        char c = s[i];\n        if (c >= 'A' && c <= 'Z') { // Check if the character is an uppercase vowel\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/99", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nint closest_integer(string value) {\n    double num = stod(value); // Convert string to double\n    int lower = floor(num); // Get the lower integer\n    int upper = ceil(num); // Get the upper integer\n\n    // Check the distance from the number to the lower and upper integers\n    double distanceToLower = abs(num - lower);\n    double distanceToUpper = abs(num - upper);\n\n    // If the distances are equal, round away from zero\n    if (distanceToLower == distanceToUpper) {\n        if (num > 0) {\n            return upper; // Round up for positive numbers\n        } else {\n            return lower; // Round down for negative numbers\n        }\n    }\n\n    // Return the closest integer\n    return (distanceToLower < distanceToUpper) ? lower : upper;\n}\n"}
{"task_id": "CPP/100", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    int currentStones = n; // Start with n stones for the first level\n\n    for (int i = 0; i < n; i++) {\n        stones.push_back(currentStones); // Add the current level stones to the vector\n        // Determine the next number of stones based on whether currentStones is odd or even\n        if (currentStones % 2 == 0) {\n            currentStones += 2; // Next even number\n        } else {\n            currentStones += 2; // Next odd number\n        }\n    }\n\n    return stones;\n}\n"}
{"task_id": "CPP/101", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    stringstream ss(s);\n    string word;\n\n    // Replace commas with spaces for easier splitting\n    replace(s.begin(), s.end(), ',', ' ');\n\n    // Split the string by spaces\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    return words;\n}\n"}
{"task_id": "CPP/102", "generation": "#include<stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1;\n    }\n    \n    // Find the largest even number in the range [x, y]\n    if (y % 2 != 0) {\n        y--; // Decrement y if it's odd to make it even\n    }\n    \n    // Check if the adjusted y is still within the range\n    if (y >= x) {\n        return y; // Return the largest even number\n    }\n    \n    return -1; // No even number in the range\n}\n"}
{"task_id": "CPP/103", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    \n    // Calculate the sum of integers from n to m\n    int sum = 0;\n    for (int i = n; i <= m; i++) {\n        sum += i;\n    }\n    \n    // Calculate the number of integers from n to m\n    int count = m - n + 1;\n    \n    // Calculate the average and round down\n    int average = sum / count; // This will automatically round down in integer division\n    \n    // Convert the average to binary\n    string binary = \"\";\n    while (average > 0) {\n        binary = to_string(average % 2) + binary;\n        average /= 2;\n    }\n    \n    return binary.empty() ? \"0\" : binary; // Handle the case when average is 0\n}\n"}
{"task_id": "CPP/104", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool hasEvenDigit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true; // Found an even digit\n        }\n        num /= 10;\n    }\n    return false; // No even digits found\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    sort(result.begin(), result.end()); // Sort the result in increasing order\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Map to convert numbers to their corresponding names\n    map<int, string> numToName = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Vector to hold valid numbers\n    vector<int> validNumbers;\n\n    // Filter the numbers to include only those between 1 and 9\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            validNumbers.push_back(num);\n        }\n    }\n\n    // Sort the valid numbers\n    sort(validNumbers.begin(), validNumbers.end());\n\n    // Reverse the sorted numbers\n    reverse(validNumbers.begin(), validNumbers.end());\n\n    // Prepare the result vector\n    vector<string> result;\n\n    // Convert the numbers to their corresponding names\n    for (int num : validNumbers) {\n        result.push_back(numToName[num]);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            // Calculate factorial for even i\n            int factorial = 1;\n            for (int j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else {\n            // Calculate sum from 1 to i for odd i\n            result[i - 1] = (i * (i + 1)) / 2; // Sum of first i natural numbers\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n\n    for (int i = 1; i <= n; i++) {\n        string numStr = to_string(i);\n        string revStr = string(numStr.rbegin(), numStr.rend());\n\n        if (numStr == revStr) { // Check if the number is a palindrome\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n\n    return {evenCount, oddCount};\n}\n"}
{"task_id": "CPP/108", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    while (num != 0) {\n        sum += num % 10; // Add the last digit\n        num /= 10; // Remove the last digit\n    }\n    return sum;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(abs(num)) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true; // An empty vector is considered sorted.\n\n    int n = arr.size();\n    int count = 0; // Count the number of times the order is broken.\n\n    for (int i = 0; i < n; i++) {\n        // Check if the current element is greater than the next element\n        if (arr[i] > arr[(i + 1) % n]) {\n            count++;\n        }\n    }\n\n    // If there is more than one break in the order, it's not possible to sort it with shifts.\n    return count <= 1;\n}\n"}
{"task_id": "CPP/110", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    bool hasEvenInLst2 = false;\n    bool hasOddInLst1 = false;\n\n    // Check if lst1 has any odd numbers and lst2 has any even numbers\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            hasOddInLst1 = true; // lst1 has an odd number\n            break;\n        }\n    }\n\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            hasEvenInLst2 = true; // lst2 has an even number\n            break;\n        }\n    }\n\n    // If lst1 has odd numbers and lst2 has even numbers, we can exchange\n    if (hasOddInLst1 && hasEvenInLst2) {\n        return \"YES\";\n    }\n\n    // If lst1 is already all even, return \"YES\"\n    if (!hasOddInLst1) {\n        return \"YES\";\n    }\n\n    // Otherwise, return \"NO\"\n    return \"NO\";\n}\n"}
{"task_id": "CPP/111", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nmap<string, int> histogram(string test) {\n    map<string, int> countMap;\n    stringstream ss(test);\n    string word;\n    \n    // Count occurrences of each letter\n    while (ss >> word) {\n        countMap[word]++;\n    }\n\n    // Find the maximum count\n    int maxCount = 0;\n    for (const auto& pair : countMap) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Prepare the result map with letters having the maximum count\n    map<string, int> result;\n    for (const auto& pair : countMap) {\n        if (pair.second == maxCount) {\n            result[pair.first] = pair.second;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/112", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Create a set of characters to delete for faster lookup\n    unordered_set<char> charsToDelete(c.begin(), c.end());\n    \n    // Create a new string with characters not in charsToDelete\n    string result;\n    for (char ch : s) {\n        if (charsToDelete.find(ch) == charsToDelete.end()) {\n            result += ch;\n        }\n    }\n    \n    // Check if the resulting string is a palindrome\n    string reversedResult = result;\n    reverse(reversedResult.begin(), reversedResult.end());\n    bool isPalindrome = (result == reversedResult);\n    \n    // Prepare the output\n    vector<string> output;\n    output.push_back(result);\n    output.push_back(isPalindrome ? \"True\" : \"False\");\n    \n    return output;\n}\n"}
{"task_id": "CPP/113", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (int i = 0; i < lst.size(); i++) {\n        int oddCount = 0;\n        \n        // Count odd digits in the current string\n        for (char c : lst[i]) {\n            if ((c - '0') % 2 != 0) {\n                oddCount++;\n            }\n        }\n        \n        // Create the output string\n        string output = \"the number of odd elements \" + to_string(oddCount) + \n                        \"n the str\" + to_string(i + 1) + \n                        \"ng \" + to_string(i + 1) + \n                        \" of the \" + to_string(i + 1) + \"nput.\";\n        \n        result.push_back(output);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long minSum = nums[0];\n    long long currentSum = 0;\n\n    for (long long num : nums) {\n        currentSum += num;\n        if (currentSum < minSum) {\n            minSum = currentSum;\n        }\n        if (currentSum > 0) {\n            currentSum = 0; // Reset current sum if it becomes positive\n        }\n    }\n\n    return minSum;\n}\n"}
{"task_id": "CPP/115", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int totalLowerings = 0;\n\n    for (const auto& row : grid) {\n        int waterUnits = 0;\n\n        // Count the number of water units (1s) in the current row\n        for (int water : row) {\n            waterUnits += water;\n        }\n\n        // Calculate the number of times we need to lower the bucket for this row\n        if (waterUnits > 0) {\n            totalLowerings += (waterUnits + capacity - 1) / capacity; // Ceiling division\n        }\n    }\n\n    return totalLowerings;\n}\n"}
{"task_id": "CPP/116", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> arr) {\n    // Custom comparator for sorting\n    sort(arr.begin(), arr.end(), [](int a, int b) {\n        // Count the number of 1s in binary representation\n        int countA = __builtin_popcount(a);\n        int countB = __builtin_popcount(b);\n        \n        // First compare by number of 1s, then by value\n        if (countA == countB) {\n            return a < b; // Sort by value if counts are equal\n        }\n        return countA < countB; // Sort by number of 1s\n    });\n    \n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word;\n    \n    // Split the string into words\n    for (char c : s) {\n        if (c == ' ') {\n            // Process the word if it's not empty\n            if (!word.empty()) {\n                int consonantCount = 0;\n                // Count consonants in the word\n                for (char ch : word) {\n                    if (isalpha(ch) && !strchr(\"aeiouAEIOU\", ch)) {\n                        consonantCount++;\n                    }\n                }\n                // Check if the consonant count matches n\n                if (consonantCount == n) {\n                    result.push_back(word);\n                }\n                word.clear(); // Reset the word for the next iteration\n            }\n        } else {\n            word += c; // Build the current word\n        }\n    }\n    \n    // Process the last word if there is one\n    if (!word.empty()) {\n        int consonantCount = 0;\n        for (char ch : word) {\n            if (isalpha(ch) && !strchr(\"aeiouAEIOU\", ch)) {\n                consonantCount++;\n            }\n        }\n        if (consonantCount == n) {\n            result.push_back(word);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    // Define a set of vowels for easy checking\n    string vowels = \"aeiouAEIOU\";\n    \n    // Initialize the variable to store the closest vowel\n    string closestVowel = \"\";\n    \n    // Iterate through the word from the end to the beginning\n    for (int i = word.length() - 1; i > 0; i--) {\n        // Check if the current character is a vowel\n        if (vowels.find(word[i]) != string::npos) {\n            // Check if the previous character is a consonant\n            if (i > 0 && vowels.find(word[i - 1]) == string::npos) {\n                // If we found a vowel between two consonants, store it\n                closestVowel = word[i];\n                break; // We only need the closest one\n            }\n        }\n    }\n    \n    return closestVowel; // Return the closest vowel found or an empty string\n}\n"}
{"task_id": "CPP/119", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0];\n    string s2 = lst[1];\n\n    // Function to count the balance of parentheses\n    auto countBalance = [](const string& s) {\n        int balance = 0;\n        for (char c : s) {\n            if (c == '(') {\n                balance++;\n            } else {\n                balance--;\n            }\n        }\n        return balance;\n    };\n\n    // Calculate the balance of both strings\n    int balance1 = countBalance(s1);\n    int balance2 = countBalance(s2);\n\n    // Check if we can concatenate in both orders\n    // Check s1 + s2\n    if (balance1 + balance2 == 0) {\n        return \"Yes\";\n    }\n    \n    // Check s2 + s1\n    if (balance2 + balance1 == 0) {\n        return \"Yes\";\n    }\n\n    // If neither order works, return \"No\"\n    return \"No\";\n}\n"}
{"task_id": "CPP/120", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Take the first k elements\n    vector<int> maxElements(arr.begin(), arr.begin() + k);\n    \n    // Sort the selected k elements in ascending order\n    sort(maxElements.begin(), maxElements.end());\n    \n    return maxElements;\n}\n"}
{"task_id": "CPP/121", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) { // Iterate through even positions\n        if (lst[i] % 2 != 0) { // Check if the element is odd\n            sum += lst[i]; // Add to sum if it's odd\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++) {\n        if (arr[i] >= -99 && arr[i] <= 99) { // Check if the element has at most two digits\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    while (n != 1) {\n        if (n % 2 != 0) { // Check if n is odd\n            odd_numbers.push_back(n);\n        }\n        // Apply the Collatz rules\n        if (n % 2 == 0) {\n            n = n / 2; // If n is even\n        } else {\n            n = 3 * n + 1; // If n is odd\n        }\n    }\n    // Include 1 in the sequence as it is the last number\n    odd_numbers.push_back(1);\n    \n    // Sort the vector before returning\n    sort(odd_numbers.begin(), odd_numbers.end());\n    \n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) {\n        return false;\n    }\n\n    // Check if the date is in the correct format mm-dd-yyyy\n    if (date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n\n    // Split the date into components\n    int month, day, year;\n    char delimiter;\n    stringstream ss(date);\n    ss >> month >> delimiter >> day >> delimiter >> year;\n\n    // Check if the month, day, and year are valid integers\n    if (ss.fail() || delimiter != '-') {\n        return false;\n    }\n\n    // Check month range\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    // Check day range based on month\n    if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && (day < 1 || day > 31)) {\n        return false;\n    }\n    if ((month == 4 || month == 6 || month == 9 || month == 11) && (day < 1 || day > 30)) {\n        return false;\n    }\n    if (month == 2) {\n        if (day < 1 || day > 29) {\n            return false;\n        }\n    }\n\n    // If all checks are passed, the date is valid\n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<sstream>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    // Check for whitespace\n    if (txt.find(' ') != string::npos) {\n        vector<string> words;\n        stringstream ss(txt);\n        string word;\n        while (ss >> word) {\n            words.push_back(word);\n        }\n        return words;\n    }\n    \n    // Check for commas\n    if (txt.find(',') != string::npos) {\n        vector<string> words;\n        stringstream ss(txt);\n        string word;\n        while (getline(ss, word, ',')) {\n            words.push_back(word);\n        }\n        return words;\n    }\n    \n    // If no whitespace or commas, count lowercase letters with odd order\n    int count = 0;\n    for (char c : txt) {\n        if (c >= 'a' && c <= 'z') {\n            int index = c - 'a';\n            if (index % 2 == 1) { // odd index\n                count++;\n            }\n        }\n    }\n    \n    return {to_string(count)};\n}\n"}
{"task_id": "CPP/126", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    unordered_map<int, int> countMap;\n    \n    for (int i = 0; i < lst.size(); i++) {\n        // Count occurrences of each number\n        countMap[lst[i]]++;\n        // If any number appears more than twice, return false\n        if (countMap[lst[i]] > 2) {\n            return false;\n        }\n        // Check if the list is sorted\n        if (i > 0 && lst[i] < lst[i - 1]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it is prime\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    // Calculate the start and end of the intersection\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n\n    // Check if there is an intersection\n    if (start > end) {\n        return \"NO\"; // No intersection\n    }\n\n    // Calculate the length of the intersection\n    int length = end - start + 1; // +1 because both ends are inclusive\n\n    // Check if the length is a prime number\n    if (isPrime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768; // Return -32768 for empty array\n    }\n\n    int sum_magnitudes = 0;\n    int product_sign = 1; // Start with a neutral product sign\n\n    for (int num : arr) {\n        if (num > 0) {\n            sum_magnitudes += num; // Add magnitude of positive numbers\n        } else if (num < 0) {\n            sum_magnitudes += -num; // Add magnitude of negative numbers\n            product_sign *= -1; // Flip the sign for negative numbers\n        } else {\n            product_sign = 0; // If there's a zero, product sign becomes zero\n            break; // No need to continue, as the product sign is determined\n        }\n    }\n\n    return sum_magnitudes * product_sign; // Return the final result\n}\n"}
{"task_id": "CPP/129", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvoid dfs(const vector<vector<int>>& grid, int x, int y, int k, vector<int>& currentPath, vector<int>& minPath) {\n    // If we have reached the length k, we compare the current path with the minimum path\n    if (currentPath.size() == k) {\n        if (minPath.empty() || currentPath < minPath) {\n            minPath = currentPath; // Update the minimum path\n        }\n        return;\n    }\n\n    // Directions for moving up, down, left, right\n    vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    // Explore all neighbors\n    for (const auto& dir : directions) {\n        int newX = x + dir.first;\n        int newY = y + dir.second;\n\n        // Check if the new position is within bounds\n        if (newX >= 0 && newX < grid.size() && newY >= 0 && newY < grid[0].size()) {\n            currentPath.push_back(grid[newX][newY]); // Add the value to the current path\n            dfs(grid, newX, newY, k, currentPath, minPath); // Recur for the next cell\n            currentPath.pop_back(); // Backtrack\n        }\n    }\n}\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    vector<int> minPath; // To store the minimum path found\n    int n = grid.size();\n\n    // Try starting from each cell in the grid\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            vector<int> currentPath = {grid[i][j]}; // Start path with the current cell\n            dfs(grid, i, j, k, currentPath, minPath); // Start DFS from the current cell\n        }\n    }\n\n    return minPath; // Return the minimum path found\n}\n"}
{"task_id": "CPP/130", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> tribonacci(n + 1);\n    \n    // Base cases\n    tribonacci[0] = 1; // tri(0)\n    if (n >= 1) tribonacci[1] = 3; // tri(1)\n    if (n >= 2) tribonacci[2] = 2; // tri(2)\n\n    // Calculate tribonacci values for n >= 3\n    for (int i = 3; i <= n; i++) {\n        if (i % 2 == 0) {\n            tribonacci[i] = 1 + (i / 2);\n        } else {\n            tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i + 1];\n        }\n    }\n\n    return tribonacci;\n}\n"}
{"task_id": "CPP/131", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOdd = false;\n\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10; // Remove the last digit\n    }\n\n    return hasOdd ? product : 0; // Return product if there's at least one odd digit, otherwise return 0\n}\n"}
{"task_id": "CPP/132", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int openCount = 0; // Count of open brackets\n    int nestedCount = 0; // Count of nested brackets\n\n    for (char ch : str) {\n        if (ch == '[') {\n            openCount++;\n            // If we have at least one open bracket before this one, we have a nested structure\n            if (openCount > 1) {\n                nestedCount++;\n            }\n        } else if (ch == ']') {\n            if (openCount > 0) {\n                openCount--;\n            } else {\n                // More closing brackets than opening brackets\n                return false;\n            }\n        }\n    }\n\n    // We need at least one nested structure and all brackets must be closed\n    return nestedCount > 0 && openCount == 0;\n}\n"}
{"task_id": "CPP/133", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int rounded = ceil(num); // Round to the upper int\n        sum += rounded * rounded; // Add the square of the rounded number\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/134", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Trim the string to remove trailing spaces\n    size_t end = txt.find_last_not_of(' ');\n    if (end == string::npos) {\n        return false; // The string is empty or contains only spaces\n    }\n    \n    // Get the last character\n    char lastChar = txt[end];\n    \n    // Check if the last character is an alphabetical character\n    if (isalpha(lastChar)) {\n        // Check if the last character is part of a word\n        // A character is part of a word if it is preceded by a non-space character\n        if (end > 0 && txt[end - 1] != ' ') {\n            return false; // Last character is part of a word\n        }\n        return true; // Last character is an alphabetical character and not part of a word\n    }\n    \n    return false; // Last character is not an alphabetical character\n}\n"}
{"task_id": "CPP/135", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int largestIndex = -1; // Initialize the largest index to -1\n    for (int i = 1; i < arr.size(); i++) { // Start from the second element\n        if (arr[i] < arr[i - 1]) { // Check if the current element is less than the previous one\n            largestIndex = i; // Update the largest index\n        }\n    }\n    return largestIndex; // Return the largest index found, or -1 if none found\n}\n"}
{"task_id": "CPP/136", "generation": "#include<stdio.h>\n#include<vector>\n#include<limits.h>\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = INT_MIN; // Initialize to the smallest possible integer\n    int smallest_positive = INT_MAX; // Initialize to the largest possible integer\n\n    for (int num : lst) {\n        if (num < 0) {\n            if (num > largest_negative) {\n                largest_negative = num; // Update largest negative\n            }\n        } else if (num > 0) {\n            if (num < smallest_positive) {\n                smallest_positive = num; // Update smallest positive\n            }\n        }\n    }\n\n    // If no negative number was found, set to 0\n    if (largest_negative == INT_MIN) {\n        largest_negative = 0;\n    }\n    \n    // If no positive number was found, set to 0\n    if (smallest_positive == INT_MAX) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n"}
{"task_id": "CPP/137", "generation": "#include <stdio.h>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n#include <sstream>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Convert boost::any to string for comparison\n    string str_a, str_b;\n    \n    if (a.type() == typeid(int)) {\n        str_a = to_string(boost::any_cast<int>(a));\n    } else if (a.type() == typeid(float)) {\n        str_a = to_string(boost::any_cast<float>(a));\n    } else if (a.type() == typeid(string)) {\n        str_a = boost::any_cast<string>(a);\n    }\n\n    if (b.type() == typeid(int)) {\n        str_b = to_string(boost::any_cast<int>(b));\n    } else if (b.type() == typeid(float)) {\n        str_b = to_string(boost::any_cast<float>(b));\n    } else if (b.type() == typeid(string)) {\n        str_b = boost::any_cast<string>(b);\n    }\n\n    // Replace ',' with '.' for proper float comparison\n    replace(str_a.begin(), str_a.end(), ',', '.');\n    replace(str_b.begin(), str_b.end(), ',', '.');\n\n    // Convert to float for comparison\n    float num_a = stof(str_a);\n    float num_b = stof(str_b);\n\n    // Compare the two numbers\n    if (num_a == num_b) {\n        return \"None\";\n    } else {\n        return (num_a > num_b) ? (a.type() == typeid(string) ? str_a : a) : (b.type() == typeid(string) ? str_b : b);\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // The smallest sum of 4 positive even numbers is 8 (2 + 2 + 2 + 2)\n    // Therefore, if n is less than 8, it cannot be expressed as the sum of 4 positive even numbers.\n    if (n < 8) {\n        return false;\n    }\n    \n    // If n is even and greater than or equal to 8, it can be expressed as the sum of 4 positive even numbers.\n    return n % 2 == 0;\n}\n"}
{"task_id": "CPP/139", "generation": "#include<stdio.h>\nusing namespace std;\n\nlong long factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i > 0; i--) {\n        result *= factorial(i);\n    }\n    return result;\n}\n"}
{"task_id": "CPP/140", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int spaceCount = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            spaceCount++;\n        } else {\n            if (spaceCount > 2) {\n                result += '-'; // Replace more than 2 spaces with a single '-'\n            } else if (spaceCount > 0) {\n                result += '_'; // Replace single space or double spaces with '_'\n            }\n            result += c; // Add the current character\n            spaceCount = 0; // Reset space count\n        }\n    }\n\n    // Handle trailing spaces\n    if (spaceCount > 2) {\n        result += '-';\n    } else if (spaceCount > 0) {\n        result += '_';\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include<stdio.h>\n#include<string>\n#include<regex>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check for exactly one dot\n    size_t dotPos = file_name.find('.');\n    if (dotPos == string::npos || file_name.find('.', dotPos + 1) != string::npos) {\n        return \"No\";\n    }\n\n    // Split the file name into name and extension\n    string namePart = file_name.substr(0, dotPos);\n    string extPart = file_name.substr(dotPos + 1);\n\n    // Check if namePart is empty and starts with a letter\n    if (namePart.empty() || !isalpha(namePart[0])) {\n        return \"No\";\n    }\n\n    // Check for valid extensions\n    if (extPart != \"txt\" && extPart != \"exe\" && extPart != \"dll\") {\n        return \"No\";\n    }\n\n    // Count digits in the namePart\n    int digitCount = 0;\n    for (char c : namePart) {\n        if (isdigit(c)) {\n            digitCount++;\n        }\n    }\n\n    // Check if there are more than three digits\n    if (digitCount > 3) {\n        return \"No\";\n    }\n\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i]; // Square the entry if index is a multiple of 3\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i]; // Cube the entry if index is a multiple of 4 and not a multiple of 3\n        } else {\n            sum += lst[i]; // Add the entry as is if index is not a multiple of 3 or 4\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include<stdio.h>\n#include<string>\n#include<vector>\n#include<sstream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    vector<string> result;\n\n    // Split the sentence into words\n    while (ss >> word) {\n        // Check if the length of the word is prime\n        if (isPrime(word.length())) {\n            result.push_back(word);\n        }\n    }\n\n    // Join the words with a space\n    string output;\n    for (size_t i = 0; i < result.size(); i++) {\n        output += result[i];\n        if (i < result.size() - 1) {\n            output += \" \";\n        }\n    }\n\n    return output;\n}\n"}
{"task_id": "CPP/144", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Split the fraction x\n    size_t pos = x.find('/');\n    int numX = stoi(x.substr(0, pos)); // numerator of x\n    int denX = stoi(x.substr(pos + 1)); // denominator of x\n\n    // Split the fraction n\n    pos = n.find('/');\n    int numN = stoi(n.substr(0, pos)); // numerator of n\n    int denN = stoi(n.substr(pos + 1)); // denominator of n\n\n    // Multiply the fractions: (numX/denX) * (numN/denN) = (numX * numN) / (denX * denN)\n    int numerator = numX * numN;\n    int denominator = denX * denN;\n\n    // Check if the result is a whole number\n    return (numerator % denominator == 0);\n}\n"}
{"task_id": "CPP/145", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n// Function to calculate the sum of digits of a number\nint digit_sum(int num) {\n    int sum = 0;\n    // Handle negative numbers by taking the absolute value\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Function to sort the vector based on the sum of digits\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of pairs to store the original index and the number\n    vector<pair<int, int>> indexed_nums;\n    for (int i = 0; i < nums.size(); i++) {\n        indexed_nums.push_back({nums[i], i});\n    }\n\n    // Sort the vector based on the sum of digits and original index\n    sort(indexed_nums.begin(), indexed_nums.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        int sum_a = digit_sum(a.first);\n        int sum_b = digit_sum(b.first);\n        // First compare by digit sum, then by original index\n        if (sum_a == sum_b) {\n            return a.second < b.second;\n        }\n        return sum_a < sum_b;\n    });\n\n    // Extract the sorted numbers from the pairs\n    vector<int> sorted_nums;\n    for (const auto& p : indexed_nums) {\n        sorted_nums.push_back(p.first);\n    }\n    \n    return sorted_nums;\n}\n"}
{"task_id": "CPP/146", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n\n    for (int num : nums) {\n        if (num > 10) {\n            string numStr = to_string(num);\n            char firstDigit = numStr[0];\n            char lastDigit = numStr[numStr.size() - 1];\n\n            if ((firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || firstDigit == '7' || firstDigit == '9') &&\n                (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' || lastDigit == '7' || lastDigit == '9')) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Fill the vector a with the given formula\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n    \n    int count = 0;\n    \n    // Check all combinations of triples (i, j, k)\n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            for (int k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/148", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Find the indices of the given planets\n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n    \n    // Check if both planets are valid\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {}; // Return empty vector if either planet is invalid\n    }\n    \n    // Get the indices of the planets\n    int index1 = distance(planets.begin(), it1);\n    int index2 = distance(planets.begin(), it2);\n    \n    // Ensure index1 is less than index2\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Collect planets between planet1 and planet2\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0; // Check for odd length\n    }), lst.end());\n\n    // Sort the remaining strings first by length, then alphabetically\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Sort alphabetically if lengths are equal\n        }\n        return a.length() < b.length(); // Sort by length\n    });\n\n    return lst; // Return the sorted vector\n}\n"}
{"task_id": "CPP/150", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\nint x_or_y(int n, int x, int y) {\n    if (isPrime(n)) {\n        return x; // Return x if n is prime\n    } else {\n        return y; // Return y if n is not prime\n    }\n}\n"}
{"task_id": "CPP/151", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    for (float num : lst) {\n        // Check if the number is a non-negative integer and odd\n        if (num >= 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<int>(num) * static_cast<int>(num); // Add the square of the odd number\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/152", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    for (size_t i = 0; i < game.size(); i++) {\n        result.push_back(abs(game[i] - guess[i]));\n    }\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = -1;\n    string strongest_extension = \"\";\n\n    for (const string& extension : extensions) {\n        int CAP = 0, SM = 0;\n        for (char c : extension) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n        int strength = CAP - SM;\n\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n"}
{"task_id": "CPP/154", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Check if b is longer than a, if so, it can't be a substring\n    if (b.length() > a.length()) {\n        return false;\n    }\n    \n    // Create a new string that is the concatenation of b with itself\n    string b_rotated = b + b;\n    \n    // Check if b or any of its rotations is a substring of a\n    return b_rotated.find(a) != string::npos;\n}\n"}
{"task_id": "CPP/155", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    vector<int> count(2, 0); // count[0] for even, count[1] for odd\n    num = abs(num); // Consider absolute value for counting digits\n\n    while (num > 0) {\n        int digit = num % 10; // Get the last digit\n        if (digit % 2 == 0) {\n            count[0]++; // Increment even count\n        } else {\n            count[1]++; // Increment odd count\n        }\n        num /= 10; // Remove the last digit\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/156", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the mapping of integers to their Roman numeral equivalents\n    vector<pair<int, string>> romanNumerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"},\n        {1, \"i\"}\n    };\n    \n    string result = \"\";\n    \n    // Iterate over the roman numeral pairs\n    for (const auto& [value, symbol] : romanNumerals) {\n        // While the number is greater than or equal to the value\n        while (number >= value) {\n            result += symbol; // Append the symbol to the result\n            number -= value;  // Decrease the number by the value\n        }\n    }\n    \n    return result; // Return the final Roman numeral string\n}\n"}
{"task_id": "CPP/157", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to identify the longest side\n    float sides[3] = {a, b, c};\n    sort(sides, sides + 3);\n    \n    // Check the Pythagorean theorem\n    return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);\n}\n"}
{"task_id": "CPP/158", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string maxWord = \"\";\n    int maxUniqueCount = 0;\n\n    for (const string& word : words) {\n        unordered_set<char> uniqueChars(word.begin(), word.end());\n        int uniqueCount = uniqueChars.size();\n\n        if (uniqueCount > maxUniqueCount || \n           (uniqueCount == maxUniqueCount && word < maxWord)) {\n            maxUniqueCount = uniqueCount;\n            maxWord = word;\n        }\n    }\n\n    return maxWord;\n}\n"}
{"task_id": "CPP/159", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int totalEaten = number;\n    int toEat = min(need, remaining); // Calculate how many more carrots to eat\n    totalEaten += toEat; // Update total eaten carrots\n    int remainingAfterEat = remaining - toEat; // Calculate remaining carrots after eating\n\n    return {totalEaten, remainingAfterEat}; // Return the result as a vector\n}\n"}
{"task_id": "CPP/160", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stdlib.h>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    int result = operand[0]; // Start with the first operand\n\n    // Iterate through the operators and operands\n    for (size_t i = 0; i < operato.size(); i++) {\n        string op = operato[i];\n        int num = operand[i + 1]; // The next operand\n\n        if (op == \"+\") {\n            result += num;\n        } else if (op == \"-\") {\n            result -= num;\n        } else if (op == \"*\") {\n            result *= num;\n        } else if (op == \"//\") {\n            if (num != 0) { // Avoid division by zero\n                result /= num;\n            } else {\n                throw invalid_argument(\"Division by zero is not allowed.\");\n            }\n        } else if (op == \"**\") {\n            result = pow(result, num); // Exponentiation\n        } else {\n            throw invalid_argument(\"Invalid operator.\");\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetter = false;\n    \n    // Check if there are any letters in the string\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n    \n    if (hasLetter) {\n        // Reverse case for letters\n        for (char &c : s) {\n            if (isalpha(c)) {\n                c = islower(c) ? toupper(c) : tolower(c);\n            }\n        }\n    } else {\n        // Reverse the string if no letters are present\n        reverse(s.begin(), s.end());\n    }\n    \n    return s;\n}\n"}
{"task_id": "CPP/162", "generation": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\"; // Return None as an empty string\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    char md5String[33];\n    for (int i = 0; i < 16; i++) {\n        snprintf(&md5String[i * 2], 3, \"%02x\", (unsigned int)digest[i]);\n    }\n\n    return string(md5String);\n}\n"}
{"task_id": "CPP/163", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> even_digits = {0, 2, 4, 6, 8}; // List of even digits\n    vector<int> result;\n\n    // Determine the range\n    int start = min(a, b);\n    int end = max(a, b);\n\n    // Collect even digits within the specified range\n    for (int digit : even_digits) {\n        if (digit >= start && digit <= end) {\n            result.push_back(digit);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/0", "generation": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    for (int i = 0; i < numbers.size(); i++) {\n        for (int j = i + 1; j < numbers.size(); j++) {\n            if (abs(numbers[i] - numbers[j]) < threshold) {\n                return true; // Found two numbers closer than the threshold\n            }\n        }\n    }\n    return false; // No such pair found\n}\n"}
{"task_id": "CPP/1", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    // Remove spaces from the input string\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n\n    for (char ch : paren_string) {\n        if (ch == '(') {\n            if (balance == 0 && !current_group.empty()) {\n                result.push_back(current_group);\n                current_group.clear();\n            }\n            current_group += ch;\n            balance++;\n        } else if (ch == ')') {\n            current_group += ch;\n            balance--;\n            if (balance == 0) {\n                result.push_back(current_group);\n                current_group.clear();\n            }\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat truncate_number(float number) {\n    int integerPart = static_cast<int>(number); // Get the integer part\n    float decimalPart = number - integerPart; // Calculate the decimal part\n    return decimalPart; // Return the decimal part\n}\n"}
{"task_id": "CPP/3", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with zero balance\n    for (int operation : operations) {\n        balance += operation; // Update balance with each operation\n        if (balance < 0) { // Check if balance falls below zero\n            return true; // Return true if it does\n        }\n    }\n    return false; // Return false if balance never falls below zero\n}\n"}
{"task_id": "CPP/4", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    float sum = 0.0;\n    int n = numbers.size();\n\n    // Calculate the mean\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / n;\n\n    // Calculate the Mean Absolute Deviation\n    float mad_sum = 0.0;\n    for (float num : numbers) {\n        mad_sum += fabs(num - mean);\n    }\n    \n    return mad_sum / n; // Return the average of absolute deviations\n}\n"}
{"task_id": "CPP/5", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) { // Avoid adding delimiter after the last element\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    string::size_type start = 0, end;\n    \n    while ((end = paren_string.find(' ', start)) != string::npos) {\n        string group = paren_string.substr(start, end - start);\n        int max_depth = 0, current_depth = 0;\n\n        for (char ch : group) {\n            if (ch == '(') {\n                current_depth++;\n                max_depth = max(max_depth, current_depth);\n            } else if (ch == ')') {\n                current_depth--;\n            }\n        }\n\n        result.push_back(max_depth);\n        start = end + 1;\n    }\n\n    // Handle the last group after the last space\n    string group = paren_string.substr(start);\n    int max_depth = 0, current_depth = 0;\n\n    for (char ch : group) {\n        if (ch == '(') {\n            current_depth++;\n            max_depth = max(max_depth, current_depth);\n        } else if (ch == ')') {\n            current_depth--;\n        }\n    }\n\n    result.push_back(max_depth);\n    \n    return result;\n}\n"}
{"task_id": "CPP/7", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filteredStrings;\n    for (const string& str : strings) {\n        if (str.find(substring) != string::npos) {\n            filteredStrings.push_back(str);\n        }\n    }\n    return filteredStrings;\n}\n"}
{"task_id": "CPP/8", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // If the vector is empty, return (0, 1)\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    // Calculate sum and product\n    for (int num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return {sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> result;\n    int current_max = INT_MIN; // Initialize current_max to the smallest integer\n\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num; // Update current_max if the current number is greater\n        }\n        result.push_back(current_max); // Add the current maximum to the result\n    }\n\n    return result; // Return the vector of rolling maximums\n}\n"}
{"task_id": "CPP/10", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome(\"\") \n    \"\" \n    >>> make_palindrome(\"cat\") \n    \"catac\" \n    >>> make_palindrome(\"cata\") \n    \"catac\" \n    */\n    \n    int n = str.length();\n    for (int i = n; i >= 0; --i) {\n        // Check if the substring from i to the end is a palindrome\n        if (is_palindrome(str.substr(i))) {\n            // If it is, append the reverse of the prefix before this palindrome\n            string prefix = str.substr(0, i);\n            string reversed_prefix(prefix.rbegin(), prefix.rend());\n            return str + reversed_prefix;\n        }\n    }\n    return str; // In case the input is already a palindrome\n}\n"}
{"task_id": "CPP/11", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    int length = a.length();\n    \n    // Ensure both strings are of the same length\n    if (b.length() < length) {\n        b.insert(0, length - b.length(), '0'); // Pad with leading zeros\n    } else if (a.length() < b.length()) {\n        a.insert(0, b.length() - a.length(), '0'); // Pad with leading zeros\n    }\n\n    // Perform XOR operation\n    for (int i = 0; i < a.length(); i++) {\n        result += (a[i] == b[i]) ? '0' : '1'; // XOR logic\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"None\"; // Return \"None\" for an empty vector\n    }\n    \n    string longestString = strings[0]; // Initialize with the first string\n    for (const string& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str; // Update if a longer string is found\n        }\n    }\n    \n    return longestString; // Return the longest string found\n}\n"}
{"task_id": "CPP/13", "generation": "#include<stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (int i = 1; i <= str.length(); i++) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss;\n    for (int i = 0; i <= n; i++) {\n        ss << i;\n        if (i < n) {\n            ss << \" \"; // Add space only if it's not the last number\n        }\n    }\n    return ss.str();\n}\n"}
{"task_id": "CPP/16", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    set<char> distinctChars; // Using a set to store distinct characters\n    for (char c : str) {\n        distinctChars.insert(tolower(c)); // Convert to lowercase and insert into the set\n    }\n    return distinctChars.size(); // The size of the set is the number of distinct characters\n}\n"}
{"task_id": "CPP/17", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    stringstream ss(music_string);\n    string note;\n\n    while (ss >> note) {\n        if (note == \"o\") {\n            beats.push_back(4); // whole note\n        } else if (note == \"o|\") {\n            beats.push_back(2); // half note\n        } else if (note == \".|\") {\n            beats.push_back(1); // quarter note\n        }\n    }\n\n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (substring.empty()) return 0; // If the substring is empty, return 0\n    int count = 0;\n    size_t pos = 0;\n\n    // Loop to find all occurrences of the substring\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++; // Increment count for each found occurrence\n        pos++; // Move to the next character to allow overlapping matches\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<vector>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Map to convert string numbers to their corresponding integer values\n    map<string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Split the input string into words\n    stringstream ss(numbers);\n    vector<string> num_words;\n    string word;\n\n    while (ss >> word) {\n        num_words.push_back(word);\n    }\n\n    // Sort the words based on their corresponding integer values\n    sort(num_words.begin(), num_words.end(), [&](const string &a, const string &b) {\n        return num_map[a] < num_map[b];\n    });\n\n    // Join the sorted words into a single string\n    string result;\n    for (const string &num : num_words) {\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += num;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/20", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Sort the numbers to make it easier to find the closest pair\n    sort(numbers.begin(), numbers.end());\n    \n    // Initialize the minimum difference and the pair of closest elements\n    float minDiff = FLT_MAX;\n    vector<float> closestPair;\n\n    // Iterate through the sorted numbers to find the closest pair\n    for (size_t i = 0; i < numbers.size() - 1; i++) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < minDiff) {\n            minDiff = diff;\n            closestPair = {numbers[i], numbers[i + 1]};\n        }\n    }\n\n    return closestPair;\n}\n"}
{"task_id": "CPP/21", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    float minVal = *min_element(numbers.begin(), numbers.end());\n    float maxVal = *max_element(numbers.begin(), numbers.end());\n    \n    vector<float> scaledNumbers;\n    for (float num : numbers) {\n        float scaledValue = (num - minVal) / (maxVal - minVal);\n        scaledNumbers.push_back(scaledValue);\n    }\n    \n    return scaledNumbers;\n}\n"}
{"task_id": "CPP/22", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\n#include <boost/any.hpp>\n#include <list>\n#include <typeinfo>\n\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> integers;\n    \n    for (const auto& value : values) {\n        // Check if the value is of type int\n        if (value.type() == typeid(int)) {\n            // Extract the integer and add it to the vector\n            integers.push_back(boost::any_cast<int>(value));\n        }\n    }\n    \n    return integers;\n}\n"}
{"task_id": "CPP/23", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint strlen(string str) {\n    int length = 0;\n    for (char c : str) {\n        length++;\n    }\n    return length;\n}\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; i--) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1; // In case n is 1, the largest divisor is 1 itself.\n}\n"}
{"task_id": "CPP/25", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> countMap;\n    // Count occurrences of each number\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n    \n    vector<int> result;\n    // Add numbers that occur only once to the result\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) {\n        if (isupper(c)) {\n            c = tolower(c);\n        } else if (islower(c)) {\n            c = toupper(c);\n        }\n    }\n    return str;\n}\n"}
{"task_id": "CPP/28", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result;\n    for (const string& str : strings) {\n        result += str; // Append each string to the result\n    }\n    return result; // Return the concatenated string\n}\n"}
{"task_id": "CPP/29", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered;\n    for (const string& str : strings) {\n        if (str.find(prefix) == 0) { // Check if the string starts with the given prefix\n            filtered.push_back(str);\n        }\n    }\n    return filtered;\n}\n"}
{"task_id": "CPP/30", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positives;\n    for (float num : l) {\n        if (num > 0) {\n            positives.push_back(num);\n        }\n    }\n    return positives;\n}\n"}
{"task_id": "CPP/31", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    if (n <= 3) return true;  // 2 and 3 are prime numbers\n\n    // Check for even numbers and multiples of 3\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    // Check for factors from 5 to the square root of n\n    for (long long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    \n    return true; // n is prime\n}\n"}
{"task_id": "CPP/32", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    /* \n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n \n    */\n    double sum = 0;\n    int i;\n    for (i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    /*\n    xs are coefficients of a polynomial. find_zero find x such that poly(x) = 0. find_zero returns only one zero point, even if there are many. \n    Moreover, find_zero only takes list xs having even number of coefficients and largest non zero coefficient as it guarantees a solution.\n    >>> round(find_zero([1, 2]), 2) #f(x) = 1 + 2x \n    -0.5 \n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 \n    1.0\n    */\n    \n    double left = -1000; // Starting point for the search\n    double right = 1000; // Starting point for the search\n    double mid;\n    \n    // Using binary search to find a root\n    while (right - left > 1e-7) { // Precision threshold\n        mid = (left + right) / 2;\n        if (poly(xs, mid) == 0) {\n            return mid; // Found an exact root\n        } else if (poly(xs, mid) * poly(xs, left) < 0) {\n            right = mid; // Root is in the left half\n        } else {\n            left = mid; // Root is in the right half\n        }\n    }\n    \n    return (left + right) / 2; // Return the midpoint as the root\n}\n"}
{"task_id": "CPP/33", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> sorted_third_values;\n    \n    // Collect values at indices divisible by 3\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            sorted_third_values.push_back(l[i]);\n        }\n    }\n    \n    // Sort the collected values\n    sort(sorted_third_values.begin(), sorted_third_values.end());\n    \n    // Replace values in the original list at indices divisible by 3\n    int sorted_index = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l[i] = sorted_third_values[sorted_index++];\n        }\n    }\n    \n    return l;\n}\n"}
{"task_id": "CPP/34", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Use the unique function to remove duplicates\n    auto last = unique(l.begin(), l.end());\n    \n    // Resize the vector to the new size\n    l.erase(last, l.end());\n    \n    return l;\n}\n"}
{"task_id": "CPP/35", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    float maxValue = l[0]; // Initialize maxValue with the first element\n    for (float num : l) {\n        if (num > maxValue) {\n            maxValue = num; // Update maxValue if a larger number is found\n        }\n    }\n    return maxValue; // Return the maximum value found\n}\n"}
{"task_id": "CPP/36", "generation": "#include<stdio.h>\nusing namespace std;\n\nint countDigit7(int number) {\n    int count = 0;\n    while (number > 0) {\n        if (number % 10 == 7) {\n            count++;\n        }\n        number /= 10;\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int totalCount = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            totalCount += countDigit7(i);\n        }\n    }\n    return totalCount;\n}\n"}
{"task_id": "CPP/37", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Create a vector to store the even indexed elements\n    vector<float> even_elements;\n\n    // Extract even indexed elements\n    for (int i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the even indexed elements\n    sort(even_elements.begin(), even_elements.end());\n\n    // Place sorted even indexed elements back into the original vector\n    for (int i = 0; i < even_elements.size(); i++) {\n        l[i * 2] = even_elements[i];\n    }\n\n    return l;\n}\n"}
{"task_id": "CPP/38", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_cyclic(string s){ \n    // returns encoded string by cycling groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    for (int i = 0; i * 3 < l; i++) {\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output = output + x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s){ \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string. \n    */\n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++) {\n        // extract the group of three characters\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            // reverse the cyclic shift\n            output += x[2]; // last character becomes first\n            output += x.substr(0, 2); // first two characters follow\n        } else {\n            // if the group has fewer than 3 characters, just append it as is\n            output += x;\n        }\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <stdio.h>\n#include <vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to return the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    vector<int> fibs = {0, 1}; // Starting Fibonacci numbers\n    int count = 0; // Count of prime Fibonacci numbers\n    int i = 2; // Index for generating Fibonacci numbers\n\n    while (count < n) {\n        // Generate the next Fibonacci number\n        int next_fib = fibs[i - 1] + fibs[i - 2];\n        fibs.push_back(next_fib);\n        \n        // Check if the Fibonacci number is prime\n        if (is_prime(next_fib)) {\n            count++;\n            if (count == n) {\n                return next_fib; // Return the n-th prime Fibonacci number\n            }\n        }\n        i++;\n    }\n    return -1; // In case n is not valid, though it shouldn't happen with valid input\n}\n"}
{"task_id": "CPP/40", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_set>\n#include<algorithm>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false; // Need at least 3 numbers to form a triplet\n\n    // Sort the array to use two-pointer technique\n    sort(l.begin(), l.end());\n\n    for (int i = 0; i < n - 2; i++) {\n        // Skip duplicate elements to avoid counting the same triplet\n        if (i > 0 && l[i] == l[i - 1]) continue;\n\n        int left = i + 1;\n        int right = n - 1;\n\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true; // Found a triplet\n            } else if (sum < 0) {\n                left++; // Move left pointer to increase the sum\n            } else {\n                right--; // Move right pointer to decrease the sum\n            }\n        }\n    }\n    return false; // No triplet found\n}\n"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Each car from the left will collide with each car from the right\n    return n * n; // Total collisions = n (left cars) * n (right cars)\n}\n"}
{"task_id": "CPP/42", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (int i = 0; i < l.size(); i++) {\n        l[i] += 1; // Increment each element by 1\n    }\n    return l; // Return the modified vector\n}\n"}
{"task_id": "CPP/43", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.count(-num)) {\n            return true; // Found a pair that sums to zero\n        }\n        seen.insert(num);\n    }\n    return false; // No pairs found that sum to zero\n}\n"}
{"task_id": "CPP/44", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (base < 2 || base >= 10) {\n        return \"\"; // Invalid base\n    }\n    \n    string result = \"\";\n    \n    // Convert the number to the specified base\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result; // Prepend the remainder\n        x /= base; // Reduce x for the next iteration\n    }\n    \n    return result.empty() ? \"0\" : result; // Handle the case where x is 0\n}\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h; // Area of triangle = 0.5 * base * height\n}\n"}
{"task_id": "CPP/46", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    int fib[n + 1];\n    fib[0] = 0;\n    fib[1] = 0;\n    fib[2] = 2;\n    fib[3] = 0;\n\n    for (int i = 4; i <= n; i++) {\n        fib[i] = fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4];\n    }\n\n    return fib[n];\n}\n"}
{"task_id": "CPP/47", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector to find the median\n    sort(l.begin(), l.end());\n    int n = l.size();\n    \n    // If the size is odd, return the middle element\n    if (n % 2 != 0) {\n        return l[n / 2];\n    } else {\n        // If the size is even, return the average of the two middle elements\n        return (l[(n / 2) - 1] + l[n / 2]) / 2.0;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n"}
{"task_id": "CPP/49", "generation": "#include<stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0) return 1; // 2^0 is 1\n    long long result = 1; // Use long long to handle large numbers\n    long long base = 2; // Base is 2\n\n    // Calculate 2^n % p using modular exponentiation\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p; // If n is odd, multiply base with result\n        }\n        base = (base * base) % p; // Square the base\n        n /= 2; // Divide n by 2\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_shift(string s){\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';   \n        out = out + (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s){\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a'; // Add 26 to handle negative values\n        out = out + (char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        // Check if the character is a vowel (both lowercase and uppercase)\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n            c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            result += c; // Append non-vowel characters to the result\n        }\n    }\n    return result; // Return the string without vowels\n}\n"}
{"task_id": "CPP/52", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false; // Return false if any number is greater than or equal to the threshold\n        }\n    }\n    return true; // Return true if all numbers are below the threshold\n}\n"}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n"}
{"task_id": "CPP/54", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create a set to store unique characters from both strings\n    unordered_set<char> set0(s0.begin(), s0.end());\n    unordered_set<char> set1(s1.begin(), s1.end());\n    \n    // Check if both sets have the same characters\n    return set0 == set1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) return 0; // Fibonacci of 0 is 0\n    if (n == 1) return 1; // Fibonacci of 1 is 1\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; i++) {\n        c = a + b; // Calculate the next Fibonacci number\n        a = b;     // Move to the next number in the sequence\n        b = c;     // Update b to the new Fibonacci number\n    }\n    return b; // Return the n-th Fibonacci number\n}\n"}
{"task_id": "CPP/56", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // To keep track of the balance of brackets\n    for (char ch : brackets) {\n        if (ch == '<') {\n            balance++; // Increment for opening bracket\n        } else if (ch == '>') {\n            balance--; // Decrement for closing bracket\n        }\n        // If balance goes negative, it means there's a closing bracket without a matching opening bracket\n        if (balance < 0) {\n            return false;\n        }\n    }\n    // At the end, balance should be zero for all brackets to be matched\n    return balance == 0;\n}\n"}
{"task_id": "CPP/57", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() < 2) return true; // A single element or empty list is considered monotonic\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); i++) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false; // Found an increase, not decreasing\n        } else if (l[i] < l[i - 1]) {\n            increasing = false; // Found a decrease, not increasing\n        }\n    }\n\n    return increasing || decreasing; // Return true if either is true\n}\n"}
{"task_id": "CPP/58", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort both vectors\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    vector<int> result;\n    // Use set_intersection to find common elements\n    set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), back_inserter(result));\n\n    // Remove duplicates by using a set\n    vector<int> unique_result(result.begin(), result.end());\n    unique(unique_result.begin(), unique_result.end());\n\n    return unique_result;\n}\n"}
{"task_id": "CPP/59", "generation": "#include<stdio.h>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int largest = -1;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        largest = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest = i;\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        largest = n;\n    }\n\n    return largest;\n}\n"}
{"task_id": "CPP/60", "generation": "#include<stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2; // Using the formula for the sum of the first n natural numbers\n}\n"}
{"task_id": "CPP/61", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // To keep track of the balance of brackets\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++; // Increment for opening bracket\n        } else if (ch == ')') {\n            balance--; // Decrement for closing bracket\n        }\n        // If balance goes negative, it means there's a closing bracket without a matching opening bracket\n        if (balance < 0) {\n            return false;\n        }\n    }\n    // At the end, balance should be zero for all brackets to be matched\n    return balance == 0;\n}\n"}
{"task_id": "CPP/62", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    int degree = xs.size();\n\n    for (int i = 1; i < degree; i++) {\n        result.push_back(xs[i] * i);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 1;\n\n    int a = 0, b = 0, c = 1; // fibfib(0), fibfib(1), fibfib(2)\n    int result = 0;\n\n    for (int i = 3; i <= n; i++) {\n        result = a + b + c; // fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n        a = b; // Update fibfib(n-3)\n        b = c; // Update fibfib(n-2)\n        c = result; // Update fibfib(n-1)\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/64", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    // Convert the string to lowercase to handle case insensitivity\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n    \n    // Check for vowels in the string\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {\n            count++;\n        }\n        // Check if 'y' is at the end of the string\n        if (i == s.length() - 1 && s[i] == 'y') {\n            count++;\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string numStr = to_string(x);\n    int len = numStr.length();\n    \n    // If shift is greater than the number of digits, reverse the string\n    if (shift >= len) {\n        reverse(numStr.begin(), numStr.end());\n        return numStr;\n    }\n    \n    // Perform the circular shift\n    string shifted = numStr.substr(len - shift) + numStr.substr(0, len - shift);\n    return shifted;\n}\n"}
{"task_id": "CPP/66", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/67", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0, oranges = 0;\n    stringstream ss(s);\n    string word;\n\n    // Parse the string to find the number of apples and oranges\n    while (ss >> word) {\n        if (word == \"apples\") {\n            ss >> apples; // Get the number before \"apples\"\n        } else if (word == \"oranges\") {\n            ss >> oranges; // Get the number before \"oranges\"\n        }\n    }\n\n    // Calculate the number of mangoes\n    return n - apples - oranges;\n}\n"}
{"task_id": "CPP/68", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    vector<int> result; // To store the result {smallest_value, its index}\n    int smallest_even_value = -1; // Initialize to -1 to indicate no even value found\n    int smallest_index = -1; // To track the index of the smallest even value\n\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            if (smallest_even_value == -1 || arr[i] < smallest_even_value) {\n                smallest_even_value = arr[i]; // Update smallest even value\n                smallest_index = i; // Update index\n            }\n        }\n    }\n\n    // If we found an even value, return it with its index\n    if (smallest_even_value != -1) {\n        result.push_back(smallest_even_value);\n        result.push_back(smallest_index);\n    }\n\n    return result; // Return the result, which will be empty if no even value was found\n}\n"}
{"task_id": "CPP/69", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_map>\n#include<algorithm>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequencyMap;\n    \n    // Count the frequency of each integer in the vector\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n    \n    int result = -1;\n    \n    // Check for the greatest integer that meets the condition\n    for (const auto& pair : frequencyMap) {\n        int num = pair.first;\n        int freq = pair.second;\n        if (num <= freq) {\n            result = max(result, num);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/70", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    vector<int> result;\n    if (lst.empty()) {\n        return result; // Return empty vector if input is empty\n    }\n\n    sort(lst.begin(), lst.end()); // Sort the list first\n\n    int left = 0; // Pointer for the minimum values\n    int right = lst.size() - 1; // Pointer for the maximum values\n\n    // Alternate between the smallest and largest remaining elements\n    while (left <= right) {\n        if (left == right) {\n            result.push_back(lst[left]); // If both pointers meet, add the last element\n        } else {\n            result.push_back(lst[left]); // Add the minimum\n            result.push_back(lst[right]); // Add the maximum\n        }\n        left++;\n        right--;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b > c && a + c > b && b + c > a) {\n        // Calculate the semi-perimeter\n        float s = (a + b + c) / 2;\n        // Calculate the area using Heron's formula\n        float area = sqrt(s * (s - a) * (s - b) * (s - c));\n        // Return the area rounded to 2 decimal points\n        return round(area * 100) / 100;\n    } else {\n        // Return -1 if the sides do not form a valid triangle\n        return -1;\n    }\n}\n"}
{"task_id": "CPP/72", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is palindromic\n    int n = q.size();\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) {\n            return false; // Not balanced\n        }\n    }\n    \n    // Calculate the sum of the elements\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    \n    // Check if the sum is less than or equal to the maximum weight\n    return sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int changes = 0;\n    int n = arr.size();\n    \n    // Compare elements from the start and end towards the center\n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++; // Increment changes needed for each mismatch\n        }\n    }\n    \n    return changes; // Return the total number of changes needed\n}\n"}
{"task_id": "CPP/74", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int totalChars1 = 0;\n    int totalChars2 = 0;\n\n    // Calculate total number of characters in lst1\n    for (const string& str : lst1) {\n        totalChars1 += str.size();\n    }\n\n    // Calculate total number of characters in lst2\n    for (const string& str : lst2) {\n        totalChars2 += str.size();\n    }\n\n    // Compare the total characters and return the appropriate vector\n    if (totalChars1 < totalChars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nbool is_multiply_prime(int a) {\n    vector<int> primes;\n    for (int i = 2; i < 100; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n\n    for (int i = 0; i < primes.size(); i++) {\n        for (int j = i; j < primes.size(); j++) {\n            for (int k = j; k < primes.size(); k++) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/76", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n <= 1) {\n        return false; // n must be greater than 1 for it to be a base of a power\n    }\n    if (x < 1) {\n        return false; // x must be at least 1 to be a power of n\n    }\n    \n    // Calculate the power of n until it exceeds x\n    int power = 1; // Start with n^0\n    while (power < x) {\n        power *= n; // Multiply by n to get the next power\n    }\n    \n    return power == x; // Check if we found the exact power\n}\n"}
{"task_id": "CPP/77", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool iscube(int a) {\n    // Calculate the cube root of the absolute value of a\n    int cubeRoot = round(cbrt(abs(a)));\n    // Check if the cube of the calculated root equals the absolute value of a\n    return (cubeRoot * cubeRoot * cubeRoot == abs(a));\n}\n"}
{"task_id": "CPP/78", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint hex_key(string num) {\n    int count = 0;\n    // Set of prime hexadecimal digits\n    const string primeHexDigits = \"2357BD\"; // B (11) and D (13) are included\n\n    for (char digit : num) {\n        if (primeHexDigits.find(digit) != string::npos) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    string binary = \"db\"; // Start with \"db\"\n    \n    if (decimal == 0) {\n        binary += \"0\"; // Handle the case for 0\n    } else {\n        while (decimal > 0) {\n            binary += (decimal % 2 == 0) ? '0' : '1'; // Append '0' or '1'\n            decimal /= 2; // Divide by 2 to shift right\n        }\n        reverse(binary.begin() + 2, binary.end()); // Reverse the binary string (excluding \"db\")\n    }\n    \n    binary += \"db\"; // End with \"db\"\n    return binary;\n}\n"}
{"task_id": "CPP/80", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n    \n    // Iterate through the string and check every 3 consecutive characters\n    for (int i = 0; i <= s.length() - 3; i++) {\n        // Check if the three consecutive characters are distinct\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    \n    // If all checks passed, the string is happy\n    return true;\n}\n"}
{"task_id": "CPP/81", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letterGrades;\n    \n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letterGrades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letterGrades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letterGrades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letterGrades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letterGrades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letterGrades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letterGrades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letterGrades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letterGrades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letterGrades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letterGrades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letterGrades.push_back(\"D-\");\n        } else {\n            letterGrades.push_back(\"E\");\n        }\n    }\n    \n    return letterGrades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\nbool prime_length(string str) {\n    int length = str.length();\n    return is_prime(length);\n}\n"}
{"task_id": "CPP/83", "generation": "#include<stdio.h>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n <= 0) return 0; // Invalid input case\n\n    // Count of n-digit numbers that start with 1\n    int start_with_one = 1; // Only one way to start with 1, which is '1' followed by (n-1) digits\n    if (n > 1) {\n        start_with_one *= 10 * (n - 1); // 10 choices for each of the remaining (n-1) digits\n    }\n\n    // Count of n-digit numbers that end with 1\n    int end_with_one = 9; // 9 choices for the first digit (2-9) and 10 choices for (n-2) digits\n    if (n > 1) {\n        end_with_one *= 10 * (n - 2); // 10 choices for each of the remaining (n-2) digits\n    }\n\n    // If n = 1, the number '1' is counted in both cases, so we need to adjust for that\n    if (n == 1) {\n        return start_with_one; // Only '1' is valid\n    }\n\n    // Total count of n-digit numbers that start or end with 1\n    return start_with_one + end_with_one - 1; // Subtract 1 to avoid double counting '1'\n}\n"}
{"task_id": "CPP/84", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    \n    // Calculate the sum of digits\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to sum\n        N /= 10;       // Remove the last digit\n    }\n    \n    // Convert the sum to binary\n    string binary = \"\";\n    if (sum == 0) {\n        binary = \"0\"; // Handle the case where sum is 0\n    } else {\n        while (sum > 0) {\n            binary = to_string(sum % 2) + binary; // Prepend the binary digit\n            sum /= 2; // Divide sum by 2\n        }\n    }\n    \n    return binary;\n}\n"}
{"task_id": "CPP/85", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2 to get odd indices\n        if (lst[i] % 2 == 0) { // Check if the element at the odd index is even\n            sum += lst[i]; // Add to sum if it is even\n        }\n    }\n    return sum; // Return the total sum of even elements at odd indices\n}\n"}
{"task_id": "CPP/86", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result = \"\";\n    string word = \"\";\n    \n    for (char c : s) {\n        if (c == ' ') {\n            // If we encounter a space, sort the current word and add it to the result\n            if (!word.empty()) {\n                sort(word.begin(), word.end());\n                result += word + ' ';\n                word = \"\"; // Reset the word\n            }\n            result += ' '; // Keep the space in the result\n        } else {\n            word += c; // Build the current word\n        }\n    }\n    \n    // Sort the last word if it exists\n    if (!word.empty()) {\n        sort(word.begin(), word.end());\n        result += word;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/87", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n\n    // Iterate through each row of the nested vector\n    for (int i = 0; i < lst.size(); i++) {\n        for (int j = 0; j < lst[i].size(); j++) {\n            // If the current element matches x, store its coordinates\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j});\n            }\n        }\n    }\n\n    // Sort coordinates by row (ascending) and then by column (descending)\n    sort(coordinates.begin(), coordinates.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort by column in descending order\n        }\n        return a[0] < b[0]; // Sort by row in ascending order\n    });\n\n    return coordinates;\n}\n"}
{"task_id": "CPP/88", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the array is empty or has only one element\n    if (array.size() <= 1) {\n        return array; // Return the array as is\n    }\n\n    // Calculate the sum of the first and last elements\n    int sum = array[0] + array[array.size() - 1];\n\n    // Sort the array based on the sum being odd or even\n    if (sum % 2 == 0) {\n        // Even sum: sort in descending order\n        sort(array.begin(), array.end(), greater<int>());\n    } else {\n        // Odd sum: sort in ascending order\n        sort(array.begin(), array.end());\n    }\n\n    return array; // Return the sorted array\n}\n"}
{"task_id": "CPP/89", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string encrypted = \"\";\n    for (char c : s) {\n        // Check if the character is a lowercase letter\n        if (c >= 'a' && c <= 'z') {\n            // Rotate the letter by 2 positions down the alphabet\n            char newChar = (c - 'a' + 2 * 2) % 26 + 'a';\n            encrypted += newChar;\n        } else {\n            // If it's not a lowercase letter, just append it as is\n            encrypted += c;\n        }\n    }\n    return encrypted;\n}\n"}
{"task_id": "CPP/90", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    // Remove duplicates by using a set\n    set<int> unique_elements(lst.begin(), lst.end());\n    \n    // If there are less than 2 unique elements, return None\n    if (unique_elements.size() < 2) {\n        return -1; // Using -1 to indicate None as per C++ convention\n    }\n    \n    // Convert the set back to a vector and sort it\n    vector<int> sorted_unique(unique_elements.begin(), unique_elements.end());\n    \n    // Return the second smallest element\n    return sorted_unique[1];\n}\n"}
{"task_id": "CPP/91", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nint is_bored(string S) {\n    int boredomCount = 0;\n    stringstream ss(S);\n    string sentence;\n\n    // Split the string into sentences based on delimiters\n    while (getline(ss, sentence, '.')) {\n        if (sentence.empty()) continue; // Skip empty sentences\n        if (sentence.back() == '?') {\n            sentence.pop_back();\n        }\n        if (sentence.back() == '!') {\n            sentence.pop_back();\n        }\n\n        // Trim leading whitespace\n        while (!sentence.empty() && isspace(sentence[0])) {\n            sentence.erase(sentence.begin());\n        }\n\n        // Check if the sentence starts with \"I\"\n        if (sentence.rfind(\"I \", 0) == 0 || sentence == \"I\") {\n            boredomCount++;\n        }\n    }\n\n    return boredomCount;\n}\n"}
{"task_id": "CPP/92", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n    \n    // Check if one number is equal to the sum of the other two\n    return (a == b + c) || (b == a + c) || (c == a + b);\n}\n"}
{"task_id": "CPP/93", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    string result = \"\";\n    for (char c : message) {\n        // Swap case\n        if (isalpha(c)) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n            // Replace vowels\n            if (c == 'A' || c == 'a') {\n                c = 'C'; // A -> C\n            } else if (c == 'E' || c == 'e') {\n                c = 'G'; // E -> G\n            } else if (c == 'I' || c == 'i') {\n                c = 'K'; // I -> K\n            } else if (c == 'O' || c == 'o') {\n                c = 'Q'; // O -> Q\n            } else if (c == 'U' || c == 'u') {\n                c = 'W'; // U -> W\n            }\n        }\n        result += c;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n\n"}
{"task_id": "CPP/95", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<cctype> // for islower and isupper\nusing namespace std;\n\nbool check_dict_case(map<string,string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n    \n    // Iterate through each key in the map\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        // Check if the key is not a string (this should not happen since the map is of type <string, string>)\n        // Check if the key contains any non-alphabetic characters\n        if (!std::all_of(key.begin(), key.end(), [](unsigned char c) { return std::isalpha(c); })) {\n            return false;\n        }\n\n        // Check if the key is either all lower case or all upper case\n        if (!(std::islower(key[0]) && std::all_of(key.begin(), key.end(), ::islower)) &&\n            !(std::isupper(key[0]) && std::all_of(key.begin(), key.end(), ::isupper))) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/96", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool isPrime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        if (isPrime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the unit digit of both numbers\n    int unitDigitA = abs(a) % 10; // Use abs to handle negative numbers\n    int unitDigitB = abs(b) % 10; // Use abs to handle negative numbers\n    \n    // Return the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n"}
{"task_id": "CPP/98", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    for (int i = 0; i < s.length(); i += 2) { // Iterate through even indices\n        if (s[i] >= 'A' && s[i] <= 'Z') { // Check if the character is an uppercase vowel\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/99", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nint closest_integer(string value) {\n    double num = stod(value); // Convert string to double\n    int lower = floor(num); // Get the lower integer\n    int upper = ceil(num); // Get the upper integer\n\n    // Check the distance from the number to the lower and upper integers\n    double distanceToLower = abs(num - lower);\n    double distanceToUpper = abs(num - upper);\n\n    // If the distances are equal, round away from zero\n    if (distanceToLower == distanceToUpper) {\n        if (num > 0) {\n            return upper; // Round up for positive numbers\n        } else {\n            return lower; // Round down for negative numbers\n        }\n    }\n\n    // Return the closest integer\n    return (distanceToLower < distanceToUpper) ? lower : upper;\n}\n"}
{"task_id": "CPP/100", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    int currentStones = n;\n\n    for (int i = 0; i < n; i++) {\n        stones.push_back(currentStones);\n        // Determine the next number of stones based on the parity of currentStones\n        if (currentStones % 2 == 0) {\n            currentStones += 2; // next even number\n        } else {\n            currentStones += 2; // next odd number\n        }\n    }\n\n    return stones;\n}\n"}
{"task_id": "CPP/101", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    stringstream ss(s);\n    string word;\n\n    // Replace commas with spaces for easier splitting\n    replace(s.begin(), s.end(), ',', ' ');\n\n    // Split the string by spaces\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    return words;\n}\n"}
{"task_id": "CPP/102", "generation": "#include<stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1;\n    }\n    \n    // If y is even, return y\n    if (y % 2 == 0) {\n        return y;\n    } else {\n        // If y is odd, return y - 1 if it's within the range\n        if (y - 1 >= x) {\n            return y - 1;\n        } else {\n            return -1; // No even number in the range\n        }\n    }\n}\n"}
{"task_id": "CPP/103", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    \n    // Calculate the sum of integers from n to m\n    int sum = 0;\n    for (int i = n; i <= m; i++) {\n        sum += i;\n    }\n    \n    // Calculate the number of integers from n to m\n    int count = m - n + 1;\n    \n    // Calculate the average and round it down\n    int average = sum / count;\n    \n    // Convert the average to binary\n    string binary = \"\";\n    while (average > 0) {\n        binary = to_string(average % 2) + binary;\n        average /= 2;\n    }\n    \n    return binary.empty() ? \"0\" : binary; // Handle the case when average is 0\n}\n"}
{"task_id": "CPP/104", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool hasEvenDigit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true; // Found an even digit\n        }\n        num /= 10;\n    }\n    return false; // No even digits found\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    sort(result.begin(), result.end()); // Sort the result in increasing order\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Create a map to convert numbers to their corresponding names\n    map<int, string> numToName = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n\n    // Filter the array to include only numbers between 1 and 9\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n\n    // Sort the filtered array\n    sort(filtered.begin(), filtered.end());\n\n    // Reverse the sorted array\n    reverse(filtered.begin(), filtered.end());\n\n    // Create the result vector to hold the names\n    vector<string> result;\n    for (int num : filtered) {\n        result.push_back(numToName[num]);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            // Calculate factorial for even index\n            int factorial = 1;\n            for (int j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else {\n            // Calculate sum from 1 to i for odd index\n            result[i - 1] = (i * (i + 1)) / 2; // Sum of first i natural numbers\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; i++) {\n        string num_str = to_string(i);\n        string reversed_str = string(num_str.rbegin(), num_str.rend());\n\n        if (num_str == reversed_str) { // Check if the number is a palindrome\n            if (i % 2 == 0) {\n                even_count++; // Increment even count\n            } else {\n                odd_count++; // Increment odd count\n            }\n        }\n    }\n\n    return {even_count, odd_count}; // Return the counts in a vector\n}\n"}
{"task_id": "CPP/108", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    while (num != 0) {\n        sum += num % 10; // Add the last digit\n        num /= 10; // Remove the last digit\n    }\n    return sum;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(abs(num)) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true; // An empty vector is considered sorted.\n\n    int n = arr.size();\n    int count = 0; // Count the number of times the order is broken.\n\n    for (int i = 0; i < n; i++) {\n        // Check if the current element is greater than the next element (considering wrap-around).\n        if (arr[i] > arr[(i + 1) % n]) {\n            count++;\n        }\n    }\n\n    // If there is more than one point where the order is broken, we cannot sort it with shifts.\n    return count <= 1;\n}\n"}
{"task_id": "CPP/110", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    bool hasEvenInLst2 = false;\n    bool hasOddInLst1 = false;\n\n    // Check lst1 for odd numbers and lst2 for even numbers\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            hasOddInLst1 = true; // lst1 has at least one odd number\n            break;\n        }\n    }\n\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            hasEvenInLst2 = true; // lst2 has at least one even number\n            break;\n        }\n    }\n\n    // If lst1 has odd numbers and lst2 has even numbers, we can exchange\n    if (hasOddInLst1 && hasEvenInLst2) {\n        return \"YES\";\n    }\n\n    // If lst1 is already all even, return \"YES\"\n    if (!hasOddInLst1) {\n        return \"YES\";\n    }\n\n    // Otherwise, return \"NO\"\n    return \"NO\";\n}\n"}
{"task_id": "CPP/111", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nmap<string, int> histogram(string test) {\n    map<string, int> countMap;\n    stringstream ss(test);\n    string word;\n\n    // Count occurrences of each letter\n    while (ss >> word) {\n        countMap[word]++;\n    }\n\n    // Find the maximum occurrence\n    int maxCount = 0;\n    for (const auto& pair : countMap) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Prepare the result map with letters that have the maximum occurrence\n    map<string, int> result;\n    for (const auto& pair : countMap) {\n        if (pair.second == maxCount) {\n            result[pair.first] = pair.second;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/112", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Create a set of characters to delete for faster lookup\n    unordered_set<char> charsToDelete(c.begin(), c.end());\n    \n    // Build the result string by skipping characters in the set\n    string result;\n    for (char ch : s) {\n        if (charsToDelete.find(ch) == charsToDelete.end()) {\n            result += ch;\n        }\n    }\n    \n    // Check if the result string is a palindrome\n    string reversedResult = result;\n    reverse(reversedResult.begin(), reversedResult.end());\n    bool isPalindrome = (result == reversedResult);\n    \n    // Prepare the output vector\n    vector<string> output = {result, isPalindrome ? \"True\" : \"False\"};\n    return output;\n}\n"}
{"task_id": "CPP/113", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (int i = 0; i < lst.size(); i++) {\n        int odd_count = 0;\n        \n        // Count odd digits in the current string\n        for (char c : lst[i]) {\n            if ((c - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n        \n        // Create the output string with the counted odd digits\n        string output = \"the number of odd elements \" + to_string(odd_count) + \n                        \"n the str\" + to_string(i + 1) + \n                        \"ng \" + to_string(i + 1) + \n                        \" of the \" + to_string(i + 1) + \n                        \"nput.\";\n        \n        result.push_back(output);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long minSum = nums[0]; // Initialize minSum with the first element\n    long long currentSum = 0; // Variable to track the current subarray sum\n\n    for (long long num : nums) {\n        currentSum += num; // Add the current number to the current subarray sum\n        if (currentSum < minSum) {\n            minSum = currentSum; // Update minSum if currentSum is smaller\n        }\n        if (currentSum > 0) {\n            currentSum = 0; // Reset currentSum if it becomes positive\n        }\n    }\n\n    return minSum; // Return the minimum subarray sum found\n}\n"}
{"task_id": "CPP/115", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int totalLowerings = 0;\n\n    for (const auto& row : grid) {\n        int waterUnits = 0;\n\n        // Count the number of water units (1s) in the current row\n        for (int cell : row) {\n            waterUnits += cell;\n        }\n\n        // Calculate the number of times we need to lower the bucket for this row\n        if (waterUnits > 0) {\n            totalLowerings += (waterUnits + capacity - 1) / capacity; // Equivalent to ceil(waterUnits / capacity)\n        }\n    }\n\n    return totalLowerings;\n}\n"}
{"task_id": "CPP/116", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> arr) {\n    // Custom comparator for sorting\n    sort(arr.begin(), arr.end(), [](int a, int b) {\n        // Count the number of 1s in the binary representation\n        int countA = __builtin_popcount(a);\n        int countB = __builtin_popcount(b);\n        \n        // First compare by number of 1s, then by value\n        if (countA == countB) {\n            return a < b; // Sort by value if counts are equal\n        }\n        return countA < countB; // Sort by number of 1s\n    });\n    \n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word;\n    \n    // Split the string into words\n    for (char c : s) {\n        if (c == ' ') {\n            if (!word.empty()) {\n                // Count consonants in the word\n                int consonantCount = 0;\n                for (char ch : word) {\n                    if (isalpha(ch) && !strchr(\"aeiouAEIOU\", ch)) {\n                        consonantCount++;\n                    }\n                }\n                // Check if the word has exactly n consonants\n                if (consonantCount == n) {\n                    result.push_back(word);\n                }\n                word.clear(); // Reset word for the next iteration\n            }\n        } else {\n            word += c; // Build the current word\n        }\n    }\n    \n    // Check the last word if there's no trailing space\n    if (!word.empty()) {\n        int consonantCount = 0;\n        for (char ch : word) {\n            if (isalpha(ch) && !strchr(\"aeiouAEIOU\", ch)) {\n                consonantCount++;\n            }\n        }\n        if (consonantCount == n) {\n            result.push_back(word);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    // Define the set of vowels\n    string vowels = \"aeiouAEIOU\";\n    int n = word.length();\n    \n    // Iterate from the end of the word to find the closest vowel\n    for (int i = n - 1; i > 0; i--) {\n        // Check if the current character is a vowel\n        if (vowels.find(word[i]) != string::npos) {\n            // Check if the previous character is a consonant\n            if (i > 0 && vowels.find(word[i - 1]) == string::npos) {\n                // Check if the character before the consonant is also a consonant\n                if (i - 2 >= 0 && vowels.find(word[i - 2]) == string::npos) {\n                    return string(1, word[i]); // Return the vowel found\n                }\n            }\n        }\n    }\n    \n    // If no valid vowel found, return an empty string\n    return \"\";\n}\n"}
{"task_id": "CPP/119", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    // Count the number of open and close parentheses in both strings\n    int open1 = 0, close1 = 0, open2 = 0, close2 = 0;\n\n    for (char c : lst[0]) {\n        if (c == '(') open1++;\n        else close1++;\n    }\n\n    for (char c : lst[1]) {\n        if (c == '(') open2++;\n        else close2++;\n    }\n\n    // Check if we can concatenate in either order\n    // Order 1: lst[0] + lst[1]\n    if (open1 + open2 >= close1 && open1 >= close2) {\n        return \"Yes\";\n    }\n    \n    // Order 2: lst[1] + lst[0]\n    if (open2 + open1 >= close2 && open2 >= close1) {\n        return \"Yes\";\n    }\n\n    return \"No\";\n}\n"}
{"task_id": "CPP/120", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Take the first k elements\n    vector<int> maxElements(arr.begin(), arr.begin() + k);\n    \n    // Sort the selected elements in ascending order\n    sort(maxElements.begin(), maxElements.end());\n    \n    return maxElements;\n}\n"}
{"task_id": "CPP/121", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        // Check if the index is even and the element is odd\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/122", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++) {\n        if (arr[i] >= 10 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    \n    // Generate the Collatz sequence\n    while (n != 1) {\n        if (n % 2 != 0) { // Check if n is odd\n            odd_numbers.push_back(n);\n        }\n        // Apply the Collatz rules\n        if (n % 2 == 0) {\n            n = n / 2; // Even case\n        } else {\n            n = 3 * n + 1; // Odd case\n        }\n    }\n    \n    // Add the last number 1, which is always odd\n    odd_numbers.push_back(1);\n    \n    // Sort the odd numbers in increasing order\n    sort(odd_numbers.begin(), odd_numbers.end());\n    \n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) {\n        return false;\n    }\n\n    // Check if the date is in the correct format (mm-dd-yyyy)\n    if (date[2] != '-' || date[5] != '-') {\n        return false;\n    }\n\n    // Split the date into components\n    int month, day, year;\n    char dash1, dash2;\n    stringstream ss(date);\n    ss >> month >> dash1 >> day >> dash2 >> year;\n\n    // Check if the input was parsed correctly\n    if (ss.fail() || dash1 != '-' || dash2 != '-') {\n        return false;\n    }\n\n    // Validate month\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    // Validate day based on the month\n    if (month == 2) {\n        // Check for leap year\n        bool isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n        if (day < 1 || day > (isLeapYear ? 29 : 28)) {\n            return false;\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        if (day < 1 || day > 30) {\n            return false;\n        }\n    } else {\n        if (day < 1 || day > 31) {\n            return false;\n        }\n    }\n\n    // If all checks pass, the date is valid\n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<sstream>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    // Check for whitespace\n    size_t pos = txt.find_first_of(\" \\t\\n\");\n    if (pos != string::npos) {\n        // Split by whitespace\n        vector<string> words;\n        stringstream ss(txt);\n        string word;\n        while (ss >> word) {\n            words.push_back(word);\n        }\n        return words;\n    }\n\n    // Check for commas\n    pos = txt.find(',');\n    if (pos != string::npos) {\n        // Split by commas\n        vector<string> words;\n        stringstream ss(txt);\n        string word;\n        while (getline(ss, word, ',')) {\n            words.push_back(word);\n        }\n        return words;\n    }\n\n    // If no whitespace or commas, count lowercase letters with odd order\n    int count = 0;\n    for (char c : txt) {\n        if (c >= 'a' && c <= 'z' && (c - 'a') % 2 == 1) {\n            count++;\n        }\n    }\n    return {to_string(count)};\n}\n"}
{"task_id": "CPP/126", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    unordered_map<int, int> countMap;\n    \n    for (int i = 0; i < lst.size(); i++) {\n        // Count occurrences of each number\n        countMap[lst[i]]++;\n        // If any number appears more than twice, return false\n        if (countMap[lst[i]] > 2) {\n            return false;\n        }\n        // Check if the current number is less than the previous number\n        if (i > 0 && lst[i] < lst[i - 1]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    // Calculate the start and end of the intersection\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n    \n    // Calculate the length of the intersection\n    int length = end - start;\n    \n    // Check if the intervals intersect\n    if (length <= 0) {\n        return \"NO\"; // No intersection\n    }\n    \n    // Check if the length of the intersection is a prime number\n    if (isPrime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768; // Return -32768 for empty array\n    }\n    \n    int sum_magnitudes = 0;\n    int product_signs = 1; // Start with neutral sign (1)\n    \n    for (int num : arr) {\n        if (num > 0) {\n            sum_magnitudes += num; // Add magnitude\n        } else if (num < 0) {\n            sum_magnitudes += -num; // Add magnitude\n            product_signs *= -1; // Flip sign for negative numbers\n        } else {\n            product_signs = 0; // If there's a zero, product sign becomes zero\n            break; // No need to continue if zero is found\n        }\n    }\n    \n    return sum_magnitudes * product_signs; // Return the final result\n}\n"}
{"task_id": "CPP/129", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nvoid dfs(const vector<vector<int>>& grid, int x, int y, int k, vector<int>& currentPath, vector<int>& bestPath) {\n    // If we have reached the desired path length\n    if (currentPath.size() == k) {\n        // Compare with the best path found so far\n        if (bestPath.empty() || currentPath < bestPath) {\n            bestPath = currentPath;\n        }\n        return;\n    }\n\n    // Directions for moving in the grid (up, down, left, right)\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    // Explore all neighboring cells\n    for (const auto& dir : directions) {\n        int newX = x + dir.first;\n        int newY = y + dir.second;\n\n        // Check if the new position is within the grid bounds\n        if (newX >= 0 && newX < grid.size() && newY >= 0 && newY < grid[0].size()) {\n            currentPath.push_back(grid[newX][newY]);\n            dfs(grid, newX, newY, k, currentPath, bestPath);\n            currentPath.pop_back(); // Backtrack\n        }\n    }\n}\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    vector<int> bestPath;\n    int n = grid.size();\n\n    // Try starting from each cell in the grid\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            vector<int> currentPath = {grid[i][j]};\n            dfs(grid, i, j, k, currentPath, bestPath);\n        }\n    }\n\n    return bestPath;\n}\n"}
{"task_id": "CPP/130", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> tribonacci(n + 1);\n    \n    // Base cases\n    if (n >= 1) tribonacci[1] = 3; // tri(1) = 3\n    if (n >= 2) tribonacci[2] = 2; // tri(2) = 2\n    \n    // Calculate tribonacci values for n >= 3\n    for (int i = 3; i <= n; ++i) {\n        if (i % 2 == 0) {\n            tribonacci[i] = 1 + (i / 2);\n        } else {\n            tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i + 1];\n        }\n    }\n    \n    // Fill in the first element\n    tribonacci[0] = 1; // tri(0) = 1\n    \n    return tribonacci;\n}\n"}
{"task_id": "CPP/131", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOdd = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply the product by the odd digit\n            hasOdd = true; // Mark that we have at least one odd digit\n        }\n        n /= 10; // Remove the last digit\n    }\n\n    return hasOdd ? product : 0; // Return product if there are odd digits, otherwise return 0\n}\n"}
{"task_id": "CPP/132", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int openCount = 0; // Count of open brackets\n    int nestedCount = 0; // Count of nested brackets\n\n    for (char ch : str) {\n        if (ch == '[') {\n            openCount++;\n            // If we have at least one open bracket before this one, we have a nested structure\n            if (openCount > 1) {\n                nestedCount++;\n            }\n        } else if (ch == ']') {\n            if (openCount > 0) {\n                openCount--; // Close one open bracket\n            } else {\n                return false; // More closing brackets than opening\n            }\n        }\n    }\n\n    // We need at least one nested structure and all brackets must be closed\n    return nestedCount > 0 && openCount == 0;\n}\n"}
{"task_id": "CPP/133", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int roundedNum = ceil(num); // Round up to the nearest integer\n        sum += roundedNum * roundedNum; // Add the square of the rounded number to the sum\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/134", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Trim any trailing spaces\n    size_t end = txt.find_last_not_of(' ');\n    if (end == string::npos) {\n        return false; // The string is empty or only contains spaces\n    }\n    \n    // Get the last character\n    char lastChar = txt[end];\n    \n    // Check if the last character is an alphabetical character\n    if (isalpha(lastChar)) {\n        // Check if it's not part of a word (i.e., it should be followed by a space or be the only character)\n        if (end == 0 || txt[end - 1] == ' ') {\n            return true;\n        }\n    }\n    \n    return false;\n}\n"}
{"task_id": "CPP/135", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int largestIndex = -1; // Initialize to -1 to handle the case where no such element exists\n\n    // Iterate through the array starting from the second element\n    for (int i = 1; i < arr.size(); i++) {\n        // Check if the current element is not greater than or equal to the preceding element\n        if (arr[i] < arr[i - 1]) {\n            largestIndex = i; // Update the largest index\n        }\n    }\n\n    return largestIndex; // Return the largest index found, or -1 if none was found\n}\n"}
{"task_id": "CPP/136", "generation": "#include<stdio.h>\n#include<vector>\n#include<limits.h> // For INT_MIN and INT_MAX\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = INT_MIN; // Initialize to the smallest possible integer\n    int smallest_positive = INT_MAX; // Initialize to the largest possible integer\n\n    for (int num : lst) {\n        if (num < 0) {\n            if (num > largest_negative) {\n                largest_negative = num; // Update largest negative\n            }\n        } else if (num > 0) {\n            if (num < smallest_positive) {\n                smallest_positive = num; // Update smallest positive\n            }\n        }\n    }\n\n    // If no negative number was found, set to 0\n    if (largest_negative == INT_MIN) {\n        largest_negative = 0;\n    }\n    \n    // If no positive number was found, set to 0\n    if (smallest_positive == INT_MAX) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n#include <sstream>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Helper function to convert boost::any to double\n    auto to_double = [](boost::any value) -> double {\n        if (value.type() == typeid(int)) {\n            return boost::any_cast<int>(value);\n        } else if (value.type() == typeid(float)) {\n            return boost::any_cast<float>(value);\n        } else if (value.type() == typeid(string)) {\n            string str = boost::any_cast<string>(value);\n            // Replace ',' with '.' for float conversion\n            replace(str.begin(), str.end(), ',', '.');\n            return stod(str);\n        }\n        throw invalid_argument(\"Unsupported type\");\n    };\n\n    // Convert both values to double for comparison\n    double num1 = to_double(a);\n    double num2 = to_double(b);\n\n    // Compare the two numbers\n    if (num1 == num2) {\n        return \"None\";\n    } else {\n        // Return the larger value in its original type\n        if (num1 > num2) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // The minimum sum of 4 positive even numbers is 8 (2 + 2 + 2 + 2).\n    // Therefore, if n is less than 8, it cannot be expressed as the sum of 4 positive even numbers.\n    if (n < 8) {\n        return false;\n    }\n    // If n is even and greater than or equal to 8, it can be expressed as the sum of 4 positive even numbers.\n    return n % 2 == 0;\n}\n"}
{"task_id": "CPP/139", "generation": "#include<stdio.h>\nusing namespace std;\n\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = n; i > 0; i--) {\n        long long factorial = 1;\n        for (int j = 1; j <= i; j++) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/140", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result = \"\";\n    int spaceCount = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            spaceCount++;\n        } else {\n            if (spaceCount > 2) {\n                result += '-';\n            } else if (spaceCount > 0) {\n                result += '_';\n            }\n            result += c;\n            spaceCount = 0; // reset space count after adding a non-space character\n        }\n    }\n\n    // Handle trailing spaces\n    if (spaceCount > 2) {\n        result += '-';\n    } else if (spaceCount > 0) {\n        result += '_';\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include<stdio.h>\n#include<string>\n#include<regex>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check for exactly one dot\n    size_t dotPos = file_name.find('.');\n    if (dotPos == string::npos || file_name.find('.', dotPos + 1) != string::npos) {\n        return \"No\";\n    }\n\n    // Split into name and extension\n    string name = file_name.substr(0, dotPos);\n    string extension = file_name.substr(dotPos + 1);\n\n    // Check if the name is not empty and starts with a letter\n    if (name.empty() || !isalpha(name[0])) {\n        return \"No\";\n    }\n\n    // Check for valid extension\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\") {\n        return \"No\";\n    }\n\n    // Count digits in the name\n    int digitCount = 0;\n    for (char c : name) {\n        if (isdigit(c)) {\n            digitCount++;\n        }\n    }\n\n    // Check for the digit count condition\n    if (digitCount > 3) {\n        return \"No\";\n    }\n\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            // Square the entry if index is a multiple of 3\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            // Cube the entry if index is a multiple of 4 and not a multiple of 3\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            // Add the entry unchanged if index is not a multiple of 3 or 4\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    vector<string> result;\n\n    // Split the sentence into words\n    while (ss >> word) {\n        // Check if the length of the word is prime\n        if (isPrime(word.length())) {\n            result.push_back(word);\n        }\n    }\n\n    // Join the words with a space\n    string output;\n    for (size_t i = 0; i < result.size(); i++) {\n        output += result[i];\n        if (i < result.size() - 1) {\n            output += \" \";\n        }\n    }\n\n    return output;\n}\n"}
{"task_id": "CPP/144", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Split the first fraction x\n    int numX, denX;\n    sscanf(x.c_str(), \"%d/%d\", &numX, &denX);\n    \n    // Split the second fraction n\n    int numN, denN;\n    sscanf(n.c_str(), \"%d/%d\", &numN, &denN);\n    \n    // Calculate the product of the fractions\n    // (numX / denX) * (numN / denN) = (numX * numN) / (denX * denN)\n    int numerator = numX * numN;\n    int denominator = denX * denN;\n    \n    // Check if the result is a whole number\n    return (numerator % denominator == 0);\n}\n"}
{"task_id": "CPP/145", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n// Function to calculate the sum of digits of a number\nint digit_sum(int num) {\n    int sum = 0;\n    // Handle negative numbers by taking the absolute value\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Function to sort the vector based on the sum of digits\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of pairs to store the original index and the number\n    vector<pair<int, int>> indexed_nums;\n    for (int i = 0; i < nums.size(); i++) {\n        indexed_nums.push_back({nums[i], i});\n    }\n\n    // Sort the vector based on the sum of digits and original index\n    sort(indexed_nums.begin(), indexed_nums.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        int sum_a = digit_sum(a.first);\n        int sum_b = digit_sum(b.first);\n        // First compare by digit sum, then by original index\n        if (sum_a == sum_b) {\n            return a.second < b.second;\n        }\n        return sum_a < sum_b;\n    });\n\n    // Extract the sorted numbers from the indexed pairs\n    vector<int> sorted_nums;\n    for (const auto& p : indexed_nums) {\n        sorted_nums.push_back(p.first);\n    }\n    \n    return sorted_nums;\n}\n"}
{"task_id": "CPP/146", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n\n    for (int num : nums) {\n        if (num > 10) {\n            string numStr = to_string(num);\n            char firstDigit = numStr[0];\n            char lastDigit = numStr[numStr.size() - 1];\n\n            if ((firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || firstDigit == '7' || firstDigit == '9') &&\n                (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' || lastDigit == '7' || lastDigit == '9')) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    // Fill the vector a with the given formula\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    int count = 0;\n\n    // Check all combinations of triples (i, j, k) with i < j < k\n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            for (int k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/148", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Check if both planets are valid\n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n    \n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {}; // Return empty vector if either planet is invalid\n    }\n    \n    // Get the indices of the planets\n    int index1 = distance(planets.begin(), it1);\n    int index2 = distance(planets.begin(), it2);\n    \n    // Ensure index1 is less than index2\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Collect planets between planet1 and planet2\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; ++i) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& str) {\n        return str.length() % 2 != 0;\n    }), lst.end());\n    \n    // Sort the remaining strings first by length, then alphabetically\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Sort alphabetically if lengths are equal\n        }\n        return a.length() < b.length(); // Sort by length\n    });\n    \n    return lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\nint x_or_y(int n, int x, int y) {\n    if (isPrime(n)) {\n        return x; // Return x if n is prime\n    } else {\n        return y; // Return y if n is not prime\n    }\n}\n"}
{"task_id": "CPP/151", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    for (float num : lst) {\n        // Check if the number is a non-negative integer and odd\n        if (num >= 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<int>(num) * static_cast<int>(num); // Add the square of the odd number\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/152", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    for (size_t i = 0; i < game.size(); i++) {\n        result.push_back(abs(game[i] - guess[i]));\n    }\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = -1;\n    string strongest_extension = \"\";\n\n    for (const string& ext : extensions) {\n        int CAP = 0, SM = 0;\n        for (char c : ext) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n        int strength = CAP - SM;\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n    \n    return class_name + \".\" + strongest_extension;\n}\n"}
{"task_id": "CPP/154", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Check if b is longer than a, if so, it can't be a substring\n    if (b.length() > a.length()) {\n        return false;\n    }\n    \n    // Create a new string that is the concatenation of b with itself\n    string b_rotated = b + b;\n    \n    // Check if b or any of its rotations is a substring of a\n    return b_rotated.find(a) != string::npos;\n}\n"}
{"task_id": "CPP/155", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    vector<int> count(2, 0); // count[0] for even, count[1] for odd\n    num = abs(num); // Consider absolute value to handle negative numbers\n\n    while (num > 0) {\n        int digit = num % 10; // Get the last digit\n        if (digit % 2 == 0) {\n            count[0]++; // Increment even count\n        } else {\n            count[1]++; // Increment odd count\n        }\n        num /= 10; // Remove the last digit\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/156", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the values and their corresponding Roman numeral representations\n    vector<pair<int, string>> romanNumerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string result = \"\";\n    \n    // Iterate through the romanNumerals vector\n    for (const auto& pair : romanNumerals) {\n        // While the number is greater than or equal to the value\n        while (number >= pair.first) {\n            result += pair.second; // Append the corresponding numeral\n            number -= pair.first;  // Decrease the number\n        }\n    }\n    \n    return result; // Return the final Roman numeral string\n}\n"}
{"task_id": "CPP/157", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to identify the largest side\n    float x = max(a, max(b, c));\n    float y = min(max(a, b), min(max(b, c), max(a, c)));\n    float z = a + b + c - x - y; // The remaining side\n\n    // Check the Pythagorean theorem\n    return (x * x) == (y * y + z * z);\n}\n"}
{"task_id": "CPP/158", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string maxWord = \"\";\n    int maxUniqueCount = 0;\n\n    for (const string& word : words) {\n        unordered_set<char> uniqueChars(word.begin(), word.end());\n        int uniqueCount = uniqueChars.size();\n\n        if (uniqueCount > maxUniqueCount || (uniqueCount == maxUniqueCount && word < maxWord)) {\n            maxUniqueCount = uniqueCount;\n            maxWord = word;\n        }\n    }\n\n    return maxWord;\n}\n"}
{"task_id": "CPP/159", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int totalEaten = number;\n    int carrotsToEat = min(need, remaining);\n    \n    totalEaten += carrotsToEat;\n    int carrotsLeft = remaining - carrotsToEat;\n    \n    return {totalEaten, carrotsLeft};\n}\n"}
{"task_id": "CPP/160", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stdlib.h>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    int result = operand[0]; // Start with the first operand\n\n    for (size_t i = 0; i < operato.size(); i++) {\n        string op = operato[i];\n        int next_operand = operand[i + 1]; // Get the next operand\n\n        if (op == \"+\") {\n            result += next_operand;\n        } else if (op == \"-\") {\n            result -= next_operand;\n        } else if (op == \"*\") {\n            result *= next_operand;\n        } else if (op == \"//\") {\n            if (next_operand != 0) { // Avoid division by zero\n                result /= next_operand;\n            } else {\n                throw invalid_argument(\"Division by zero is not allowed.\");\n            }\n        } else if (op == \"**\") {\n            result = pow(result, next_operand);\n        } else {\n            throw invalid_argument(\"Invalid operator.\");\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetter = false;\n    \n    // Check if there are any letters in the string\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n    \n    if (hasLetter) {\n        // Reverse case for letters\n        for (char &c : s) {\n            if (isalpha(c)) {\n                c = islower(c) ? toupper(c) : tolower(c);\n            }\n        }\n    } else {\n        // Reverse the string if no letters are present\n        reverse(s.begin(), s.end());\n    }\n    \n    return s;\n}\n"}
{"task_id": "CPP/162", "generation": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\"; // Return None as an empty string\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    char md5String[33]; // MD5 produces a 32-character hexadecimal number\n    for (int i = 0; i < 16; i++) {\n        sprintf(&md5String[i * 2], \"%02x\", (unsigned int)digest[i]);\n    }\n\n    return string(md5String);\n}\n"}
{"task_id": "CPP/163", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> even_digits = {0, 2, 4, 6, 8}; // List of even digits\n    vector<int> result;\n\n    // Ensure a is less than or equal to b\n    if (a > b) {\n        swap(a, b);\n    }\n\n    // Iterate through the even digits and check if they are within the range [a, b]\n    for (int digit : even_digits) {\n        if (digit >= a && digit <= b) {\n            result.push_back(digit);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/0", "generation": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    // Sort the numbers to make it easier to find close elements\n    sort(numbers.begin(), numbers.end());\n    \n    // Check the difference between consecutive elements\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] - numbers[i - 1] < threshold) {\n            return true; // Found two elements closer than the threshold\n        }\n    }\n    \n    return false; // No elements found that are closer than the threshold\n}\n"}
{"task_id": "CPP/1", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string currentGroup;\n    int balance = 0;\n\n    // Remove spaces from the input string\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n\n    for (char ch : paren_string) {\n        if (ch == '(') {\n            if (balance == 0 && !currentGroup.empty()) {\n                result.push_back(currentGroup);\n                currentGroup.clear();\n            }\n            currentGroup += ch;\n            balance++;\n        } else if (ch == ')') {\n            currentGroup += ch;\n            balance--;\n        }\n\n        // When we have a complete group\n        if (balance == 0 && !currentGroup.empty()) {\n            result.push_back(currentGroup);\n            currentGroup.clear();\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat truncate_number(float number) {\n    // Get the integer part of the number\n    int integerPart = static_cast<int>(number);\n    // Calculate the decimal part by subtracting the integer part from the original number\n    float decimalPart = number - integerPart;\n    return decimalPart;\n}\n"}
{"task_id": "CPP/3", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with zero balance\n    for (int operation : operations) {\n        balance += operation; // Update balance with each operation\n        if (balance < 0) { // Check if balance falls below zero\n            return true; // Return true if balance is below zero\n        }\n    }\n    return false; // Return false if balance never goes below zero\n}\n"}
{"task_id": "CPP/4", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    float sum = 0.0;\n    int n = numbers.size();\n\n    // Calculate the mean\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / n;\n\n    // Calculate the Mean Absolute Deviation\n    float mad_sum = 0.0;\n    for (float num : numbers) {\n        mad_sum += abs(num - mean);\n    }\n    float mad = mad_sum / n;\n\n    return mad;\n}\n"}
{"task_id": "CPP/5", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) { // Avoid adding delimiter after the last element\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> result;\n    string::size_type start = 0, end;\n\n    while ((end = paren_string.find(' ', start)) != string::npos) {\n        string group = paren_string.substr(start, end - start);\n        int max_depth = 0, current_depth = 0;\n\n        for (char ch : group) {\n            if (ch == '(') {\n                current_depth++;\n                max_depth = max(max_depth, current_depth);\n            } else if (ch == ')') {\n                current_depth--;\n            }\n        }\n\n        result.push_back(max_depth);\n        start = end + 1;\n    }\n\n    // Handle the last group after the last space\n    string group = paren_string.substr(start);\n    int max_depth = 0, current_depth = 0;\n\n    for (char ch : group) {\n        if (ch == '(') {\n            current_depth++;\n            max_depth = max(max_depth, current_depth);\n        } else if (ch == ')') {\n            current_depth--;\n        }\n    }\n\n    result.push_back(max_depth);\n    \n    return result;\n}\n"}
{"task_id": "CPP/7", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> filtered;\n    for (const string& str : strings) {\n        if (str.find(substring) != string::npos) {\n            filtered.push_back(str);\n        }\n    }\n    return filtered;\n}\n"}
{"task_id": "CPP/8", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // If the vector is empty, return (0, 1)\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    // Calculate sum and product\n    for (int number : numbers) {\n        sum += number;\n        product *= number;\n    }\n\n    return {sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> result;\n    int current_max = INT_MIN; // Initialize to the smallest integer\n\n    for (int num : numbers) {\n        current_max = max(current_max, num); // Update the current maximum\n        result.push_back(current_max); // Add the current maximum to the result\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/10", "generation": "#include <stdio.h>\n#include <string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome(\"\") \n    \"\" \n    >>> make_palindrome(\"cat\") \n    \"catac\" \n    >>> make_palindrome(\"cata\") \n    \"catac\" \n    */\n    \n    int n = str.length();\n    // Find the longest palindromic suffix\n    for (int i = n; i >= 0; i--) {\n        if (is_palindrome(str.substr(i))) {\n            // Append the reverse of the prefix before the palindromic suffix\n            return str + string(str.begin(), str.begin() + i);\n        }\n    }\n    return str; // In case the string is already a palindrome\n}\n"}
{"task_id": "CPP/11", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    int length = a.length();\n    \n    // Ensure both strings are of the same length\n    if (a.length() != b.length()) {\n        return \"\"; // or handle error as needed\n    }\n    \n    for (int i = 0; i < length; i++) {\n        // Perform XOR operation: '0' XOR '0' = '0', '1' XOR '1' = '0', '0' XOR '1' = '1', '1' XOR '0' = '1'\n        if (a[i] == b[i]) {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"None\"; // Return \"None\" if the input vector is empty\n    }\n    \n    string longestString = strings[0]; // Initialize with the first string\n    for (const string& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str; // Update longestString if a longer string is found\n        }\n    }\n    \n    return longestString; // Return the longest string found\n}\n"}
{"task_id": "CPP/13", "generation": "#include<stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (int i = 1; i <= str.length(); i++) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        ss << i;\n        if (i < n) {\n            ss << \" \"; // Add space after each number except the last one\n        }\n    }\n    return ss.str(); // Convert the stringstream to a string and return it\n}\n"}
{"task_id": "CPP/16", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    set<char> distinctChars; // Using a set to store distinct characters\n    for (char c : str) {\n        distinctChars.insert(tolower(c)); // Convert to lowercase and insert into the set\n    }\n    return distinctChars.size(); // The size of the set gives the count of distinct characters\n}\n"}
{"task_id": "CPP/17", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    stringstream ss(music_string);\n    string note;\n\n    while (ss >> note) {\n        if (note == \"o\") {\n            beats.push_back(4); // whole note\n        } else if (note == \"o|\") {\n            beats.push_back(2); // half note\n        } else if (note == \".|\") {\n            beats.push_back(1); // quarter note\n        }\n    }\n\n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (substring.empty()) return 0; // If the substring is empty, return 0\n    int count = 0;\n    size_t pos = 0;\n\n    // Search for the substring in the string\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++; // Increment count for each found substring\n        pos++; // Move to the next character to allow overlapping\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/19", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<vector>\n#include<sstream>\n#include<algorithm>\n\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Map to convert string numbers to their corresponding integer values\n    map<string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Split the input string into words\n    stringstream ss(numbers);\n    vector<string> num_words;\n    string word;\n\n    while (ss >> word) {\n        num_words.push_back(word);\n    }\n\n    // Sort the words based on their integer values\n    sort(num_words.begin(), num_words.end(), [&](const string& a, const string& b) {\n        return num_map[a] < num_map[b];\n    });\n\n    // Join the sorted words back into a single string\n    string result;\n    for (const string& num : num_words) {\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += num;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/20", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Sort the numbers to find the closest pairs easily\n    sort(numbers.begin(), numbers.end());\n    \n    // Initialize the minimum difference and the pair of closest elements\n    float minDiff = FLT_MAX;\n    vector<float> closestPair;\n\n    // Iterate through the sorted numbers to find the closest pair\n    for (int i = 0; i < numbers.size() - 1; i++) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < minDiff) {\n            minDiff = diff;\n            closestPair = {numbers[i], numbers[i + 1]};\n        }\n    }\n\n    return closestPair;\n}\n"}
{"task_id": "CPP/21", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    float minVal = *min_element(numbers.begin(), numbers.end());\n    float maxVal = *max_element(numbers.begin(), numbers.end());\n    \n    vector<float> scaledNumbers;\n    for (float num : numbers) {\n        float scaledValue = (num - minVal) / (maxVal - minVal);\n        scaledNumbers.push_back(scaledValue);\n    }\n    \n    return scaledNumbers;\n}\n"}
{"task_id": "CPP/22", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        // Check if the value is of type int\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint strlen(string str) {\n    int length = 0;\n    for (char c : str) {\n        length++;\n    }\n    return length;\n}\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; i--) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1; // In case n is 1, the largest divisor is 1\n}\n"}
{"task_id": "CPP/25", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    // Start checking for factors from 2 to sqrt(n)\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i; // Divide n by the factor\n        }\n    }\n    // If n is still greater than 1, then it is a prime factor\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> countMap;\n    // Count occurrences of each number\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n    \n    vector<int> result;\n    // Collect numbers that occur only once\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) {\n        if (isupper(c)) {\n            c = tolower(c);\n        } else if (islower(c)) {\n            c = toupper(c);\n        }\n    }\n    return str;\n}\n"}
{"task_id": "CPP/28", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result;\n    for (const string& str : strings) {\n        result += str; // Append each string to the result\n    }\n    return result; // Return the concatenated string\n}\n"}
{"task_id": "CPP/29", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered;\n    for (const string& str : strings) {\n        if (str.find(prefix) == 0) { // Check if the string starts with the prefix\n            filtered.push_back(str);\n        }\n    }\n    return filtered;\n}\n"}
{"task_id": "CPP/30", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positives;\n    for (float num : l) {\n        if (num > 0) {\n            positives.push_back(num);\n        }\n    }\n    return positives;\n}\n"}
{"task_id": "CPP/31", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    if (n <= 3) return true; // 2 and 3 are prime numbers\n    if (n % 2 == 0 || n % 3 == 0) return false; // eliminate multiples of 2 and 3\n\n    for (long long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false; // check for factors of the form 6k \u00b1 1\n        }\n    }\n    return true; // if no factors found, n is prime\n}\n"}
{"task_id": "CPP/32", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    /* \n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[2] * x^2 + .... xs[n] * x^n \n    */\n    double sum = 0;\n    int i;\n    for (i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    /*\n    xs are coefficients of a polynomial. find_zero finds x such that poly(x) = 0. find_zero returns only one zero point, even if there are many. \n    Moreover, find_zero only takes list xs having even number of coefficients and largest non zero coefficient as it guarantees a solution.\n    >>> round(find_zero([1, 2]), 2) #f(x) = 1 + 2x \n    -0.5 \n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 \n    1.0\n    */\n    \n    // Using the bisection method to find a root\n    double low = -1000; // Starting lower bound\n    double high = 1000; // Starting upper bound\n    double mid;\n\n    // Ensure that the function changes sign in the interval\n    while (poly(xs, low) * poly(xs, high) > 0) {\n        low -= 1000; // Expand the search range if no sign change is found\n        high += 1000;\n    }\n\n    // Bisection method\n    while (high - low > 1e-7) { // Precision threshold\n        mid = (low + high) / 2;\n        if (poly(xs, mid) == 0) {\n            return mid; // Found exact root\n        } else if (poly(xs, mid) * poly(xs, low) < 0) {\n            high = mid; // Root is in the left half\n        } else {\n            low = mid; // Root is in the right half\n        }\n    }\n\n    return (low + high) / 2; // Return the midpoint as the root\n}\n"}
{"task_id": "CPP/33", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> sortedValues;\n    \n    // Collect values at indices divisible by 3\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            sortedValues.push_back(l[i]);\n        }\n    }\n    \n    // Sort the collected values\n    sort(sortedValues.begin(), sortedValues.end());\n    \n    // Replace the values in the original vector at indices divisible by 3\n    int sortedIndex = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l[i] = sortedValues[sortedIndex++];\n        }\n    }\n    \n    return l;\n}\n"}
{"task_id": "CPP/34", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the vector to bring duplicates together\n    sort(l.begin(), l.end());\n    \n    // Create a new vector to hold unique elements\n    vector<int> uniqueElements;\n    \n    // Use std::unique to remove duplicates and resize the vector\n    auto last = unique(l.begin(), l.end());\n    l.erase(last, l.end());\n    \n    // Return the sorted unique elements\n    return l;\n}\n"}
{"task_id": "CPP/35", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    float maxVal = l[0]; // Initialize maxVal with the first element\n    for (int i = 1; i < l.size(); i++) { // Start from the second element\n        if (l[i] > maxVal) { // If current element is greater than maxVal\n            maxVal = l[i]; // Update maxVal\n        }\n    }\n    return maxVal; // Return the maximum value found\n}\n"}
{"task_id": "CPP/36", "generation": "#include<stdio.h>\nusing namespace std;\n\nint countDigit7(int num) {\n    int count = 0;\n    while (num > 0) {\n        if (num % 10 == 7) {\n            count++;\n        }\n        num /= 10;\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int totalCount = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            totalCount += countDigit7(i);\n        }\n    }\n    return totalCount;\n}\n"}
{"task_id": "CPP/37", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Extract even indexed elements\n    vector<float> even_indices;\n    for (int i = 0; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    \n    // Sort the even indexed elements\n    sort(even_indices.begin(), even_indices.end());\n    \n    // Place sorted even indexed elements back into the original vector\n    for (int i = 0, j = 0; i < l.size(); i += 2, j++) {\n        l[i] = even_indices[j];\n    }\n    \n    return l;\n}\n"}
{"task_id": "CPP/38", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_cyclic(string s){ \n    // returns encoded string by cycling groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l = s.length();\n    int num = (l + 2) / 3;\n    string x, output;\n    int i;\n    for (i = 0; i * 3 < l; i++)\n    {\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        x = s.substr(i * 3, 3);\n        if (x.length() == 3) x = x.substr(1) + x[0];\n        output = output + x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s){ \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string. \n    */\n    int l = s.length();\n    string output;\n    int i;\n    for (i = 0; i * 3 < l; i++)\n    {\n        // split string into groups of three characters\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            // reverse the cycling operation\n            output += x[2]; // last character becomes first\n            output += x.substr(0, 2); // first two characters remain in order\n        } else {\n            output += x; // if less than 3 characters, just append as is\n        }\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\n// Function to find the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    vector<int> fibs = {0, 1}; // Starting Fibonacci numbers\n    int count = 0; // Count of prime Fibonacci numbers\n    int i = 2; // Index for generating Fibonacci numbers\n\n    while (count < n) {\n        // Generate the next Fibonacci number\n        int next_fib = fibs[i - 1] + fibs[i - 2];\n        fibs.push_back(next_fib);\n        \n        // Check if the Fibonacci number is prime\n        if (is_prime(next_fib)) {\n            count++;\n            if (count == n) {\n                return next_fib; // Return the n-th prime Fibonacci number\n            }\n        }\n        i++;\n    }\n    return -1; // In case n is invalid (should not happen with valid input)\n}\n"}
{"task_id": "CPP/40", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false; // Need at least three numbers to form a triplet\n\n    // Sort the array to use two-pointer technique\n    sort(l.begin(), l.end());\n\n    for (int i = 0; i < n - 2; i++) {\n        // Skip duplicate elements to avoid counting the same triplet\n        if (i > 0 && l[i] == l[i - 1]) continue;\n\n        int left = i + 1;\n        int right = n - 1;\n\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true; // Found a triplet that sums to zero\n            } else if (sum < 0) {\n                left++; // Need a larger sum\n            } else {\n                right--; // Need a smaller sum\n            }\n        }\n    }\n    return false; // No triplet found\n}\n"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Each car from the left will collide with each car from the right\n    return n * n; // Total collisions = n (left cars) * n (right cars)\n}\n"}
{"task_id": "CPP/42", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (int i = 0; i < l.size(); i++) {\n        l[i] += 1; // Increment each element by 1\n    }\n    return l; // Return the modified vector\n}\n"}
{"task_id": "CPP/43", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.count(-num)) {\n            return true; // Found a pair that sums to zero\n        }\n        seen.insert(num);\n    }\n    return false; // No pairs found that sum to zero\n}\n"}
{"task_id": "CPP/44", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (base < 2 || base >= 10) {\n        return \"\"; // Invalid base\n    }\n    \n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result; // Prepend the remainder\n        x /= base; // Divide x by the base\n    }\n    \n    return result.empty() ? \"0\" : result; // Handle the case when x is 0\n}\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h; // Area of triangle = 0.5 * base * height\n}\n"}
{"task_id": "CPP/46", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    int fib[n + 1];\n    fib[0] = 0;\n    fib[1] = 0;\n    fib[2] = 2;\n    fib[3] = 0;\n\n    for (int i = 4; i <= n; i++) {\n        fib[i] = fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4];\n    }\n\n    return fib[n];\n}\n"}
{"task_id": "CPP/47", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector to find the median\n    sort(l.begin(), l.end());\n    \n    int n = l.size();\n    if (n % 2 == 1) {\n        // If the size is odd, return the middle element\n        return l[n / 2];\n    } else {\n        // If the size is even, return the average of the two middle elements\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false; // Not a palindrome\n        }\n        left++;\n        right--;\n    }\n    return true; // Is a palindrome\n}\n"}
{"task_id": "CPP/49", "generation": "#include<stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0) return 1; // 2^0 is 1\n    long long result = 1; // Use long long to avoid overflow\n    long long base = 2; // Base is 2\n\n    // Use modular exponentiation\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p; // If n is odd, multiply the base with the result\n        }\n        base = (base * base) % p; // Square the base\n        n /= 2; // Divide n by 2\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_shift(string s){\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';   \n        out = out + (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s){\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    for (int i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';   \n        out = out + (char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        // Check if the character is not a vowel (both lowercase and uppercase)\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n            c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            result += c; // Append non-vowel characters to the result\n        }\n    }\n    return result; // Return the string without vowels\n}\n"}
{"task_id": "CPP/52", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false; // If any number is greater than or equal to the threshold, return false\n        }\n    }\n    return true; // All numbers are below the threshold\n}\n"}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n"}
{"task_id": "CPP/54", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Use a set to store unique characters from both strings\n    set<char> chars0(s0.begin(), s0.end());\n    set<char> chars1(s1.begin(), s1.end());\n    \n    // Compare the sets of unique characters\n    return chars0 == chars1;\n}\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) return 0; // Fibonacci of 0 is 0\n    if (n == 1) return 1; // Fibonacci of 1 is 1\n\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; i++) {\n        c = a + b; // Calculate the next Fibonacci number\n        a = b;     // Move to the next pair\n        b = c;\n    }\n    return b; // Return the n-th Fibonacci number\n}\n"}
{"task_id": "CPP/56", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // To keep track of the balance of brackets\n    for (char ch : brackets) {\n        if (ch == '<') {\n            balance++; // Increment for an opening bracket\n        } else if (ch == '>') {\n            balance--; // Decrement for a closing bracket\n        }\n        // If balance goes negative, it means there's a closing bracket without a matching opening bracket\n        if (balance < 0) {\n            return false;\n        }\n    }\n    // At the end, balance should be zero for all opening brackets to be matched\n    return balance == 0;\n}\n"}
{"task_id": "CPP/57", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() < 2) return true; // A single element or empty vector is considered monotonic\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); i++) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false; // Found an increasing pair\n        } else if (l[i] < l[i - 1]) {\n            increasing = false; // Found a decreasing pair\n        }\n    }\n\n    return increasing || decreasing; // Return true if either increasing or decreasing\n}\n"}
{"task_id": "CPP/58", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Use a set to store unique elements\n    set<int> set1(l1.begin(), l1.end());\n    set<int> set2(l2.begin(), l2.end());\n    \n    vector<int> result;\n    \n    // Iterate through the first set and check for common elements in the second set\n    for (const int& num : set1) {\n        if (set2.find(num) != set2.end()) {\n            result.push_back(num);\n        }\n    }\n    \n    // Sort the result (although using a set already keeps it sorted)\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/59", "generation": "#include<stdio.h>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int largest = -1;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        largest = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest = i;\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        largest = n;\n    }\n\n    return largest;\n}\n"}
{"task_id": "CPP/60", "generation": "#include<stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2;\n}\n"}
{"task_id": "CPP/61", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // To track the balance of brackets\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++; // Increment for opening bracket\n        } else if (ch == ')') {\n            balance--; // Decrement for closing bracket\n        }\n        // If balance goes negative, it means there's a closing bracket without a matching opening bracket\n        if (balance < 0) {\n            return false;\n        }\n    }\n    // At the end, balance should be zero for all brackets to be matched\n    return balance == 0;\n}\n"}
{"task_id": "CPP/62", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    int degree = xs.size() - 1; // The highest degree of the polynomial\n\n    for (int i = 1; i <= degree; i++) {\n        result.push_back(xs[i] * i); // Coefficient * degree\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    int a = 0, b = 0, c = 1; // fibfib(0), fibfib(1), fibfib(2)\n    int result = 0;\n\n    for (int i = 3; i <= n; i++) {\n        result = a + b + c; // fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n        a = b; // Update fibfib(n-3)\n        b = c; // Update fibfib(n-2)\n        c = result; // Update fibfib(n-1)\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/64", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    // Convert the string to lowercase to handle both uppercase and lowercase vowels\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n    \n    // Check for vowels in the string\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {\n            count++;\n        }\n    }\n    \n    // Check if the last character is 'y' and count it as a vowel if it is\n    if (s.length() > 0 && s[s.length() - 1] == 'y') {\n        count++;\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string numStr = to_string(x);\n    int len = numStr.length();\n    \n    // If shift is greater than the number of digits, reverse the string\n    if (shift >= len) {\n        reverse(numStr.begin(), numStr.end());\n        return numStr;\n    }\n    \n    // Perform the circular shift\n    string shiftedStr = numStr.substr(len - shift) + numStr.substr(0, len - shift);\n    return shiftedStr;\n}\n"}
{"task_id": "CPP/66", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/67", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0, oranges = 0;\n    string word;\n    stringstream ss(s);\n    \n    while (ss >> word) {\n        if (word == \"apples\") {\n            ss >> apples; // Get the number of apples\n        } else if (word == \"oranges\") {\n            ss >> oranges; // Get the number of oranges\n        }\n    }\n    \n    return n - apples - oranges; // Calculate mangoes\n}\n"}
{"task_id": "CPP/68", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    vector<int> result;\n    int smallest_even_value = -1;\n    int smallest_index = -1;\n\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            if (smallest_even_value == -1 || arr[i] < smallest_even_value) {\n                smallest_even_value = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_even_value != -1) {\n        result.push_back(smallest_even_value);\n        result.push_back(smallest_index);\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/69", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_map>\n#include<algorithm>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequencyMap;\n    \n    // Count the frequency of each number\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n    \n    int result = -1;\n    \n    // Check for the greatest integer that meets the condition\n    for (const auto& entry : frequencyMap) {\n        int num = entry.first;\n        int freq = entry.second;\n        \n        // Check if the frequency is greater than or equal to the number itself\n        if (freq >= num) {\n            result = max(result, num);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/70", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    vector<int> result;\n    if (lst.empty()) {\n        return result; // Return empty vector if input is empty\n    }\n    \n    sort(lst.begin(), lst.end()); // Sort the input list\n    int left = 0; // Pointer for the minimum values\n    int right = lst.size() - 1; // Pointer for the maximum values\n    \n    // Alternate between the smallest and largest remaining elements\n    while (left <= right) {\n        if (left == right) {\n            result.push_back(lst[left]); // If both pointers meet, add the last element\n        } else {\n            result.push_back(lst[left]); // Add the minimum\n            result.push_back(lst[right]); // Add the maximum\n        }\n        left++;\n        right--;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b > c && a + c > b && b + c > a) {\n        // Calculate the semi-perimeter\n        float s = (a + b + c) / 2;\n        // Calculate the area using Heron's formula\n        float area = sqrt(s * (s - a) * (s - b) * (s - c));\n        // Return the area rounded to 2 decimal points\n        return round(area * 100) / 100;\n    } else {\n        // Return -1 if the sides do not form a valid triangle\n        return -1;\n    }\n}\n"}
{"task_id": "CPP/72", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is palindromic\n    int n = q.size();\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) {\n            return false; // Not a palindrome\n        }\n    }\n    \n    // Calculate the sum of the elements\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    \n    // Check if the sum is less than or equal to the maximum weight\n    return sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int changes = 0;\n    int n = arr.size();\n    \n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n"}
{"task_id": "CPP/74", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int totalChars1 = 0;\n    int totalChars2 = 0;\n\n    // Calculate total number of characters in lst1\n    for (const string& str : lst1) {\n        totalChars1 += str.size();\n    }\n\n    // Calculate total number of characters in lst2\n    for (const string& str : lst2) {\n        totalChars2 += str.size();\n    }\n\n    // Return the vector with fewer total characters, or lst1 if they are equal\n    if (totalChars1 < totalChars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\n\nbool is_multiply_prime(int a) {\n    // List of prime numbers less than 100\n    vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    unordered_set<int> primeSet(primes.begin(), primes.end());\n    \n    // Check for combinations of three primes\n    for (int i = 0; i < primes.size(); i++) {\n        for (int j = i; j < primes.size(); j++) {\n            for (int k = j; k < primes.size(); k++) {\n                int product = primes[i] * primes[j] * primes[k];\n                if (product == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/76", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n <= 1) return false; // n must be greater than 1 for power checking\n    if (x < 1) return false; // x must be a positive integer\n\n    // Calculate the power of n until it exceeds x\n    int power = 1; // n^0 = 1\n    while (power < x) {\n        power *= n; // Calculate n^k\n    }\n\n    // Check if we found a power that equals x\n    return power == x;\n}\n"}
{"task_id": "CPP/77", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool iscube(int a) {\n    // Calculate the cube root of the absolute value of a\n    int cubeRoot = round(cbrt(abs(a)));\n    \n    // Check if the cube of the calculated cube root equals the absolute value of a\n    return (cubeRoot * cubeRoot * cubeRoot == abs(a));\n}\n"}
{"task_id": "CPP/78", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint hex_key(string num) {\n    // Set of prime hexadecimal digits\n    const string primeHexDigits = \"2357BD\"; // B (11) and D (13) are included\n    int count = 0;\n\n    // Iterate through each character in the input string\n    for (char c : num) {\n        // Check if the character is in the set of prime hexadecimal digits\n        if (primeHexDigits.find(c) != string::npos) {\n            count++;\n        }\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/79", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    string binary = \"\";\n    \n    // Handle the case for 0 explicitly\n    if (decimal == 0) {\n        return \"db0db\";\n    }\n\n    // Convert decimal to binary\n    while (decimal > 0) {\n        binary = to_string(decimal % 2) + binary; // Prepend the binary digit\n        decimal /= 2; // Divide by 2 to get the next digit\n    }\n\n    // Add the \"db\" prefix and suffix\n    return \"db\" + binary + \"db\";\n}\n"}
{"task_id": "CPP/80", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is at least 3\n    if (s.length() < 3) {\n        return false;\n    }\n    \n    // Iterate through the string and check every 3 consecutive characters\n    for (int i = 0; i <= s.length() - 3; i++) {\n        // Check if the three characters are distinct\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false; // If any two are the same, return false\n        }\n    }\n    \n    return true; // If all checks passed, the string is happy\n}\n"}
{"task_id": "CPP/81", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letterGrades;\n    \n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letterGrades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letterGrades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letterGrades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letterGrades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letterGrades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letterGrades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letterGrades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letterGrades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letterGrades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letterGrades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letterGrades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letterGrades.push_back(\"D-\");\n        } else {\n            letterGrades.push_back(\"E\");\n        }\n    }\n    \n    return letterGrades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\nbool prime_length(string str) {\n    int length = str.length();\n    return is_prime(length);\n}\n"}
{"task_id": "CPP/83", "generation": "#include<stdio.h>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n <= 0) return 0; // No n-digit numbers for non-positive n\n\n    // Count of n-digit numbers that start with 1\n    int start_with_one = 1; // Only one way to start with 1 (1xxxx...x)\n    int remaining_digits = n - 1; // Remaining digits can be anything from 0-9\n    start_with_one *= 9 * pow(10, remaining_digits - 1); // 9 choices for the first digit (2-9) and 10 choices for each of the remaining digits\n\n    // Count of n-digit numbers that end with 1\n    int end_with_one = 0; // Initialize count for numbers ending with 1\n    if (n == 1) {\n        end_with_one = 1; // Only the number 1\n    } else {\n        end_with_one = 9 * pow(10, remaining_digits); // 9 choices for the first digit (1-9) and 10 choices for each of the remaining digits\n    }\n\n    // Total count of n-digit numbers that start or end with 1\n    return start_with_one + end_with_one;\n}\n"}
{"task_id": "CPP/84", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    \n    // Calculate the sum of digits\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to sum\n        N /= 10;       // Remove the last digit\n    }\n    \n    // Convert the sum to binary\n    string binary = \"\";\n    if (sum == 0) {\n        return \"0\"; // Handle the case where sum is 0\n    }\n    \n    while (sum > 0) {\n        binary = to_string(sum % 2) + binary; // Prepend the binary digit\n        sum /= 2; // Divide sum by 2\n    }\n    \n    return binary; // Return the binary representation of the sum\n}\n"}
{"task_id": "CPP/85", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) { // Start from index 1 and step by 2\n        if (lst[i] % 2 == 0) { // Check if the element is even\n            sum += lst[i]; // Add to sum if it's even\n        }\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/86", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result = \"\";\n    string word = \"\";\n    \n    for (char c : s) {\n        if (c == ' ') {\n            // If we encounter a space, sort the current word and add it to the result\n            if (!word.empty()) {\n                sort(word.begin(), word.end());\n                result += word + ' ';\n                word = \"\"; // Reset the word\n            }\n            result += ' '; // Add the space to the result\n        } else {\n            word += c; // Build the current word\n        }\n    }\n    \n    // Sort the last word if it exists\n    if (!word.empty()) {\n        sort(word.begin(), word.end());\n        result += word;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/87", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n\n    // Iterate through each row of the nested vector\n    for (int i = 0; i < lst.size(); i++) {\n        for (int j = 0; j < lst[i].size(); j++) {\n            // Check if the current element is equal to x\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j}); // Store the coordinates\n            }\n        }\n    }\n\n    // Sort the coordinates by row (ascending) and then by column (descending)\n    sort(coordinates.begin(), coordinates.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort by column in descending order\n        }\n        return a[0] < b[0]; // Sort by row in ascending order\n    });\n\n    return coordinates;\n}\n"}
{"task_id": "CPP/88", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the array is empty or has only one element\n    if (array.size() <= 1) {\n        return array; // Return the array as is\n    }\n\n    // Calculate the sum of the first and last elements\n    int sum = array[0] + array[array.size() - 1];\n\n    // Sort the array based on the sum being odd or even\n    if (sum % 2 == 0) {\n        // Even sum: sort in descending order\n        sort(array.begin(), array.end(), greater<int>());\n    } else {\n        // Odd sum: sort in ascending order\n        sort(array.begin(), array.end());\n    }\n\n    return array; // Return the sorted array\n}\n"}
{"task_id": "CPP/89", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string encrypted = \"\";\n    for (char c : s) {\n        // Check if the character is a lowercase letter\n        if (c >= 'a' && c <= 'z') {\n            // Rotate the character by 2 positions down the alphabet\n            char newChar = (c - 'a' + 4) % 26 + 'a'; // 2 * 2 = 4\n            encrypted += newChar;\n        }\n    }\n    return encrypted;\n}\n"}
{"task_id": "CPP/90", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    // Remove duplicates by converting the vector to a set\n    set<int> unique_elements(lst.begin(), lst.end());\n    \n    // If there are less than 2 unique elements, return None\n    if (unique_elements.size() < 2) {\n        return -1; // Using -1 to represent None\n    }\n    \n    // Convert the set back to a vector and sort it\n    vector<int> sorted_unique(unique_elements.begin(), unique_elements.end());\n    \n    // Return the second smallest element\n    return sorted_unique[1];\n}\n"}
{"task_id": "CPP/91", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nint is_bored(string S) {\n    int boredomCount = 0;\n    stringstream ss(S);\n    string sentence;\n\n    // Split the string into sentences based on delimiters\n    while (getline(ss, sentence, '.')) {\n        if (sentence.empty()) continue;\n        if (sentence.back() == '?' || sentence.back() == '!') {\n            sentence.pop_back(); // Remove the last character if it's a delimiter\n        }\n        // Trim leading whitespace\n        while (!sentence.empty() && isspace(sentence[0])) {\n            sentence.erase(sentence.begin());\n        }\n        // Check if the sentence starts with \"I\"\n        if (sentence.rfind(\"I \", 0) == 0 || sentence == \"I\") {\n            boredomCount++;\n        }\n    }\n\n    return boredomCount;\n}\n"}
{"task_id": "CPP/92", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n    \n    // Check if one number is equal to the sum of the other two\n    return (a == b + c) || (b == a + c) || (c == a + b);\n}\n"}
{"task_id": "CPP/93", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    string encodedMessage = \"\";\n    for (char c : message) {\n        // Swap case\n        if (isupper(c)) {\n            c = tolower(c);\n        } else if (islower(c)) {\n            c = toupper(c);\n        }\n\n        // Replace vowels\n        if (c == 'a' || c == 'A') {\n            c = 'C'; // 'A' -> 'C'\n        } else if (c == 'e' || c == 'E') {\n            c = 'G'; // 'E' -> 'G'\n        } else if (c == 'i' || c == 'I') {\n            c = 'K'; // 'I' -> 'K'\n        } else if (c == 'o' || c == 'O') {\n            c = 'Q'; // 'O' -> 'Q'\n        } else if (c == 'u' || c == 'U') {\n            c = 'W'; // 'U' -> 'W'\n        }\n\n        encodedMessage += c;\n    }\n    return encodedMessage;\n}\n"}
{"task_id": "CPP/94", "generation": "#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it is prime\n}\n\n// Function to calculate the sum of digits of a number\nint sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n        sum += num % 10; // Add the last digit\n        num /= 10; // Remove the last digit\n    }\n    return sum;\n}\n\n// Main function to find the largest prime and return the sum of its digits\nint skjkasdkd(vector<int> lst) {\n    int largestPrime = -1; // Initialize to -1 to indicate no prime found\n    for (int num : lst) {\n        if (isPrime(num) && num > largestPrime) {\n            largestPrime = num; // Update largest prime found\n        }\n    }\n    // If no prime number was found, return 0 or handle as needed\n    if (largestPrime == -1) return 0; \n    return sumOfDigits(largestPrime); // Return the sum of digits of the largest prime\n}\n"}
{"task_id": "CPP/95", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<cctype> // for islower and isupper\nusing namespace std;\n\nbool check_dict_case(map<string,string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n    \n    // Iterate through each key in the map\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n        \n        // Check if the key is not a string (should not happen in map<string, string>)\n        // Check if the key contains any non-alphabetic characters\n        if (!std::all_of(key.begin(), key.end(), ::isalpha)) {\n            return false;\n        }\n        \n        // Check if the key is either all lower case or all upper case\n        if (!std::all_of(key.begin(), key.end(), ::islower) && \n            !std::all_of(key.begin(), key.end(), ::isupper)) {\n            return false;\n        }\n    }\n    \n    return true; // All checks passed\n}\n"}
{"task_id": "CPP/96", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool isPrime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        if (isPrime(i)) {\n            primes.push_back(i); // Add prime number to the list\n        }\n    }\n    return primes; // Return the list of prime numbers\n}\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the unit digits of both numbers\n    int unitDigitA = abs(a) % 10; // Use abs to handle negative numbers\n    int unitDigitB = abs(b) % 10; // Use abs to handle negative numbers\n    \n    // Return the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n"}
{"task_id": "CPP/98", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    for (int i = 0; i < s.length(); i += 2) { // Iterate over even indices\n        char c = s[i];\n        if (c >= 'A' && c <= 'Z') { // Check if the character is an uppercase vowel\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/99", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nint closest_integer(string value) {\n    double num = stod(value); // Convert string to double\n    int lower = floor(num); // Get the lower integer\n    int upper = ceil(num); // Get the upper integer\n\n    // Check the distance from the number to the lower and upper integers\n    double distanceToLower = abs(num - lower);\n    double distanceToUpper = abs(num - upper);\n\n    // If the distances are equal, round away from zero\n    if (distanceToLower == distanceToUpper) {\n        if (num > 0) {\n            return upper; // Round up for positive numbers\n        } else {\n            return lower; // Round down for negative numbers\n        }\n    }\n\n    // Return the closest integer\n    return (distanceToLower < distanceToUpper) ? lower : upper;\n}\n"}
{"task_id": "CPP/100", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    int current_stones = n;\n    \n    for (int i = 0; i < n; i++) {\n        stones.push_back(current_stones);\n        // Determine the next number of stones based on the parity of current_stones\n        if (current_stones % 2 == 0) {\n            current_stones += 2; // next even number\n        } else {\n            current_stones += 2; // next odd number\n        }\n    }\n    \n    return stones;\n}\n"}
{"task_id": "CPP/101", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    stringstream ss(s);\n    string word;\n\n    // Replace commas with spaces to handle both delimiters\n    replace(s.begin(), s.end(), ',', ' ');\n\n    // Split the string by spaces\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    return words;\n}\n"}
{"task_id": "CPP/102", "generation": "#include<stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1;\n    }\n    \n    // If y is even, return y\n    if (y % 2 == 0) {\n        return y;\n    }\n    \n    // If y is odd, return y - 1 if it's greater than or equal to x\n    if (y - 1 >= x) {\n        return y - 1;\n    }\n    \n    // If no even number is found in the range\n    return -1;\n}\n"}
{"task_id": "CPP/103", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    \n    // Calculate the sum of integers from n to m\n    int sum = 0;\n    for (int i = n; i <= m; i++) {\n        sum += i;\n    }\n    \n    // Calculate the count of integers from n to m\n    int count = m - n + 1;\n    \n    // Calculate the average and round it down\n    int average = sum / count;\n    \n    // Convert the average to binary\n    string binary = \"\";\n    while (average > 0) {\n        binary = to_string(average % 2) + binary;\n        average /= 2;\n    }\n    \n    return binary.empty() ? \"0\" : binary; // Handle case when average is 0\n}\n"}
{"task_id": "CPP/104", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool hasEvenDigit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true; // Found an even digit\n        }\n        num /= 10;\n    }\n    return false; // No even digits found\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    sort(result.begin(), result.end()); // Sort the result in increasing order\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Map to convert numbers to their corresponding names\n    map<int, string> numToName = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n    \n    // Filter the array to keep only numbers between 1 and 9\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n    \n    // Sort the filtered array\n    sort(filtered.begin(), filtered.end());\n    \n    // Reverse the sorted array\n    reverse(filtered.begin(), filtered.end());\n    \n    // Prepare the result vector\n    vector<string> result;\n    for (int num : filtered) {\n        result.push_back(numToName[num]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            // Calculate factorial for even i\n            int factorial = 1;\n            for (int j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else {\n            // Calculate sum from 1 to i for odd i\n            result[i - 1] = (i * (i + 1)) / 2; // Sum of first i natural numbers\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n\n    for (int i = 1; i <= n; i++) {\n        // Convert the integer to string to check if it's a palindrome\n        string str = to_string(i);\n        string reversedStr = string(str.rbegin(), str.rend());\n\n        // Check if the number is a palindrome\n        if (str == reversedStr) {\n            // Check if the palindrome is even or odd\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n\n    return {evenCount, oddCount};\n}\n"}
{"task_id": "CPP/108", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    while (num != 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(abs(num)) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true; // An empty vector is considered sorted\n\n    int n = arr.size();\n    int count = 0; // Count the number of times the order is violated\n\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            count++;\n        }\n    }\n\n    // If there are more than one violations, it's not possible to sort by right shifts\n    return count <= 1;\n}\n"}
{"task_id": "CPP/110", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    bool hasEvenInLst2 = false;\n    bool hasOddInLst1 = false;\n\n    // Check lst1 for odd numbers and lst2 for even numbers\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            hasOddInLst1 = true; // lst1 has at least one odd number\n            break;\n        }\n    }\n\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            hasEvenInLst2 = true; // lst2 has at least one even number\n            break;\n        }\n    }\n\n    // If lst1 has odd numbers and lst2 has even numbers, we can exchange\n    if (hasOddInLst1 && hasEvenInLst2) {\n        return \"YES\";\n    }\n\n    // If lst1 is already all even, return \"YES\"\n    if (!hasOddInLst1) {\n        return \"YES\";\n    }\n\n    // Otherwise, return \"NO\"\n    return \"NO\";\n}\n"}
{"task_id": "CPP/111", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nmap<string, int> histogram(string test) {\n    map<string, int> countMap;\n    stringstream ss(test);\n    string word;\n\n    // Count occurrences of each letter\n    while (ss >> word) {\n        countMap[word]++;\n    }\n\n    // Find the maximum occurrence\n    int maxCount = 0;\n    for (const auto& pair : countMap) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Prepare the result map with letters that have the maximum occurrence\n    map<string, int> result;\n    for (const auto& pair : countMap) {\n        if (pair.second == maxCount) {\n            result[pair.first] = pair.second;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/112", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Create a set of characters to delete for faster lookup\n    unordered_set<char> charsToDelete(c.begin(), c.end());\n    \n    // Create a new string with characters not in charsToDelete\n    string result;\n    for (char ch : s) {\n        if (charsToDelete.find(ch) == charsToDelete.end()) {\n            result += ch;\n        }\n    }\n    \n    // Check if the result string is a palindrome\n    string reversedResult = result;\n    reverse(reversedResult.begin(), reversedResult.end());\n    bool isPalindrome = (result == reversedResult);\n    \n    // Prepare the output\n    vector<string> output = {result, isPalindrome ? \"True\" : \"False\"};\n    return output;\n}\n"}
{"task_id": "CPP/113", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (int i = 0; i < lst.size(); i++) {\n        int odd_count = 0;\n        \n        // Count the number of odd digits in the current string\n        for (char c : lst[i]) {\n            if ((c - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n        \n        // Create the output string with the counted odd digits\n        string output = \"the number of odd elements \" + to_string(odd_count) + \n                        \"n the str\" + to_string(i) + \n                        \"ng \" + to_string(i) + \n                        \" of the \" + to_string(i) + \n                        \"nput.\";\n        \n        result.push_back(output);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long minSum = nums[0]; // Initialize minSum with the first element\n    long long currentSum = 0; // Variable to keep track of the current subarray sum\n\n    for (long long num : nums) {\n        currentSum += num; // Add the current number to the current sum\n        if (currentSum < minSum) {\n            minSum = currentSum; // Update minSum if currentSum is smaller\n        }\n        if (currentSum > 0) {\n            currentSum = 0; // Reset currentSum if it becomes positive\n        }\n    }\n    \n    return minSum; // Return the minimum sum found\n}\n"}
{"task_id": "CPP/115", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int totalLowerings = 0;\n\n    for (const auto& row : grid) {\n        int waterUnits = 0;\n\n        // Count the number of water units (1s) in the current row\n        for (int cell : row) {\n            waterUnits += cell;\n        }\n\n        // Calculate how many times we need to lower the bucket for this row\n        if (waterUnits > 0) {\n            totalLowerings += (waterUnits + capacity - 1) / capacity; // Equivalent to ceil(waterUnits / capacity)\n        }\n    }\n\n    return totalLowerings;\n}\n"}
{"task_id": "CPP/116", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> arr) {\n    sort(arr.begin(), arr.end(), [](int a, int b) {\n        int countA = __builtin_popcount(a); // Count number of 1s in binary representation of a\n        int countB = __builtin_popcount(b); // Count number of 1s in binary representation of b\n        if (countA == countB) {\n            return a < b; // If counts are the same, sort by value\n        }\n        return countA < countB; // Otherwise, sort by number of 1s\n    });\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word;\n    \n    // Split the string into words\n    for (char c : s) {\n        if (c == ' ') {\n            if (!word.empty()) {\n                // Count consonants in the word\n                int consonantCount = 0;\n                for (char ch : word) {\n                    if (isalpha(ch) && !strchr(\"aeiouAEIOU\", ch)) {\n                        consonantCount++;\n                    }\n                }\n                // Check if the word has exactly n consonants\n                if (consonantCount == n) {\n                    result.push_back(word);\n                }\n                word.clear(); // Reset word for the next one\n            }\n        } else {\n            word += c; // Build the current word\n        }\n    }\n    \n    // Check the last word if there is no trailing space\n    if (!word.empty()) {\n        int consonantCount = 0;\n        for (char ch : word) {\n            if (isalpha(ch) && !strchr(\"aeiouAEIOU\", ch)) {\n                consonantCount++;\n            }\n        }\n        if (consonantCount == n) {\n            result.push_back(word);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    // Define the set of vowels\n    string vowels = \"aeiouAEIOU\";\n    int n = word.length();\n    \n    // Iterate from the end of the word to find the closest vowel\n    for (int i = n - 1; i > 0; i--) {\n        // Check if the current character is a vowel\n        if (vowels.find(word[i]) != string::npos) {\n            // Check if the previous character is a consonant\n            if (i > 0 && vowels.find(word[i - 1]) == string::npos) {\n                // Check if the character before the consonant is also a consonant\n                if (i - 2 >= 0 && vowels.find(word[i - 2]) == string::npos) {\n                    return string(1, word[i]); // Return the closest vowel\n                }\n            }\n        }\n    }\n    \n    // If no vowel found between consonants, return an empty string\n    return \"\";\n}\n"}
{"task_id": "CPP/119", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    // Count the number of open and close parentheses in both strings\n    int open1 = 0, close1 = 0, open2 = 0, close2 = 0;\n\n    for (char c : lst[0]) {\n        if (c == '(') open1++;\n        else close1++;\n    }\n\n    for (char c : lst[1]) {\n        if (c == '(') open2++;\n        else close2++;\n    }\n\n    // Check if concatenating lst[0] + lst[1] can be balanced\n    // For lst[0] + lst[1] to be good:\n    // open1 + open2 must be >= close1 + close2\n    // and close1 must be <= open2 (to balance the closing parentheses)\n    if (open1 + open2 >= close1 + close2 && close1 <= open2) {\n        return \"Yes\";\n    }\n\n    // Check if concatenating lst[1] + lst[0] can be balanced\n    // For lst[1] + lst[0] to be good:\n    // open2 + open1 must be >= close2 + close1\n    // and close2 must be <= open1 (to balance the closing parentheses)\n    if (open2 + open1 >= close2 + close1 && close2 <= open1) {\n        return \"Yes\";\n    }\n\n    return \"No\";\n}\n"}
{"task_id": "CPP/120", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Take the first k elements\n    vector<int> result(arr.begin(), arr.begin() + k);\n    \n    // Sort the result in ascending order\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) { // Iterate through even positions\n        if (lst[i] % 2 != 0) { // Check if the element is odd\n            sum += lst[i]; // Add to sum if it's odd\n        }\n    }\n    return sum; // Return the total sum of odd elements in even positions\n}\n"}
{"task_id": "CPP/122", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++) {\n        if (arr[i] >= -99 && arr[i] <= 99) { // Check if the element has at most two digits\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    \n    // Generate the Collatz sequence\n    while (n != 1) {\n        if (n % 2 != 0) { // Check if n is odd\n            odd_numbers.push_back(n);\n        }\n        // Apply the Collatz rules\n        if (n % 2 == 0) {\n            n /= 2; // If n is even\n        } else {\n            n = 3 * n + 1; // If n is odd\n        }\n    }\n    \n    // Include 1 in the sequence as it is the last term\n    odd_numbers.push_back(1);\n    \n    // Sort the odd numbers in increasing order\n    sort(odd_numbers.begin(), odd_numbers.end());\n    \n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) return false;\n\n    // Check if the date is in the correct format (mm-dd-yyyy)\n    if (date[2] != '-' || date[5] != '-') return false;\n\n    // Extract month, day, and year\n    int month, day, year;\n    char dash1, dash2;\n    stringstream ss(date);\n    ss >> month >> dash1 >> day >> dash2 >> year;\n\n    // Check if the extraction was successful and if the delimiters are correct\n    if (ss.fail() || dash1 != '-' || dash2 != '-') return false;\n\n    // Check if month is valid\n    if (month < 1 || month > 12) return false;\n\n    // Check if day is valid based on the month\n    if (month == 2) {\n        // February: check for leap year\n        if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n            // Leap year: 29 days\n            if (day < 1 || day > 29) return false;\n        } else {\n            // Non-leap year: 28 days\n            if (day < 1 || day > 28) return false;\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        // Months with 30 days\n        if (day < 1 || day > 30) return false;\n    } else {\n        // Months with 31 days\n        if (day < 1 || day > 31) return false;\n    }\n\n    // If all checks passed, the date is valid\n    return true;\n}\n"}
{"task_id": "CPP/125", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<sstream>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    \n    // Check for whitespace\n    if (txt.find(' ') != string::npos) {\n        // Split by whitespace\n        stringstream ss(txt);\n        string word;\n        while (ss >> word) {\n            result.push_back(word);\n        }\n        return result;\n    }\n    \n    // Check for commas\n    if (txt.find(',') != string::npos) {\n        // Split by commas\n        stringstream ss(txt);\n        string word;\n        while (getline(ss, word, ',')) {\n            result.push_back(word);\n        }\n        return result;\n    }\n    \n    // If no whitespace or commas, count lowercase letters with odd order\n    int count = 0;\n    for (char c : txt) {\n        if (c >= 'a' && c <= 'z') {\n            int position = c - 'a'; // Get the position in the alphabet\n            if (position % 2 == 1) { // Check if it's odd\n                count++;\n            }\n        }\n    }\n    \n    // Return the count as a string in a vector\n    return {to_string(count)};\n}\n"}
{"task_id": "CPP/126", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    unordered_map<int, int> countMap;\n    \n    for (int i = 0; i < lst.size(); i++) {\n        // Count occurrences of each number\n        countMap[lst[i]]++;\n        // If any number appears more than twice, return false\n        if (countMap[lst[i]] > 2) {\n            return false;\n        }\n        // Check if the list is sorted\n        if (i > 0 && lst[i] < lst[i - 1]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    // Calculate the start and end of the intersection\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n    \n    // Check if there is an intersection\n    if (start > end) {\n        return \"NO\"; // No intersection\n    }\n    \n    // Calculate the length of the intersection\n    int length = end - start + 1; // +1 because both ends are inclusive\n    \n    // Check if the length is a prime number\n    if (isPrime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768; // Return -32768 for empty array\n    }\n\n    int sum_magnitudes = 0;\n    int product_sign = 1; // Start with a neutral product sign\n\n    for (int num : arr) {\n        if (num > 0) {\n            sum_magnitudes += num; // Add magnitude for positive numbers\n        } else if (num < 0) {\n            sum_magnitudes += -num; // Add magnitude for negative numbers\n            product_sign *= -1; // Flip sign for negative numbers\n        } else {\n            product_sign = 0; // If there's a zero, product sign becomes zero\n            break; // No need to continue if we encounter zero\n        }\n    }\n\n    return sum_magnitudes * product_sign; // Return the final result\n}\n"}
{"task_id": "CPP/129", "generation": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid dfs(int x, int y, int k, vector<vector<int>>& grid, vector<int>& currentPath, vector<int>& minPath) {\n    // If the path length is equal to k, check if it's the minimum path\n    if (currentPath.size() == k) {\n        if (minPath.empty() || currentPath < minPath) {\n            minPath = currentPath; // Update the minimum path\n        }\n        return;\n    }\n\n    // Directions for moving in the grid (up, down, left, right)\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    // Explore all neighbors\n    for (auto& dir : directions) {\n        int newX = x + dir.first;\n        int newY = y + dir.second;\n\n        // Check if the new position is within bounds\n        if (newX >= 0 && newX < grid.size() && newY >= 0 && newY < grid[0].size()) {\n            currentPath.push_back(grid[newX][newY]); // Add the new cell to the path\n            dfs(newX, newY, k, grid, currentPath, minPath); // Recur for the next cell\n            currentPath.pop_back(); // Backtrack\n        }\n    }\n}\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    vector<int> minPath; // To store the minimum path found\n    int n = grid.size();\n\n    // Try starting from each cell in the grid\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            vector<int> currentPath = {grid[i][j]}; // Start path with the current cell\n            dfs(i, j, k, grid, currentPath, minPath); // Start DFS from the current cell\n        }\n    }\n\n    return minPath; // Return the minimum path found\n}\n"}
{"task_id": "CPP/130", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> tribonacci(n + 1);\n    \n    // Base cases\n    tribonacci[0] = 1; // tri(0) = 1\n    if (n >= 1) tribonacci[1] = 3; // tri(1) = 3\n    if (n >= 2) tribonacci[2] = 2; // tri(2) = 2\n\n    // Calculate tribonacci values for n >= 3\n    for (int i = 3; i <= n; i++) {\n        if (i % 2 == 0) {\n            tribonacci[i] = 1 + (i / 2);\n        } else {\n            tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i + 1];\n        }\n    }\n\n    return tribonacci;\n}\n"}
{"task_id": "CPP/131", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOdd = false;\n\n    while (n > 0) {\n        int digit = n % 10; // Get the last digit\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit; // Multiply the product by the odd digit\n            hasOdd = true; // Mark that we have at least one odd digit\n        }\n        n /= 10; // Remove the last digit\n    }\n\n    return hasOdd ? product : 0; // Return product if there's at least one odd digit, otherwise return 0\n}\n"}
{"task_id": "CPP/132", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int openCount = 0; // To count the number of open brackets\n    int nestedCount = 0; // To check if we have a nested structure\n\n    for (char ch : str) {\n        if (ch == '[') {\n            openCount++;\n            // If we have an open bracket and we have seen at least one open bracket before, we have a nested structure\n            if (openCount > 1) {\n                nestedCount = 1; // Mark that we have a nested structure\n            }\n        } else if (ch == ']') {\n            if (openCount > 0) {\n                openCount--; // Close an open bracket\n            } else {\n                return false; // More closing brackets than opening brackets\n            }\n        }\n    }\n\n    // We need at least one nested structure and all brackets must be closed\n    return nestedCount == 1 && openCount == 0;\n}\n"}
{"task_id": "CPP/133", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int rounded = ceil(num); // Round up to the nearest integer\n        sum += rounded * rounded; // Add the square of the rounded number to the sum\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/134", "generation": "#include<stdio.h>\n#include<string>\n#include<cctype> // for isalpha function\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Trim trailing spaces\n    size_t end = txt.find_last_not_of(' ');\n    if (end == string::npos) {\n        return false; // The string is empty or contains only spaces\n    }\n    \n    // Get the last character\n    char lastChar = txt[end];\n    \n    // Check if the last character is an alphabetical character\n    if (isalpha(lastChar)) {\n        // Check if it's part of a word (i.e., not followed by a space)\n        if (end == 0 || txt[end - 1] == ' ') {\n            return true; // Last character is a letter and not part of a word\n        }\n    }\n    \n    return false; // Last character is not a letter or is part of a word\n}\n"}
{"task_id": "CPP/135", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int largestIndex = -1; // Initialize to -1, assuming no such element exists\n\n    for (int i = 1; i < arr.size(); i++) {\n        // Check if the current element is less than the previous one\n        if (arr[i] < arr[i - 1]) {\n            largestIndex = i; // Update the largest index\n        }\n    }\n\n    return largestIndex; // Return the largest index found, or -1 if none found\n}\n"}
{"task_id": "CPP/136", "generation": "#include<stdio.h>\n#include<vector>\n#include<limits.h> // For INT_MIN and INT_MAX\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = INT_MIN; // Initialize to the smallest possible integer\n    int smallest_positive = INT_MAX; // Initialize to the largest possible integer\n\n    for (int num : lst) {\n        if (num < 0) {\n            if (num > largest_negative) {\n                largest_negative = num; // Update largest negative\n            }\n        } else if (num > 0) {\n            if (num < smallest_positive) {\n                smallest_positive = num; // Update smallest positive\n            }\n        }\n    }\n\n    // If no negative number was found, set to 0\n    if (largest_negative == INT_MIN) {\n        largest_negative = 0;\n    }\n\n    // If no positive number was found, set to 0\n    if (smallest_positive == INT_MAX) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n#include <sstream>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Helper function to convert boost::any to double\n    auto to_double = [](boost::any value) -> double {\n        if (value.type() == typeid(int)) {\n            return boost::any_cast<int>(value);\n        } else if (value.type() == typeid(float)) {\n            return boost::any_cast<float>(value);\n        } else if (value.type() == typeid(string)) {\n            string str = boost::any_cast<string>(value);\n            // Replace ',' with '.' for proper float conversion\n            replace(str.begin(), str.end(), ',', '.');\n            return stod(str);\n        }\n        throw std::invalid_argument(\"Unsupported type\");\n    };\n\n    // Convert both values to double for comparison\n    double num1 = to_double(a);\n    double num2 = to_double(b);\n\n    // Compare the two numbers\n    if (num1 == num2) {\n        return \"None\";\n    } else {\n        // Return the larger value in its original type\n        if (num1 > num2) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // The smallest sum of 4 positive even numbers is 8 (2 + 2 + 2 + 2)\n    // Therefore, if n is less than 8, it cannot be expressed as such a sum.\n    if (n < 8) {\n        return false;\n    }\n    \n    // If n is even and greater than or equal to 8, it can be expressed as the sum of 4 positive even numbers.\n    return n % 2 == 0;\n}\n"}
{"task_id": "CPP/139", "generation": "#include<stdio.h>\nusing namespace std;\n\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; i++) {\n        long long factorial = 1;\n        for (int j = 1; j <= i; j++) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/140", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int spaceCount = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            spaceCount++;\n        } else {\n            if (spaceCount > 2) {\n                result += '-';\n            } else if (spaceCount > 0) {\n                result += string(spaceCount, '_');\n            }\n            result += c;\n            spaceCount = 0; // reset space count\n        }\n    }\n\n    // Handle the case where the string ends with spaces\n    if (spaceCount > 2) {\n        result += '-';\n    } else if (spaceCount > 0) {\n        result += string(spaceCount, '_');\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include<stdio.h>\n#include<string>\n#include<regex>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check for exactly one dot\n    size_t dotPos = file_name.find('.');\n    if (dotPos == string::npos || file_name.find('.', dotPos + 1) != string::npos) {\n        return \"No\";\n    }\n\n    // Split the file name into name and extension\n    string namePart = file_name.substr(0, dotPos);\n    string extPart = file_name.substr(dotPos + 1);\n\n    // Check if name part is not empty and starts with a letter\n    if (namePart.empty() || !isalpha(namePart[0])) {\n        return \"No\";\n    }\n\n    // Check for valid extension\n    if (extPart != \"txt\" && extPart != \"exe\" && extPart != \"dll\") {\n        return \"No\";\n    }\n\n    // Count digits in the name part\n    int digitCount = 0;\n    for (char c : namePart) {\n        if (isdigit(c)) {\n            digitCount++;\n        }\n    }\n\n    // Check if there are more than three digits\n    if (digitCount > 3) {\n        return \"No\";\n    }\n\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            // Square the entry if index is a multiple of 3\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            // Cube the entry if index is a multiple of 4 and not a multiple of 3\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            // Add the entry as is if it's not a multiple of 3 or 4\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<vector>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    vector<string> result;\n\n    // Split the sentence into words\n    while (ss >> word) {\n        // Check if the length of the word is prime\n        if (isPrime(word.length())) {\n            result.push_back(word);\n        }\n    }\n\n    // Join the words with a space\n    string output;\n    for (size_t i = 0; i < result.size(); i++) {\n        output += result[i];\n        if (i < result.size() - 1) {\n            output += \" \";\n        }\n    }\n\n    return output;\n}\n"}
{"task_id": "CPP/144", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Split the fractions into numerator and denominator\n    int numX, denX, numN, denN;\n    char slash;\n\n    // Parse the first fraction x\n    stringstream ssX(x);\n    ssX >> numX >> slash >> denX;\n\n    // Parse the second fraction n\n    stringstream ssN(n);\n    ssN >> numN >> slash >> denN;\n\n    // Calculate the product of the fractions\n    // x * n = (numX / denX) * (numN / denN) = (numX * numN) / (denX * denN)\n    int numerator = numX * numN;\n    int denominator = denX * denN;\n\n    // Check if the result is a whole number\n    return (numerator % denominator == 0);\n}\n"}
{"task_id": "CPP/145", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n// Function to calculate the sum of digits of a number\nint digit_sum(int num) {\n    int sum = 0;\n    // Handle negative numbers by taking absolute value\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\n// Function to sort the vector based on the sum of digits\nvector<int> order_by_points(vector<int> nums) {\n    // Create a vector of pairs to store the original index and the number\n    vector<pair<int, int>> indexed_nums;\n    for (int i = 0; i < nums.size(); i++) {\n        indexed_nums.push_back({nums[i], i});\n    }\n\n    // Sort the vector based on the sum of digits and original index\n    sort(indexed_nums.begin(), indexed_nums.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        int sum_a = digit_sum(a.first);\n        int sum_b = digit_sum(b.first);\n        // First compare by digit sum, then by original index\n        if (sum_a == sum_b) {\n            return a.second < b.second;\n        }\n        return sum_a < sum_b;\n    });\n\n    // Extract the sorted numbers from the pairs\n    vector<int> sorted_nums;\n    for (const auto& p : indexed_nums) {\n        sorted_nums.push_back(p.first);\n    }\n    \n    return sorted_nums;\n}\n"}
{"task_id": "CPP/146", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n\n    for (int num : nums) {\n        if (num > 10) {\n            string numStr = to_string(num);\n            char firstDigit = numStr[0];\n            char lastDigit = numStr[numStr.size() - 1];\n\n            if ((firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || firstDigit == '7' || firstDigit == '9') &&\n                (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' || lastDigit == '7' || lastDigit == '9')) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Fill the vector a with the given formula\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n    \n    int count = 0;\n\n    // Check all combinations of triples (i, j, k) where i < j < k\n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            for (int k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/148", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Check if the provided planet names are valid\n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n    \n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {}; // Return empty vector if either planet is invalid\n    }\n    \n    // Get the indices of the planets\n    int index1 = distance(planets.begin(), it1);\n    int index2 = distance(planets.begin(), it2);\n    \n    // Ensure index1 is less than index2 for easier processing\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Collect planets between the two indices\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0;\n    }), lst.end());\n\n    // Sort the remaining strings first by length, then alphabetically\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Sort alphabetically if lengths are equal\n        }\n        return a.length() < b.length(); // Sort by length\n    });\n\n    return lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it is prime\n}\n\nint x_or_y(int n, int x, int y) {\n    if (isPrime(n)) {\n        return x; // Return x if n is prime\n    } else {\n        return y; // Return y if n is not prime\n    }\n}\n"}
{"task_id": "CPP/151", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    for (float num : lst) {\n        // Check if the number is a non-negative integer and odd\n        if (num >= 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<int>(num) * static_cast<int>(num); // Add the square of the odd number\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/152", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    for (size_t i = 0; i < game.size(); i++) {\n        result.push_back(abs(game[i] - guess[i]));\n    }\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = -1; // Initialize to a value lower than any possible strength\n    string strongest_extension = \"\";\n\n    for (const string& ext : extensions) {\n        int CAP = 0;\n        int SM = 0;\n\n        // Calculate the strength of the current extension\n        for (char c : ext) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n\n        int strength = CAP - SM;\n\n        // Update the strongest extension if the current one is stronger\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n"}
{"task_id": "CPP/154", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Check if b is longer than a, if so, it can't be a substring\n    if (b.length() > a.length()) {\n        return false;\n    }\n    \n    // Create a new string that is the concatenation of b with itself\n    string b_rotated = b + b;\n    \n    // Check if b or any of its rotations is a substring of a\n    return b_rotated.find(a) != string::npos;\n}\n"}
{"task_id": "CPP/155", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    vector<int> count(2, 0); // count[0] for even, count[1] for odd\n    num = abs(num); // Consider absolute value to handle negative numbers\n\n    while (num > 0) {\n        int digit = num % 10; // Get the last digit\n        if (digit % 2 == 0) {\n            count[0]++; // Increment even count\n        } else {\n            count[1]++; // Increment odd count\n        }\n        num /= 10; // Remove the last digit\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/156", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the mapping of integers to their Roman numeral equivalents\n    vector<pair<int, string>> romanNumerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string result = \"\";\n    \n    // Iterate through the roman numeral pairs\n    for (const auto& pair : romanNumerals) {\n        // While the number is greater than or equal to the current value\n        while (number >= pair.first) {\n            result += pair.second; // Append the corresponding Roman numeral\n            number -= pair.first;  // Decrease the number by the value\n        }\n    }\n    \n    return result; // Return the final Roman numeral string\n}\n"}
{"task_id": "CPP/157", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to identify the longest side\n    float sides[3] = {a, b, c};\n    sort(sides, sides + 3);\n    \n    // Check the Pythagorean theorem\n    return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);\n}\n"}
{"task_id": "CPP/158", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string maxWord = \"\";\n    int maxUniqueCount = 0;\n\n    for (const string& word : words) {\n        unordered_set<char> uniqueChars(word.begin(), word.end());\n        int uniqueCount = uniqueChars.size();\n\n        if (uniqueCount > maxUniqueCount || \n           (uniqueCount == maxUniqueCount && word < maxWord)) {\n            maxUniqueCount = uniqueCount;\n            maxWord = word;\n        }\n    }\n\n    return maxWord;\n}\n"}
{"task_id": "CPP/159", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int totalEaten = number;\n    int toEat = need;\n\n    if (remaining >= toEat) {\n        totalEaten += toEat;\n        remaining -= toEat;\n    } else {\n        totalEaten += remaining;\n        remaining = 0;\n    }\n\n    return {totalEaten, remaining};\n}\n"}
{"task_id": "CPP/160", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stdlib.h>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    int result = operand[0]; // Start with the first operand\n\n    for (size_t i = 0; i < operato.size(); i++) {\n        string op = operato[i];\n        int nextOperand = operand[i + 1]; // Get the next operand\n\n        if (op == \"+\") {\n            result += nextOperand;\n        } else if (op == \"-\") {\n            result -= nextOperand;\n        } else if (op == \"*\") {\n            result *= nextOperand;\n        } else if (op == \"//\") {\n            if (nextOperand != 0) { // Avoid division by zero\n                result /= nextOperand;\n            } else {\n                throw invalid_argument(\"Division by zero encountered.\");\n            }\n        } else if (op == \"**\") {\n            result = pow(result, nextOperand); // Exponentiation\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetter = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n    \n    if (!hasLetter) {\n        reverse(s.begin(), s.end());\n        return s;\n    }\n    \n    for (char &c : s) {\n        if (isalpha(c)) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n        }\n    }\n    \n    return s;\n}\n"}
{"task_id": "CPP/162", "generation": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\"; // Return None as an empty string\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    char md5String[33];\n    for (int i = 0; i < 16; i++) {\n        sprintf(&md5String[i * 2], \"%02x\", (unsigned int)digest[i]);\n    }\n\n    return string(md5String);\n}\n"}
{"task_id": "CPP/163", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> even_digits = {0, 2, 4, 6, 8}; // List of even digits\n    vector<int> result;\n\n    // Ensure a is less than or equal to b\n    if (a > b) {\n        swap(a, b);\n    }\n\n    // Collect even digits within the range [a, b]\n    for (int digit : even_digits) {\n        if (digit >= a && digit <= b) {\n            result.push_back(digit);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/0", "generation": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n\nbool has_close_elements(vector<float> numbers, float threshold) {\n    for (int i = 0; i < numbers.size(); i++) {\n        for (int j = i + 1; j < numbers.size(); j++) {\n            if (abs(numbers[i] - numbers[j]) < threshold) {\n                return true; // Found two numbers closer than the threshold\n            }\n        }\n    }\n    return false; // No such pair found\n}\n"}
{"task_id": "CPP/1", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> separate_paren_groups(string paren_string) {\n    vector<string> result;\n    string current_group;\n    int balance = 0;\n\n    // Remove spaces from the input string\n    paren_string.erase(remove(paren_string.begin(), paren_string.end(), ' '), paren_string.end());\n\n    for (char ch : paren_string) {\n        if (ch == '(') {\n            if (balance == 0 && !current_group.empty()) {\n                // If we are starting a new group, push the current group to the result\n                result.push_back(current_group);\n                current_group.clear();\n            }\n            current_group += ch;\n            balance++;\n        } else if (ch == ')') {\n            current_group += ch;\n            balance--;\n        }\n\n        // If balance is zero, we have a complete group\n        if (balance == 0 && !current_group.empty()) {\n            result.push_back(current_group);\n            current_group.clear();\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/2", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat truncate_number(float number) {\n    int integerPart = static_cast<int>(number); // Get the integer part\n    float decimalPart = number - integerPart; // Calculate the decimal part\n    return decimalPart; // Return the decimal part\n}\n"}
{"task_id": "CPP/3", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0; // Start with zero balance\n    for (int operation : operations) {\n        balance += operation; // Update balance with each operation\n        if (balance < 0) { // Check if balance falls below zero\n            return true; // Return true if balance is below zero\n        }\n    }\n    return false; // Return false if balance never goes below zero\n}\n"}
{"task_id": "CPP/4", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat mean_absolute_deviation(vector<float> numbers) {\n    float sum = 0.0;\n    int n = numbers.size();\n    \n    // Calculate the mean\n    for (float num : numbers) {\n        sum += num;\n    }\n    float mean = sum / n;\n\n    // Calculate the Mean Absolute Deviation\n    float mad_sum = 0.0;\n    for (float num : numbers) {\n        mad_sum += fabs(num - mean);\n    }\n    \n    return mad_sum / n; // Return the average of absolute deviations\n}\n"}
{"task_id": "CPP/5", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> intersperse(vector<int> numbers, int delimeter) {\n    vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) { // Avoid adding delimiter after the last element\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/6", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> parse_nested_parens(string paren_string) {\n    vector<int> depths;\n    string::size_type start = 0, end;\n\n    while ((end = paren_string.find(' ', start)) != string::npos) {\n        string group = paren_string.substr(start, end - start);\n        int max_depth = 0, current_depth = 0;\n\n        for (char ch : group) {\n            if (ch == '(') {\n                current_depth++;\n                max_depth = max(max_depth, current_depth);\n            } else if (ch == ')') {\n                current_depth--;\n            }\n        }\n\n        depths.push_back(max_depth);\n        start = end + 1;\n    }\n\n    // Handle the last group after the last space\n    string group = paren_string.substr(start);\n    int max_depth = 0, current_depth = 0;\n\n    for (char ch : group) {\n        if (ch == '(') {\n            current_depth++;\n            max_depth = max(max_depth, current_depth);\n        } else if (ch == ')') {\n            current_depth--;\n        }\n    }\n\n    depths.push_back(max_depth);\n    \n    return depths;\n}\n"}
{"task_id": "CPP/7", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> filter_by_substring(vector<string> strings, string substring) {\n    vector<string> result;\n    for (const string& str : strings) {\n        if (str.find(substring) != string::npos) {\n            result.push_back(str);\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/8", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> sum_product(vector<int> numbers) {\n    int sum = 0;\n    int product = 1;\n\n    // If the vector is empty, return (0, 1)\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    // Calculate the sum and product\n    for (int number : numbers) {\n        sum += number;\n        product *= number;\n    }\n\n    return {sum, product};\n}\n"}
{"task_id": "CPP/9", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> rolling_max(vector<int> numbers) {\n    vector<int> result;\n    int current_max = INT_MIN; // Initialize current_max to the smallest integer\n\n    for (int num : numbers) {\n        current_max = max(current_max, num); // Update current_max if the current number is larger\n        result.push_back(current_max); // Add the current_max to the result vector\n    }\n\n    return result; // Return the vector of rolling maximums\n}\n"}
{"task_id": "CPP/10", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string str) {\n    // Test if given string is a palindrome \n    string s(str.rbegin(), str.rend());\n    return s == str;\n}\n\nstring make_palindrome(string str) {\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome(\"\") \n    \"\" \n    >>> make_palindrome(\"cat\") \n    \"catac\" \n    >>> make_palindrome(\"cata\") \n    \"catac\" \n    */\n    int n = str.length();\n    for (int i = n; i >= 0; --i) {\n        if (is_palindrome(str.substr(0, i))) {\n            // Append the reverse of the non-palindromic suffix\n            return str + string(str.rbegin() + (n - i), str.rend());\n        }\n    }\n    return str; // In case the input is already a palindrome\n}\n"}
{"task_id": "CPP/11", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring string_xor(string a, string b) {\n    string result = \"\";\n    int length = a.length();\n    \n    // Ensure both strings are of the same length\n    if (a.length() != b.length()) {\n        return \"\"; // Return empty string if lengths are not equal\n    }\n    \n    for (int i = 0; i < length; i++) {\n        // Perform XOR operation\n        if (a[i] == b[i]) {\n            result += '0'; // If both bits are the same, result is 0\n        } else {\n            result += '1'; // If bits are different, result is 1\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/12", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring longest(vector<string> strings) {\n    if (strings.empty()) {\n        return \"\"; // Return an empty string to represent None\n    }\n    \n    string longestString = strings[0];\n    \n    for (const string& str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str;\n        }\n    }\n    \n    return longestString;\n}\n"}
{"task_id": "CPP/13", "generation": "#include<stdio.h>\nusing namespace std;\n\nint greatest_common_divisor(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n"}
{"task_id": "CPP/14", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> all_prefixes(string str) {\n    vector<string> prefixes;\n    for (int i = 1; i <= str.length(); i++) {\n        prefixes.push_back(str.substr(0, i));\n    }\n    return prefixes;\n}\n"}
{"task_id": "CPP/15", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nstring string_sequence(int n) {\n    stringstream ss;\n    for (int i = 0; i <= n; ++i) {\n        ss << i;\n        if (i < n) {\n            ss << \" \"; // Add space only if it's not the last number\n        }\n    }\n    return ss.str();\n}\n"}
{"task_id": "CPP/16", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\nint count_distinct_characters(string str) {\n    set<char> distinctChars; // Using a set to store distinct characters\n    for (char c : str) {\n        distinctChars.insert(tolower(c)); // Convert to lowercase and insert into the set\n    }\n    return distinctChars.size(); // The size of the set gives the count of distinct characters\n}\n"}
{"task_id": "CPP/17", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nvector<int> parse_music(string music_string) {\n    vector<int> beats;\n    stringstream ss(music_string);\n    string note;\n\n    while (ss >> note) {\n        if (note == \"o\") {\n            beats.push_back(4); // whole note\n        } else if (note == \"o|\") {\n            beats.push_back(2); // half note\n        } else if (note == \".|\") {\n            beats.push_back(1); // quarter note\n        }\n    }\n\n    return beats;\n}\n"}
{"task_id": "CPP/18", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint how_many_times(string str, string substring) {\n    if (substring.empty()) return 0; // If the substring is empty, return 0\n    int count = 0;\n    size_t pos = 0;\n\n    // Loop to find all occurrences of the substring\n    while ((pos = str.find(substring, pos)) != string::npos) {\n        count++; // Increment count for each found occurrence\n        pos++; // Move to the next character to allow for overlapping matches\n    }\n\n    return count; // Return the total count of occurrences\n}\n"}
{"task_id": "CPP/19", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<vector>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nstring sort_numbers(string numbers) {\n    // Map to convert string representations of numbers to their corresponding integer values\n    map<string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3},\n        {\"four\", 4}, {\"five\", 5}, {\"six\", 6}, {\"seven\", 7},\n        {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    // Split the input string into words\n    stringstream ss(numbers);\n    vector<string> num_words;\n    string word;\n\n    while (ss >> word) {\n        num_words.push_back(word);\n    }\n\n    // Sort the words based on their integer values\n    sort(num_words.begin(), num_words.end(), [&](const string &a, const string &b) {\n        return num_map[a] < num_map[b];\n    });\n\n    // Join the sorted words back into a single string\n    string result;\n    for (const string &num : num_words) {\n        if (!result.empty()) {\n            result += \" \";\n        }\n        result += num;\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/20", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<float> find_closest_elements(vector<float> numbers) {\n    // Sort the numbers to make it easier to find the closest pairs\n    sort(numbers.begin(), numbers.end());\n    \n    // Initialize variables to store the closest pair\n    float minDiff = FLT_MAX; // Start with the maximum possible float value\n    vector<float> closestPair;\n\n    // Iterate through the sorted numbers to find the closest pair\n    for (int i = 0; i < numbers.size() - 1; i++) {\n        float diff = numbers[i + 1] - numbers[i]; // Calculate the difference between adjacent numbers\n        if (diff < minDiff) {\n            minDiff = diff; // Update the minimum difference\n            closestPair = {numbers[i], numbers[i + 1]}; // Update the closest pair\n        }\n    }\n\n    return closestPair; // Return the closest pair\n}\n"}
{"task_id": "CPP/21", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> rescale_to_unit(vector<float> numbers) {\n    float minVal = *min_element(numbers.begin(), numbers.end());\n    float maxVal = *max_element(numbers.begin(), numbers.end());\n    \n    vector<float> rescaled;\n    for (float num : numbers) {\n        float scaledValue = (num - minVal) / (maxVal - minVal);\n        rescaled.push_back(scaledValue);\n    }\n    \n    return rescaled;\n}\n"}
{"task_id": "CPP/22", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\n\nvector<int> filter_integers(list_any values) {\n    vector<int> result;\n    for (const auto& value : values) {\n        // Check if the value is of type int\n        if (value.type() == typeid(int)) {\n            result.push_back(boost::any_cast<int>(value));\n        }\n    }\n    return result;\n}\n"}
{"task_id": "CPP/23", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint strlen(string str) {\n    int length = 0;\n    for (char c : str) {\n        length++;\n    }\n    return length;\n}\n"}
{"task_id": "CPP/24", "generation": "#include<stdio.h>\nusing namespace std;\n\nint largest_divisor(int n) {\n    for (int i = n - 1; i > 0; i--) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1; // In case n is 1, the largest divisor is 1\n}\n"}
{"task_id": "CPP/25", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> factorize(int n) {\n    vector<int> factors;\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i * i <= n; i += 2) {\n        // While i divides n, add i and divide n\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n"}
{"task_id": "CPP/26", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\n\nvector<int> remove_duplicates(vector<int> numbers) {\n    unordered_map<int, int> countMap;\n    // Count occurrences of each number\n    for (int num : numbers) {\n        countMap[num]++;\n    }\n    \n    vector<int> result;\n    // Add numbers that occur only once to the result\n    for (int num : numbers) {\n        if (countMap[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/27", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring flip_case(string str) {\n    for (char &c : str) {\n        if (isupper(c)) {\n            c = tolower(c);\n        } else if (islower(c)) {\n            c = toupper(c);\n        }\n    }\n    return str;\n}\n"}
{"task_id": "CPP/28", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring concatenate(vector<string> strings) {\n    string result = \"\";\n    for (const string& str : strings) {\n        result += str; // Concatenate each string to the result\n    }\n    return result; // Return the concatenated string\n}\n"}
{"task_id": "CPP/29", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> filter_by_prefix(vector<string> strings, string prefix) {\n    vector<string> filtered;\n    for (const string& str : strings) {\n        if (str.find(prefix) == 0) { // Check if the string starts with the prefix\n            filtered.push_back(str);\n        }\n    }\n    return filtered;\n}\n"}
{"task_id": "CPP/30", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> get_positive(vector<float> l) {\n    vector<float> positives;\n    for (float num : l) {\n        if (num > 0) {\n            positives.push_back(num);\n        }\n    }\n    return positives;\n}\n"}
{"task_id": "CPP/31", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool is_prime(long long n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    if (n <= 3) return true; // 2 and 3 are prime numbers\n\n    // Check for even numbers and multiples of 3\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    // Check for factors from 5 to the square root of n\n    for (long long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n\n    return true; // n is prime\n}\n"}
{"task_id": "CPP/32", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\ndouble poly(vector<double> xs, double x) {\n    /* \n    Evaluates polynomial with coefficients xs at point x. return xs[0] + xs[1] * x + xs[2] * x^2 + .... xs[n] * x^n \n    */\n    double sum = 0;\n    for (int i = 0; i < xs.size(); i++) {\n        sum += xs[i] * pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(vector<double> xs) {\n    /*\n    xs are coefficients of a polynomial. find_zero finds x such that poly(x) = 0. \n    find_zero returns only one zero point, even if there are many. \n    Moreover, find_zero only takes list xs having even number of coefficients and largest non-zero coefficient as it guarantees a solution.\n    >>> round(find_zero([1, 2]), 2) #f(x) = 1 + 2x \n    -0.5 \n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 \n    1.0\n    */\n    \n    double left = -1000; // Start with a large negative value\n    double right = 1000; // Start with a large positive value\n    double mid;\n\n    // Use binary search to find a root\n    while (right - left > 1e-7) { // Precision threshold\n        mid = (left + right) / 2;\n        if (poly(xs, mid) == 0) {\n            return mid; // Found exact root\n        } else if (poly(xs, mid) > 0) {\n            right = mid; // Move left\n        } else {\n            left = mid; // Move right\n        }\n    }\n    \n    return (left + right) / 2; // Return the midpoint as the root\n}\n"}
{"task_id": "CPP/33", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_third(vector<int> l) {\n    vector<int> sorted_third;\n    \n    // Collect values at indices divisible by 3\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            sorted_third.push_back(l[i]);\n        }\n    }\n    \n    // Sort the collected values\n    sort(sorted_third.begin(), sorted_third.end());\n    \n    // Replace values in the original list at indices divisible by 3\n    int sorted_index = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l[i] = sorted_third[sorted_index++];\n        }\n    }\n    \n    return l;\n}\n"}
{"task_id": "CPP/34", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> unique(vector<int> l) {\n    // Sort the vector\n    sort(l.begin(), l.end());\n    \n    // Use the unique function to remove duplicates\n    auto last = unique(l.begin(), l.end());\n    \n    // Resize the vector to contain only unique elements\n    l.erase(last, l.end());\n    \n    return l;\n}\n"}
{"task_id": "CPP/35", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nfloat max_element(vector<float> l) {\n    float maxVal = l[0]; // Initialize maxVal with the first element\n    for (int i = 1; i < l.size(); i++) { // Start from the second element\n        if (l[i] > maxVal) { // If current element is greater than maxVal\n            maxVal = l[i]; // Update maxVal\n        }\n    }\n    return maxVal; // Return the maximum value found\n}\n"}
{"task_id": "CPP/36", "generation": "#include<stdio.h>\nusing namespace std;\n\nint countDigit7(int num) {\n    int count = 0;\n    while (num > 0) {\n        if (num % 10 == 7) {\n            count++;\n        }\n        num /= 10;\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    int totalCount = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            totalCount += countDigit7(i);\n        }\n    }\n    return totalCount;\n}\n"}
{"task_id": "CPP/37", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<float> sort_even(vector<float> l) {\n    // Create a vector to store the even indexed elements\n    vector<float> even_elements;\n\n    // Extract even indexed elements\n    for (int i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the even indexed elements\n    sort(even_elements.begin(), even_elements.end());\n\n    // Place the sorted even indexed elements back into the original vector\n    for (int i = 0, j = 0; i < l.size(); i += 2, j++) {\n        l[i] = even_elements[j];\n    }\n\n    return l;\n}\n"}
{"task_id": "CPP/38", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_cyclic(string s){ \n    // returns encoded string by cycling groups of three characters.  \n    // split string to groups. Each of length 3.\n    int l=s.length();\n    int num=(l+2)/3;\n    string x,output;\n    int i;\n    for (i=0;i*3<l;i++)\n    {\n        //cycle elements in each group. Unless group has fewer elements than 3.\n        x=s.substr(i*3,3);\n        if (x.length()==3) x=x.substr(1)+x[0];\n        output=output+x;\n    }\n    return output;\n}\n\nstring decode_cyclic(string s){ \n    /*\n    takes as input string encoded with encode_cyclic function. Returns decoded string. \n    */\n    int l = s.length();\n    string output;\n    for (int i = 0; i * 3 < l; i++)\n    {\n        // Extract the group of three characters\n        string x = s.substr(i * 3, 3);\n        if (x.length() == 3) {\n            // Shift the last character to the front\n            x = x[x.length() - 1] + x.substr(0, 2);\n        }\n        output += x;\n    }\n    return output;\n}\n"}
{"task_id": "CPP/39", "generation": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to return the n-th Fibonacci number that is also prime\nint prime_fib(int n) {\n    vector<int> fibs = {0, 1}; // Starting values for Fibonacci\n    int count = 0; // Count of prime Fibonacci numbers\n    int i = 2; // Index for Fibonacci sequence\n\n    while (count < n) {\n        // Generate the next Fibonacci number\n        int next_fib = fibs[i - 1] + fibs[i - 2];\n        fibs.push_back(next_fib);\n        \n        // Check if the Fibonacci number is prime\n        if (is_prime(next_fib)) {\n            count++;\n            if (count == n) {\n                return next_fib; // Return the n-th prime Fibonacci number\n            }\n        }\n        i++;\n    }\n    return -1; // In case n is invalid, though it shouldn't happen with valid input\n}\n"}
{"task_id": "CPP/40", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\n\nbool triples_sum_to_zero(vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false; // Need at least 3 elements\n\n    // Sort the array\n    sort(l.begin(), l.end());\n\n    for (int i = 0; i < n - 2; i++) {\n        // Avoid duplicates for the first element\n        if (i > 0 && l[i] == l[i - 1]) continue;\n\n        int left = i + 1;\n        int right = n - 1;\n\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true; // Found a triplet\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return false; // No triplet found\n}\n"}
{"task_id": "CPP/41", "generation": "#include<stdio.h>\nusing namespace std;\n\nint car_race_collision(int n) {\n    // Each car from the left will collide with each car from the right\n    return n * n; // Total collisions = n (left cars) * n (right cars)\n}\n"}
{"task_id": "CPP/42", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> incr_list(vector<int> l) {\n    for (int i = 0; i < l.size(); i++) {\n        l[i] += 1; // Increment each element by 1\n    }\n    return l; // Return the modified vector\n}\n"}
{"task_id": "CPP/43", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen;\n    for (int num : l) {\n        // Check if the negative of the current number has been seen\n        if (seen.count(-num)) {\n            return true; // Found a pair that sums to zero\n        }\n        seen.insert(num); // Add the current number to the set\n    }\n    return false; // No pairs found that sum to zero\n}\n"}
{"task_id": "CPP/44", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring change_base(int x, int base) {\n    if (base < 2 || base >= 10) {\n        return \"\"; // Invalid base\n    }\n    \n    string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = to_string(remainder) + result; // Prepend the remainder to the result\n        x /= base; // Divide x by the base\n    }\n    \n    return result.empty() ? \"0\" : result; // Return \"0\" if the result is empty\n}\n"}
{"task_id": "CPP/45", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float h) {\n    return 0.5 * a * h; // Area of triangle = 0.5 * base * height\n}\n"}
{"task_id": "CPP/46", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib4(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    int fib[n + 1];\n    fib[0] = 0;\n    fib[1] = 0;\n    fib[2] = 2;\n    fib[3] = 0;\n\n    for (int i = 4; i <= n; i++) {\n        fib[i] = fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4];\n    }\n\n    return fib[n];\n}\n"}
{"task_id": "CPP/47", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nfloat median(vector<float> l) {\n    // Sort the vector to find the median\n    sort(l.begin(), l.end());\n    int n = l.size();\n    \n    // If the size is odd, return the middle element\n    if (n % 2 != 0) {\n        return l[n / 2];\n    } else {\n        // If the size is even, return the average of the two middle elements\n        return (l[(n / 2) - 1] + l[n / 2]) / 2.0;\n    }\n}\n"}
{"task_id": "CPP/48", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_palindrome(string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n"}
{"task_id": "CPP/49", "generation": "#include<stdio.h>\nusing namespace std;\n\nint modp(int n, int p) {\n    if (n == 0) return 1; // 2^0 is 1\n    long long result = 1; // Use long long to avoid overflow\n    long long base = 2; // Base is 2\n    n = n % (p - 1); // Fermat's Little Theorem optimization\n\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * base) % p; // If n is odd, multiply the base with the result\n        }\n        base = (base * base) % p; // Square the base\n        n /= 2; // Divide n by 2\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/50", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encode_shift(string s) {\n    // returns encoded string by shifting every character by 5 in the alphabet.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] + 5 - (int)'a') % 26 + (int)'a';   \n        out = out + (char)w;\n    }\n    return out;\n}\n\nstring decode_shift(string s) {\n    // takes as input string encoded with encode_shift function. Returns decoded string.\n    string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a'; // Adding 26 to handle negative values\n        out = out + (char)w;\n    }\n    return out;\n}\n"}
{"task_id": "CPP/51", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring remove_vowels(string text) {\n    string result;\n    for (char c : text) {\n        // Check if the character is a vowel (both lowercase and uppercase)\n        if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n            c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            result += c; // Append non-vowel characters to the result\n        }\n    }\n    return result; // Return the string without vowels\n}\n"}
{"task_id": "CPP/52", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool below_threshold(vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false; // If any number is greater than or equal to the threshold, return false\n        }\n    }\n    return true; // All numbers are below the threshold\n}\n"}
{"task_id": "CPP/53", "generation": "#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\nint add(int x, int y) {\n    return x + y;\n}\n"}
{"task_id": "CPP/54", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nbool same_chars(string s0, string s1) {\n    // Create a set to store unique characters from both strings\n    unordered_set<char> set0(s0.begin(), s0.end());\n    unordered_set<char> set1(s1.begin(), s1.end());\n    \n    // Check if both sets have the same size and contain the same characters\n    return set0.size() == set1.size() && equal(set0.begin(), set0.end(), set1.begin());\n}\n"}
{"task_id": "CPP/55", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fib(int n) {\n    if (n <= 0) return 0; // Fibonacci of 0 is 0\n    if (n == 1) return 1; // Fibonacci of 1 is 1\n\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; i++) {\n        c = a + b; // Calculate the next Fibonacci number\n        a = b;     // Update a to the previous Fibonacci number\n        b = c;     // Update b to the current Fibonacci number\n    }\n    return b; // Return the n-th Fibonacci number\n}\n"}
{"task_id": "CPP/56", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // To keep track of the balance of brackets\n    for (char ch : brackets) {\n        if (ch == '<') {\n            balance++; // Increment for an opening bracket\n        } else if (ch == '>') {\n            balance--; // Decrement for a closing bracket\n        }\n        // If balance goes negative, it means there's a closing bracket without a matching opening bracket\n        if (balance < 0) {\n            return false;\n        }\n    }\n    // At the end, balance should be zero for all brackets to be matched\n    return balance == 0;\n}\n"}
{"task_id": "CPP/57", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool monotonic(vector<float> l) {\n    if (l.size() < 2) return true; // A single element or empty list is considered monotonic\n\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (size_t i = 1; i < l.size(); i++) {\n        if (l[i] > l[i - 1]) {\n            decreasing = false; // Found an increasing pair, not decreasing\n        } else if (l[i] < l[i - 1]) {\n            increasing = false; // Found a decreasing pair, not increasing\n        }\n    }\n\n    return increasing || decreasing; // Return true if either increasing or decreasing\n}\n"}
{"task_id": "CPP/58", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> common(vector<int> l1, vector<int> l2) {\n    // Sort both vectors to prepare for finding common elements\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\n    vector<int> result;\n    // Use two pointers to find common elements\n    int i = 0, j = 0;\n\n    while (i < l1.size() && j < l2.size()) {\n        if (l1[i] < l2[j]) {\n            i++;\n        } else if (l1[i] > l2[j]) {\n            j++;\n        } else {\n            // Found a common element\n            // Check if it's already in the result to ensure uniqueness\n            if (result.empty() || result.back() != l1[i]) {\n                result.push_back(l1[i]);\n            }\n            i++;\n            j++;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/59", "generation": "#include<stdio.h>\nusing namespace std;\n\nint largest_prime_factor(int n) {\n    int largest = -1;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        largest = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so we can skip even numbers\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest = i;\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        largest = n;\n    }\n\n    return largest;\n}\n"}
{"task_id": "CPP/60", "generation": "#include<stdio.h>\nusing namespace std;\n\nint sum_to_n(int n) {\n    return n * (n + 1) / 2; // Using the formula for the sum of the first n natural numbers\n}\n"}
{"task_id": "CPP/61", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool correct_bracketing(string brackets) {\n    int balance = 0; // To keep track of the balance of brackets\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++; // Increment for an opening bracket\n        } else if (ch == ')') {\n            balance--; // Decrement for a closing bracket\n        }\n        // If balance goes negative, it means there's a closing bracket without a matching opening bracket\n        if (balance < 0) {\n            return false;\n        }\n    }\n    // At the end, balance should be zero for all brackets to be matched\n    return balance == 0;\n}\n"}
{"task_id": "CPP/62", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<float> derivative(vector<float> xs) {\n    vector<float> result;\n    int degree = xs.size();\n    \n    for (int i = 1; i < degree; i++) {\n        result.push_back(xs[i] * i);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/63", "generation": "#include<stdio.h>\nusing namespace std;\n\nint fibfib(int n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    int a = 0, b = 0, c = 1; // fibfib(0), fibfib(1), fibfib(2)\n    int result = 0;\n\n    for (int i = 3; i <= n; ++i) {\n        result = a + b + c; // fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n        a = b; // Update fibfib(n-3)\n        b = c; // Update fibfib(n-2)\n        c = result; // Update fibfib(n-1)\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/64", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint vowels_count(string s) {\n    int count = 0;\n    int n = s.length();\n    \n    // Convert the string to lowercase to handle case insensitivity\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\n    \n    // Check for vowels in the string\n    for (int i = 0; i < n; i++) {\n        if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {\n            count++;\n        }\n    }\n    \n    // Check if the last character is 'y' and count it as a vowel\n    if (n > 0 && s[n - 1] == 'y') {\n        count++;\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/65", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring circular_shift(int x, int shift) {\n    string numStr = to_string(x);\n    int len = numStr.length();\n    \n    // If shift is greater than the number of digits, reverse the string\n    if (shift >= len) {\n        reverse(numStr.begin(), numStr.end());\n        return numStr;\n    }\n    \n    // Perform the circular shift\n    string shifted = numStr.substr(len - shift) + numStr.substr(0, len - shift);\n    return shifted;\n}\n"}
{"task_id": "CPP/66", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint digitSum(string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) { // Check if the character is uppercase\n            sum += static_cast<int>(c); // Add the ASCII value of the uppercase character\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/67", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nint fruit_distribution(string s, int n) {\n    int apples = 0, oranges = 0;\n    stringstream ss(s);\n    string word;\n\n    // Extract the number of apples\n    ss >> apples; // Read the number before \"apples\"\n    ss >> word;   // Read \"apples\"\n\n    // Extract the number of oranges\n    ss >> oranges; // Read the number before \"oranges\"\n    ss >> word;    // Read \"oranges\"\n\n    // Calculate the number of mangoes\n    return n - apples - oranges;\n}\n"}
{"task_id": "CPP/68", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> pluck(vector<int> arr) {\n    vector<int> result;\n    int smallest_even_value = -1; // Initialize to -1 to indicate no even value found\n    int smallest_index = -1;\n\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) { // Check if the number is even\n            if (smallest_even_value == -1 || arr[i] < smallest_even_value) {\n                smallest_even_value = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_even_value != -1) {\n        result.push_back(smallest_even_value);\n        result.push_back(smallest_index);\n    }\n\n    return result; // Return the result vector\n}\n"}
{"task_id": "CPP/69", "generation": "#include<stdio.h>\n#include<vector>\n#include<unordered_map>\n#include<algorithm>\nusing namespace std;\n\nint search(vector<int> lst) {\n    unordered_map<int, int> frequencyMap;\n    \n    // Count the frequency of each number\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n    \n    int result = -1;\n    \n    // Check for the greatest integer that meets the condition\n    for (const auto& entry : frequencyMap) {\n        int num = entry.first;\n        int freq = entry.second;\n        \n        if (num <= freq) {\n            result = max(result, num);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/70", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> strange_sort_list(vector<int> lst) {\n    vector<int> result;\n    if (lst.empty()) return result; // Return empty if input is empty\n\n    // Sort the list to easily access min and max values\n    sort(lst.begin(), lst.end());\n\n    // Use two pointers to pick elements from both ends\n    int left = 0;\n    int right = lst.size() - 1;\n    bool pickMin = true; // Start with picking the minimum\n\n    while (left <= right) {\n        if (pickMin) {\n            result.push_back(lst[left]);\n            left++;\n        } else {\n            result.push_back(lst[right]);\n            right--;\n        }\n        pickMin = !pickMin; // Alternate between min and max\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/71", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nfloat triangle_area(float a, float b, float c) {\n    // Check if the sides form a valid triangle\n    if (a + b > c && a + c > b && b + c > a) {\n        // Calculate the semi-perimeter\n        float s = (a + b + c) / 2;\n        // Calculate the area using Heron's formula\n        float area = sqrt(s * (s - a) * (s - b) * (s - c));\n        // Return the area rounded to 2 decimal points\n        return round(area * 100) / 100;\n    } else {\n        // Return -1 if the sides do not form a valid triangle\n        return -1;\n    }\n}\n"}
{"task_id": "CPP/72", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    // Check if the vector is palindromic\n    int n = q.size();\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) {\n            return false; // Not balanced\n        }\n    }\n    \n    // Calculate the sum of the elements\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    \n    // Check if the sum is less than or equal to the maximum weight\n    return sum <= w;\n}\n"}
{"task_id": "CPP/73", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint smallest_change(vector<int> arr) {\n    int changes = 0;\n    int n = arr.size();\n    \n    // Compare elements from the start and end towards the center\n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++; // Increment changes if elements are not equal\n        }\n    }\n    \n    return changes; // Return the total number of changes needed\n}\n"}
{"task_id": "CPP/74", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> total_match(vector<string> lst1, vector<string> lst2) {\n    int totalChars1 = 0;\n    int totalChars2 = 0;\n\n    // Calculate total characters in lst1\n    for (const string& str : lst1) {\n        totalChars1 += str.size();\n    }\n\n    // Calculate total characters in lst2\n    for (const string& str : lst2) {\n        totalChars2 += str.size();\n    }\n\n    // Compare total characters and return the appropriate vector\n    if (totalChars1 < totalChars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n"}
{"task_id": "CPP/75", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nbool is_multiply_prime(int a) {\n    vector<int> primes;\n    // Collect all prime numbers less than 100\n    for (int i = 2; i < 100; i++) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n\n    // Check for combinations of three primes\n    int n = primes.size();\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            for (int k = j; k < n; k++) {\n                int product = primes[i] * primes[j] * primes[k];\n                if (product == a) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n"}
{"task_id": "CPP/76", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool is_simple_power(int x, int n) {\n    if (n <= 1) {\n        return false; // n must be greater than 1 for power comparison\n    }\n    if (x == 1) {\n        return true; // 1 is a power of any number\n    }\n    \n    double power = log(x) / log(n); // Calculate the logarithm base n of x\n    return power == floor(power); // Check if power is an integer\n}\n"}
{"task_id": "CPP/77", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool iscube(int a) {\n    if (a < 0) {\n        a = -a; // Take the absolute value for negative numbers\n    }\n    int cubeRoot = round(pow(a, 1.0 / 3.0)); // Calculate the cube root and round it\n    return (cubeRoot * cubeRoot * cubeRoot == a); // Check if the cube of the rounded root equals the original number\n}\n"}
{"task_id": "CPP/78", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint hex_key(string num) {\n    // Set of prime hexadecimal digits\n    const string primeHexDigits = \"2357BD\"; // B = 11, D = 13\n    int count = 0;\n\n    // Iterate through each character in the input string\n    for (char c : num) {\n        // Check if the character is in the set of prime hexadecimal digits\n        if (primeHexDigits.find(c) != string::npos) {\n            count++;\n        }\n    }\n\n    return count; // Return the count of prime hexadecimal digits\n}\n"}
{"task_id": "CPP/79", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring decimal_to_binary(int decimal) {\n    string binary = \"db\"; // Start with \"db\"\n    \n    if (decimal == 0) {\n        binary += \"0\"; // Handle the case for 0\n    } else {\n        while (decimal > 0) {\n            binary += (decimal % 2 == 0) ? '0' : '1'; // Append '0' or '1'\n            decimal /= 2; // Divide by 2 to shift right\n        }\n    }\n    \n    reverse(binary.begin() + 2, binary.end()); // Reverse the binary string, skipping the \"db\"\n    binary += \"db\"; // End with \"db\"\n    \n    return binary;\n}\n"}
{"task_id": "CPP/80", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_happy(string s) {\n    // Check if the length of the string is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n    \n    // Iterate through the string and check every 3 consecutive characters\n    for (int i = 0; i <= s.length() - 3; i++) {\n        // Check if the three characters are distinct\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false; // Not happy if any two are the same\n        }\n    }\n    \n    return true; // All checks passed, the string is happy\n}\n"}
{"task_id": "CPP/81", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> numerical_letter_grade(vector<float> grades) {\n    vector<string> letterGrades;\n    \n    for (float gpa : grades) {\n        if (gpa == 4.0) {\n            letterGrades.push_back(\"A+\");\n        } else if (gpa > 3.7) {\n            letterGrades.push_back(\"A\");\n        } else if (gpa > 3.3) {\n            letterGrades.push_back(\"A-\");\n        } else if (gpa > 3.0) {\n            letterGrades.push_back(\"B+\");\n        } else if (gpa > 2.7) {\n            letterGrades.push_back(\"B\");\n        } else if (gpa > 2.3) {\n            letterGrades.push_back(\"B-\");\n        } else if (gpa > 2.0) {\n            letterGrades.push_back(\"C+\");\n        } else if (gpa > 1.7) {\n            letterGrades.push_back(\"C\");\n        } else if (gpa > 1.3) {\n            letterGrades.push_back(\"C-\");\n        } else if (gpa > 1.0) {\n            letterGrades.push_back(\"D+\");\n        } else if (gpa > 0.7) {\n            letterGrades.push_back(\"D\");\n        } else if (gpa > 0.0) {\n            letterGrades.push_back(\"D-\");\n        } else {\n            letterGrades.push_back(\"E\");\n        }\n    }\n    \n    return letterGrades;\n}\n"}
{"task_id": "CPP/82", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\nbool prime_length(string str) {\n    int length = str.length();\n    return is_prime(length);\n}\n"}
{"task_id": "CPP/83", "generation": "#include<stdio.h>\nusing namespace std;\n\nint starts_one_ends(int n) {\n    if (n <= 0) return 0; // Handle invalid input\n\n    // Count of n-digit numbers that start with 1\n    int start_with_one = 1; // The first digit is fixed as 1\n    // The remaining (n-1) digits can be anything from 0 to 9\n    if (n > 1) {\n        start_with_one *= 9 * pow(10, n - 2); // 9 choices for the second digit (2-9) and 10 choices for the rest\n    }\n\n    // Count of n-digit numbers that end with 1\n    int end_with_one = 9 * pow(10, n - 1); // 9 choices for the first digit (1-9) and 1 choice for the last digit (1)\n\n    // If n > 1, we have counted the numbers that both start and end with 1 twice\n    int both_start_and_end_with_one = 1; // Only the number '11' for n = 2\n    if (n > 2) {\n        both_start_and_end_with_one = pow(10, n - 2); // 10^(n-2) choices for the middle digits\n    }\n\n    // Total count\n    return start_with_one + end_with_one - both_start_and_end_with_one;\n}\n"}
{"task_id": "CPP/84", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring solve(int N) {\n    int sum = 0;\n    \n    // Calculate the sum of digits\n    while (N > 0) {\n        sum += N % 10; // Add the last digit to sum\n        N /= 10;       // Remove the last digit\n    }\n    \n    // Convert the sum to binary\n    string binary = \"\";\n    if (sum == 0) {\n        return \"0\"; // Handle the case where sum is 0\n    }\n    \n    while (sum > 0) {\n        binary = to_string(sum % 2) + binary; // Prepend the binary digit\n        sum /= 2; // Divide the sum by 2\n    }\n    \n    return binary;\n}\n"}
{"task_id": "CPP/85", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add(vector<int> lst) {\n    int sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) { // Start from index 1 and increment by 2 to get odd indices\n        if (lst[i] % 2 == 0) { // Check if the element is even\n            sum += lst[i]; // Add to sum if it's even\n        }\n    }\n    return sum; // Return the total sum\n}\n"}
{"task_id": "CPP/86", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring anti_shuffle(string s) {\n    string result = \"\";\n    string word = \"\";\n    \n    for (char c : s) {\n        if (c == ' ') {\n            // If we encounter a space, sort the current word and add it to the result\n            if (!word.empty()) {\n                sort(word.begin(), word.end());\n                result += word + ' ';\n                word = \"\"; // Reset the word\n            }\n            result += ' '; // Add the space to the result\n        } else {\n            word += c; // Build the current word\n        }\n    }\n    \n    // Sort the last word if it exists\n    if (!word.empty()) {\n        sort(word.begin(), word.end());\n        result += word;\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/87", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<vector<int>> get_row(vector<vector<int>> lst, int x) {\n    vector<vector<int>> coordinates;\n\n    // Iterate through each row and column to find occurrences of x\n    for (int i = 0; i < lst.size(); i++) {\n        for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                coordinates.push_back({i, j}); // Store the coordinates\n            }\n        }\n    }\n\n    // Sort coordinates by row (ascending) and then by column (descending)\n    sort(coordinates.begin(), coordinates.end(), [](const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) {\n            return a[1] > b[1]; // Sort by column in descending order if rows are the same\n        }\n        return a[0] < b[0]; // Sort by row in ascending order\n    });\n\n    return coordinates;\n}\n"}
{"task_id": "CPP/88", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> array) {\n    // Check if the array is empty or has only one element\n    if (array.size() <= 1) {\n        return array; // Return the array as is\n    }\n\n    // Calculate the sum of the first and last elements\n    int sum = array.front() + array.back();\n\n    // Sort the array based on the sum being odd or even\n    if (sum % 2 == 0) {\n        // Even sum: sort in descending order\n        sort(array.begin(), array.end(), greater<int>());\n    } else {\n        // Odd sum: sort in ascending order\n        sort(array.begin(), array.end());\n    }\n\n    return array; // Return the sorted array\n}\n"}
{"task_id": "CPP/89", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring encrypt(string s) {\n    string encrypted = \"\";\n    for (char c : s) {\n        // Check if the character is a lowercase letter\n        if (c >= 'a' && c <= 'z') {\n            // Rotate the letter by 2 * 2 = 4 positions\n            char newChar = c + 4;\n            // Wrap around if it goes past 'z'\n            if (newChar > 'z') {\n                newChar -= 26; // Wrap around to the start of the alphabet\n            }\n            encrypted += newChar;\n        }\n    }\n    return encrypted;\n}\n"}
{"task_id": "CPP/90", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint next_smallest(vector<int> lst) {\n    // Remove duplicates by using a set\n    set<int> unique_elements(lst.begin(), lst.end());\n    \n    // If there are less than 2 unique elements, return None\n    if (unique_elements.size() < 2) {\n        return -1; // Using -1 to represent None\n    }\n    \n    // Convert the set back to a vector and sort it\n    vector<int> sorted_unique(unique_elements.begin(), unique_elements.end());\n    \n    // Return the second smallest element\n    return sorted_unique[1];\n}\n"}
{"task_id": "CPP/91", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nint is_bored(string S) {\n    int boredomCount = 0;\n    stringstream ss(S);\n    string sentence;\n\n    // Split the string into sentences based on delimiters\n    while (getline(ss, sentence, '.')) {\n        if (sentence.empty()) continue;\n        if (sentence.back() == '?') {\n            sentence.pop_back();\n        }\n        if (sentence.back() == '!') {\n            sentence.pop_back();\n        }\n\n        // Trim leading whitespace\n        while (!sentence.empty() && isspace(sentence[0])) {\n            sentence.erase(sentence.begin());\n        }\n\n        // Check if the sentence starts with \"I\"\n        if (sentence.rfind(\"I \", 0) == 0 || sentence == \"I\") {\n            boredomCount++;\n        }\n    }\n\n    return boredomCount;\n}\n"}
{"task_id": "CPP/92", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool any_int(float a, float b, float c) {\n    // Check if all numbers are integers\n    if (floor(a) != a || floor(b) != b || floor(c) != c) {\n        return false;\n    }\n    \n    // Check if one number is equal to the sum of the other two\n    return (a == b + c) || (b == a + c) || (c == a + b);\n}\n"}
{"task_id": "CPP/93", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring encode(string message) {\n    string encodedMessage = \"\";\n    for (char c : message) {\n        // Swap case\n        if (isalpha(c)) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n            // Replace vowels\n            switch (tolower(c)) {\n                case 'a':\n                    c = 'c'; // 'a' -> 'c'\n                    break;\n                case 'e':\n                    c = 'g'; // 'e' -> 'g'\n                    break;\n                case 'i':\n                    c = 'k'; // 'i' -> 'k'\n                    break;\n                case 'o':\n                    c = 'q'; // 'o' -> 'q'\n                    break;\n                case 'u':\n                    c = 'w'; // 'u' -> 'w'\n                    break;\n                default:\n                    break; // Non-vowel characters remain unchanged\n            }\n        }\n        encodedMessage += c; // Append the processed character to the result\n    }\n    return encodedMessage;\n}\n"}
{"task_id": "CPP/94", "generation": "#include <iostream>\n\n"}
{"task_id": "CPP/95", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<cctype> // for islower and isupper\nusing namespace std;\n\nbool check_dict_case(map<string,string> dict) {\n    // Check if the map is empty\n    if (dict.empty()) {\n        return false;\n    }\n    \n    // Iterate through each key in the map\n    for (const auto& pair : dict) {\n        const string& key = pair.first;\n\n        // Check if the key is not a string (this should not happen since the map is of type <string, string>)\n        // But we will check if the key is valid\n        if (key.empty()) {\n            return false;\n        }\n\n        // Check if the key is either all lower case or all upper case\n        bool isLower = true;\n        bool isUpper = true;\n\n        for (char c : key) {\n            if (!isalpha(c)) {\n                return false; // Key contains non-alphabetic characters\n            }\n            if (islower(c)) {\n                isUpper = false; // Found a lowercase letter\n            } else if (isupper(c)) {\n                isLower = false; // Found an uppercase letter\n            }\n        }\n\n        // If the key is neither all lower case nor all upper case\n        if (!isLower && !isUpper) {\n            return false;\n        }\n    }\n\n    return true; // All keys are valid\n}\n"}
{"task_id": "CPP/96", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool isPrime(int num) {\n    if (num <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\nvector<int> count_up_to(int n) {\n    vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        if (isPrime(i)) {\n            primes.push_back(i); // Add prime number to the list\n        }\n    }\n    return primes; // Return the list of prime numbers\n}\n"}
{"task_id": "CPP/97", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nint multiply(int a, int b) {\n    // Get the unit digits of both integers\n    int unitDigitA = abs(a) % 10; // Use abs to handle negative numbers\n    int unitDigitB = abs(b) % 10; // Use abs to handle negative numbers\n    \n    // Return the product of the unit digits\n    return unitDigitA * unitDigitB;\n}\n"}
{"task_id": "CPP/98", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nint count_upper(string s) {\n    int count = 0;\n    for (int i = 0; i < s.length(); i += 2) { // Iterate over even indices\n        char c = s[i];\n        if (c >= 'A' && c <= 'Z') { // Check if the character is an uppercase vowel\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/99", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nint closest_integer(string value) {\n    double num = stod(value); // Convert string to double\n    int lower = floor(num);    // Get the lower integer\n    int upper = ceil(num);     // Get the upper integer\n\n    // Check the distance to the lower and upper integers\n    double lower_diff = abs(num - lower);\n    double upper_diff = abs(num - upper);\n\n    // If the number is equidistant from both integers, round away from zero\n    if (lower_diff == upper_diff) {\n        if (num > 0) {\n            return upper; // Round up for positive numbers\n        } else {\n            return lower; // Round down for negative numbers\n        }\n    }\n\n    // Return the closest integer\n    return (lower_diff < upper_diff) ? lower : upper;\n}\n"}
{"task_id": "CPP/100", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> make_a_pile(int n) {\n    vector<int> stones;\n    int currentStones = n; // Start with n stones for the first level\n\n    for (int i = 0; i < n; i++) {\n        stones.push_back(currentStones); // Add current level stones to the vector\n        // Determine the next number of stones based on whether n is odd or even\n        if (currentStones % 2 == 0) {\n            currentStones += 2; // Next even number\n        } else {\n            currentStones += 2; // Next odd number\n        }\n    }\n\n    return stones;\n}\n"}
{"task_id": "CPP/101", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\n\nvector<string> words_string(string s) {\n    vector<string> words;\n    stringstream ss(s);\n    string word;\n\n    // Replace commas with spaces to handle both delimiters\n    replace(s.begin(), s.end(), ',', ' ');\n\n    // Use stringstream to split the string by spaces\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    return words;\n}\n"}
{"task_id": "CPP/102", "generation": "#include<stdio.h>\nusing namespace std;\n\nint choose_num(int x, int y) {\n    // Ensure x is less than or equal to y\n    if (x > y) {\n        return -1;\n    }\n    \n    // Find the largest even number in the range [x, y]\n    if (y % 2 != 0) {\n        y--; // Decrease y by 1 if it's odd to make it even\n    }\n    \n    // Check if the adjusted y is still within the range\n    if (y >= x) {\n        return y; // Return the largest even number\n    }\n    \n    return -1; // No even number in the range\n}\n"}
{"task_id": "CPP/103", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\n\nstring rounded_avg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    \n    // Calculate the average\n    int sum = 0;\n    int count = m - n + 1; // Total numbers from n to m\n    for (int i = n; i <= m; i++) {\n        sum += i;\n    }\n    \n    // Calculate the average and round down\n    int average = sum / count; // Integer division automatically rounds down\n    \n    // Convert the average to binary\n    string binary = \"\";\n    while (average > 0) {\n        binary = to_string(average % 2) + binary; // Prepend the binary digit\n        average /= 2;\n    }\n    \n    return binary.empty() ? \"0\" : binary; // Handle the case where average is 0\n}\n"}
{"task_id": "CPP/104", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nbool hasEvenDigit(int num) {\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            return true; // Found an even digit\n        }\n        num /= 10;\n    }\n    return false; // No even digits found\n}\n\nvector<int> unique_digits(vector<int> x) {\n    vector<int> result;\n\n    for (int num : x) {\n        if (!hasEvenDigit(num)) {\n            result.push_back(num);\n        }\n    }\n\n    sort(result.begin(), result.end()); // Sort the result in increasing order\n    return result;\n}\n"}
{"task_id": "CPP/105", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nvector<string> by_length(vector<int> arr) {\n    // Create a map to convert numbers to their corresponding names\n    map<int, string> numToName = {\n        {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n        {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n    };\n    \n    // Filter the input array to only include numbers between 1 and 9\n    vector<int> filtered;\n    for (int num : arr) {\n        if (num >= 1 && num <= 9) {\n            filtered.push_back(num);\n        }\n    }\n    \n    // Sort the filtered array\n    sort(filtered.begin(), filtered.end());\n    \n    // Reverse the sorted array\n    reverse(filtered.begin(), filtered.end());\n    \n    // Convert the numbers to their corresponding names\n    vector<string> result;\n    for (int num : filtered) {\n        result.push_back(numToName[num]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/106", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> f(int n) {\n    vector<int> result(n);\n    \n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            // Calculate factorial for even index\n            int factorial = 1;\n            for (int j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else {\n            // Calculate sum from 1 to i for odd index\n            result[i - 1] = (i * (i + 1)) / 2; // Sum of first i natural numbers\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/107", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n\n    for (int i = 1; i <= n; i++) {\n        string numStr = to_string(i);\n        string reversedStr = string(numStr.rbegin(), numStr.rend());\n\n        if (numStr == reversedStr) { // Check if the number is a palindrome\n            if (i % 2 == 0) {\n                evenCount++; // Increment even count\n            } else {\n                oddCount++; // Increment odd count\n            }\n        }\n    }\n\n    return {evenCount, oddCount}; // Return the counts as a vector\n}\n"}
{"task_id": "CPP/108", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    while (num != 0) {\n        sum += num % 10; // Add the last digit\n        num /= 10;       // Remove the last digit\n    }\n    return sum;\n}\n\nint count_nums(vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(abs(num)) > 0) { // Check if the sum of digits is greater than 0\n            count++;\n        }\n    }\n    return count;\n}\n"}
{"task_id": "CPP/109", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) return true; // An empty vector is considered sorted.\n\n    int n = arr.size();\n    int count = 0; // To count the number of \"drops\" in the sorted order.\n\n    for (int i = 0; i < n; i++) {\n        // Check if the current element is greater than the next element.\n        if (arr[i] > arr[(i + 1) % n]) {\n            count++;\n        }\n    }\n\n    // If there are more than one drop, we cannot sort the array with right shifts.\n    return count <= 1;\n}\n"}
{"task_id": "CPP/110", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring exchange(vector<int> lst1, vector<int> lst2) {\n    bool hasEvenInLst2 = false;\n    \n    // Check if lst1 can be made all even\n    for (int num : lst1) {\n        if (num % 2 != 0) { // If there's an odd number in lst1\n            // Check if lst2 has at least one even number\n            for (int num2 : lst2) {\n                if (num2 % 2 == 0) {\n                    hasEvenInLst2 = true;\n                    break;\n                }\n            }\n            // If lst2 has no even number, return \"NO\"\n            if (!hasEvenInLst2) {\n                return \"NO\";\n            }\n        }\n    }\n    \n    // If all odd numbers in lst1 can be replaced with even numbers from lst2\n    return \"YES\";\n}\n"}
{"task_id": "CPP/111", "generation": "#include<stdio.h>\n#include<string>\n#include<map>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nmap<string, int> histogram(string test) {\n    map<string, int> countMap;\n    stringstream ss(test);\n    string word;\n    \n    // Count occurrences of each letter\n    while (ss >> word) {\n        countMap[word]++;\n    }\n\n    // Find the maximum occurrence\n    int maxCount = 0;\n    for (const auto& pair : countMap) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n        }\n    }\n\n    // Prepare the result map with letters that have the maximum occurrence\n    map<string, int> result;\n    for (const auto& pair : countMap) {\n        if (pair.second == maxCount) {\n            result[pair.first] = pair.second;\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/112", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> reverse_delete(string s, string c) {\n    // Create a set of characters to delete for faster lookup\n    unordered_set<char> charsToDelete(c.begin(), c.end());\n    \n    // Build the result string by skipping characters in the set\n    string result;\n    for (char ch : s) {\n        if (charsToDelete.find(ch) == charsToDelete.end()) {\n            result += ch;\n        }\n    }\n    \n    // Check if the result string is a palindrome\n    string reversedResult = result;\n    reverse(reversedResult.begin(), reversedResult.end());\n    bool isPalindrome = (result == reversedResult);\n    \n    // Prepare the output vector\n    vector<string> output;\n    output.push_back(result);\n    output.push_back(isPalindrome ? \"True\" : \"False\");\n    \n    return output;\n}\n"}
{"task_id": "CPP/113", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> odd_count(vector<string> lst) {\n    vector<string> result;\n    \n    for (int i = 0; i < lst.size(); i++) {\n        int oddCount = 0;\n        for (char c : lst[i]) {\n            if ((c - '0') % 2 != 0) { // Check if the digit is odd\n                oddCount++;\n            }\n        }\n        // Create the output string with the count of odd digits\n        result.push_back(\"the number of odd elements \" + to_string(oddCount) + \n                         \"n the str\" + to_string(i + 1) + \n                         \"ng \" + to_string(i + 1) + \n                         \" of the \" + to_string(i + 1) + \"nput.\");\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/114", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nlong long minSubArraySum(vector<long long> nums) {\n    long long currentSum = 0;\n    long long minSum = LLONG_MAX; // Initialize to maximum possible value\n\n    for (long long num : nums) {\n        currentSum += num; // Add current number to the current sum\n        if (currentSum < minSum) {\n            minSum = currentSum; // Update minSum if currentSum is smaller\n        }\n        if (currentSum > 0) {\n            currentSum = 0; // Reset currentSum if it becomes positive\n        }\n    }\n    \n    return minSum; // Return the minimum sum found\n}\n"}
{"task_id": "CPP/115", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint max_fill(vector<vector<int>> grid, int capacity) {\n    int totalLowerings = 0;\n\n    for (const auto& row : grid) {\n        int waterUnits = 0;\n\n        // Count the number of water units (1's) in the current row\n        for (int cell : row) {\n            waterUnits += cell;\n        }\n\n        // Calculate the number of times we need to lower the bucket for this row\n        if (waterUnits > 0) {\n            totalLowerings += (waterUnits + capacity - 1) / capacity; // Equivalent to ceil(waterUnits / capacity)\n        }\n    }\n\n    return totalLowerings;\n}\n"}
{"task_id": "CPP/116", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> sort_array(vector<int> arr) {\n    sort(arr.begin(), arr.end(), [](int a, int b) {\n        int countA = __builtin_popcount(a); // Count number of 1s in binary representation of a\n        int countB = __builtin_popcount(b); // Count number of 1s in binary representation of b\n        if (countA == countB) {\n            return a < b; // If counts are the same, sort by value\n        }\n        return countA < countB; // Otherwise, sort by number of 1s\n    });\n    return arr;\n}\n"}
{"task_id": "CPP/117", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> select_words(string s, int n) {\n    vector<string> result;\n    string word;\n    \n    // Split the string into words\n    for (char c : s) {\n        if (c == ' ') {\n            if (!word.empty()) {\n                int consonantCount = 0;\n                // Count consonants in the word\n                for (char ch : word) {\n                    if (isalpha(ch) && !strchr(\"aeiouAEIOU\", ch)) {\n                        consonantCount++;\n                    }\n                }\n                // Check if the word has exactly n consonants\n                if (consonantCount == n) {\n                    result.push_back(word);\n                }\n                word.clear(); // Reset the word for the next iteration\n            }\n        } else {\n            word += c; // Build the current word\n        }\n    }\n    \n    // Check the last word if there is no trailing space\n    if (!word.empty()) {\n        int consonantCount = 0;\n        for (char ch : word) {\n            if (isalpha(ch) && !strchr(\"aeiouAEIOU\", ch)) {\n                consonantCount++;\n            }\n        }\n        if (consonantCount == n) {\n            result.push_back(word);\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/118", "generation": "#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring get_closest_vowel(string word) {\n    // Define the set of vowels\n    string vowels = \"aeiouAEIOU\";\n    int n = word.size();\n    \n    // Iterate from the end of the word to find the closest vowel\n    for (int i = n - 1; i > 0; i--) {\n        // Check if the current character is a vowel\n        if (vowels.find(word[i]) != string::npos) {\n            // Check if the previous character is a consonant\n            if (i > 0 && vowels.find(word[i - 1]) == string::npos) {\n                // Check if the character before the consonant is also a consonant\n                if (i - 2 >= 0 && vowels.find(word[i - 2]) == string::npos) {\n                    return string(1, word[i]); // Return the vowel as a string\n                }\n            }\n        }\n    }\n    \n    // Return an empty string if no valid vowel is found\n    return \"\";\n}\n"}
{"task_id": "CPP/119", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring match_parens(vector<string> lst) {\n    string s1 = lst[0];\n    string s2 = lst[1];\n\n    // Function to check if a string of parentheses is balanced\n    auto is_balanced = [](const string& s) {\n        int balance = 0;\n        for (char c : s) {\n            if (c == '(') {\n                balance++;\n            } else {\n                balance--;\n            }\n            if (balance < 0) {\n                return false; // More closing brackets\n            }\n        }\n        return balance == 0; // Must be balanced at the end\n    };\n\n    // Check both concatenation orders\n    if (is_balanced(s1 + s2) || is_balanced(s2 + s1)) {\n        return \"Yes\";\n    }\n    return \"No\";\n}\n"}
{"task_id": "CPP/120", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> maximum(vector<int> arr, int k) {\n    // Sort the array in descending order\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    // Take the first k elements\n    vector<int> result(arr.begin(), arr.begin() + k);\n    \n    // Sort the result in ascending order before returning\n    sort(result.begin(), result.end());\n    \n    return result;\n}\n"}
{"task_id": "CPP/121", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint solution(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) { // Iterate through even positions\n        if (lst[i] % 2 != 0) { // Check if the element is odd\n            sum += lst[i]; // Add to sum if it's odd\n        }\n    }\n    return sum; // Return the final sum\n}\n"}
{"task_id": "CPP/122", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint add_elements(vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++) {\n        if (arr[i] >= -99 && arr[i] <= 99) { // Check if the element has at most two digits\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/123", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> get_odd_collatz(int n) {\n    vector<int> odd_numbers;\n    \n    // Generate the Collatz sequence\n    while (n != 1) {\n        if (n % 2 != 0) { // Check if n is odd\n            odd_numbers.push_back(n);\n        }\n        // Apply the Collatz rules\n        if (n % 2 == 0) {\n            n = n / 2; // If even, divide by 2\n        } else {\n            n = 3 * n + 1; // If odd, multiply by 3 and add 1\n        }\n    }\n    \n    // Include the last term which is always 1\n    odd_numbers.push_back(1);\n    \n    // Sort the odd numbers in increasing order\n    sort(odd_numbers.begin(), odd_numbers.end());\n    \n    return odd_numbers;\n}\n"}
{"task_id": "CPP/124", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nbool valid_date(string date) {\n    // Check if the date string is empty\n    if (date.empty()) return false;\n\n    // Check if the date is in the correct format (mm-dd-yyyy)\n    if (date[2] != '-' || date[5] != '-') return false;\n\n    // Split the date into components\n    int month, day, year;\n    char dash1, dash2;\n    stringstream ss(date);\n    ss >> month >> dash1 >> day >> dash2 >> year;\n\n    // Check if the input was parsed correctly\n    if (ss.fail() || dash1 != '-' || dash2 != '-') return false;\n\n    // Check month range\n    if (month < 1 || month > 12) return false;\n\n    // Check day range based on the month\n    if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && (day < 1 || day > 31)) {\n        return false;\n    } else if ((month == 4 || month == 6 || month == 9 || month == 11) && (day < 1 || day > 30)) {\n        return false;\n    } else if (month == 2) {\n        // Check for leap year for February\n        if (day < 1 || day > 29) {\n            return false;\n        }\n        if (day == 29) {\n            if ((year % 4 != 0) || (year % 100 == 0 && year % 400 != 0)) {\n                return false; // Not a leap year\n            }\n        }\n    }\n\n    return true; // All checks passed, the date is valid\n}\n"}
{"task_id": "CPP/125", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<sstream>\nusing namespace std;\n\nvector<string> split_words(string txt) {\n    vector<string> result;\n    \n    // Check for whitespace\n    if (txt.find(' ') != string::npos) {\n        // Split by whitespace\n        stringstream ss(txt);\n        string word;\n        while (ss >> word) {\n            result.push_back(word);\n        }\n        return result;\n    }\n    \n    // Check for commas\n    if (txt.find(',') != string::npos) {\n        // Split by commas\n        stringstream ss(txt);\n        string word;\n        while (getline(ss, word, ',')) {\n            result.push_back(word);\n        }\n        return result;\n    }\n    \n    // If no whitespace or commas, count lowercase letters with odd order\n    int count = 0;\n    for (char c : txt) {\n        if (c >= 'a' && c <= 'z') {\n            int position = c - 'a'; // Get the position in the alphabet\n            if (position % 2 == 1) { // Check if it's odd\n                count++;\n            }\n        }\n    }\n    \n    // Return the count as a string in a vector\n    return {to_string(count)};\n}\n"}
{"task_id": "CPP/126", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<unordered_map>\nusing namespace std;\n\nbool is_sorted(vector<int> lst) {\n    unordered_map<int, int> countMap;\n\n    for (int i = 0; i < lst.size(); i++) {\n        // Count occurrences of each number\n        countMap[lst[i]]++;\n\n        // If any number appears more than twice, return false\n        if (countMap[lst[i]] > 2) {\n            return false;\n        }\n\n        // Check if the list is sorted\n        if (i > 0 && lst[i] < lst[i - 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"}
{"task_id": "CPP/127", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it's prime\n}\n\nstring intersection(vector<int> interval1, vector<int> interval2) {\n    // Calculate the start and end of the intersection\n    int start = max(interval1[0], interval2[0]);\n    int end = min(interval1[1], interval2[1]);\n\n    // Check if there is an intersection\n    if (start > end) {\n        return \"NO\"; // No intersection\n    }\n\n    // Calculate the length of the intersection\n    int length = end - start + 1; // +1 because both ends are inclusive\n\n    // Check if the length is a prime number\n    if (isPrime(length)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n"}
{"task_id": "CPP/128", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint prod_signs(vector<int> arr) {\n    if (arr.empty()) {\n        return -32768; // Return -32768 for empty array\n    }\n\n    int sum_magnitudes = 0;\n    int product_sign = 1; // Start with a neutral product sign\n\n    for (int num : arr) {\n        if (num > 0) {\n            sum_magnitudes += num; // Add magnitude for positive numbers\n        } else if (num < 0) {\n            sum_magnitudes += -num; // Add magnitude for negative numbers\n            product_sign *= -1; // Flip the sign for negative numbers\n        } else {\n            product_sign = 0; // If there's a zero, product sign becomes zero\n        }\n    }\n\n    return sum_magnitudes * product_sign; // Return the final result\n}\n"}
{"task_id": "CPP/129", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvoid dfs(vector<vector<int>>& grid, int x, int y, int k, vector<int>& path, vector<int>& bestPath) {\n    // If we have reached the desired path length\n    if (path.size() == k) {\n        // Compare with the best path found so far\n        if (bestPath.empty() || path < bestPath) {\n            bestPath = path; // Update the best path\n        }\n        return;\n    }\n\n    // Directions for moving in the grid (up, down, left, right)\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    \n    // Explore all possible directions\n    for (auto& dir : directions) {\n        int newX = x + dir.first;\n        int newY = y + dir.second;\n\n        // Check if the new position is within the grid bounds\n        if (newX >= 0 && newX < grid.size() && newY >= 0 && newY < grid[0].size()) {\n            path.push_back(grid[newX][newY]); // Add the new cell value to the path\n            dfs(grid, newX, newY, k, path, bestPath); // Recur for the new cell\n            path.pop_back(); // Backtrack\n        }\n    }\n}\n\nvector<int> minPath(vector<vector<int>> grid, int k) {\n    vector<int> bestPath; // To store the best path found\n    int n = grid.size();\n\n    // Try starting from each cell in the grid\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            vector<int> path = {grid[i][j]}; // Start path with the current cell\n            dfs(grid, i, j, k, path, bestPath); // Perform DFS from the current cell\n        }\n    }\n\n    return bestPath; // Return the best path found\n}\n"}
{"task_id": "CPP/130", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> tri(int n) {\n    vector<int> tribonacci(n + 1);\n    \n    // Base cases\n    tribonacci[0] = 1; // tri(0) = 1\n    if (n >= 1) tribonacci[1] = 3; // tri(1) = 3\n    if (n >= 2) tribonacci[2] = 2; // tri(2) = 2\n\n    // Fill the tribonacci sequence\n    for (int i = 3; i <= n; i++) {\n        if (i % 2 == 0) {\n            tribonacci[i] = 1 + (i / 2); // tri(n) = 1 + n / 2 for even n\n        } else {\n            tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i + 1]; // tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1) for odd n\n        }\n    }\n\n    return tribonacci;\n}\n"}
{"task_id": "CPP/131", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nint digits(int n) {\n    int product = 1;\n    bool hasOdd = false;\n\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) { // Check if the digit is odd\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10; // Remove the last digit\n    }\n\n    return hasOdd ? product : 0; // Return product if there are odd digits, otherwise return 0\n}\n"}
{"task_id": "CPP/132", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool is_nested(string str) {\n    int openCount = 0; // Count of open brackets\n    int nestedCount = 0; // Count of nested brackets\n\n    for (char ch : str) {\n        if (ch == '[') {\n            openCount++;\n            // If we have an open bracket and we have seen at least one other open bracket before\n            if (openCount > 1) {\n                nestedCount++;\n            }\n        } else if (ch == ']') {\n            if (openCount > 0) {\n                openCount--;\n            } else {\n                // More closing brackets than opening brackets\n                return false;\n            }\n        }\n    }\n\n    // We need at least one nested bracket\n    return nestedCount > 0 && openCount == 0;\n}\n"}
{"task_id": "CPP/133", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<float> lst) {\n    int sum = 0;\n    for (float num : lst) {\n        int rounded = ceil(num); // Round up to the nearest integer\n        sum += rounded * rounded; // Add the square of the rounded number to the sum\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/134", "generation": "#include<stdio.h>\n#include<string>\n#include<cctype> // for isalpha\nusing namespace std;\n\nbool check_if_last_char_is_a_letter(string txt) {\n    // Trim trailing spaces\n    size_t end = txt.find_last_not_of(' ');\n    if (end == string::npos) {\n        return false; // String is empty or only contains spaces\n    }\n    \n    // Get the last character\n    char lastChar = txt[end];\n    \n    // Check if the last character is an alphabetical character\n    if (isalpha(lastChar)) {\n        // Check if it's not part of a word (i.e., it should be followed by a space or be the only character)\n        if (end == 0 || txt[end - 1] == ' ') {\n            return true;\n        }\n    }\n    \n    return false;\n}\n"}
{"task_id": "CPP/135", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint can_arrange(vector<int> arr) {\n    int largestIndex = -1; // Initialize the largest index to -1\n    for (int i = 1; i < arr.size(); i++) { // Start from the second element\n        if (arr[i] < arr[i - 1]) { // Check if the current element is less than the previous one\n            largestIndex = i; // Update the largest index\n        }\n    }\n    return largestIndex; // Return the largest index found or -1 if none found\n}\n"}
{"task_id": "CPP/136", "generation": "#include<stdio.h>\n#include<vector>\n#include<limits.h> // For INT_MIN and INT_MAX\nusing namespace std;\n\nvector<int> largest_smallest_integers(vector<int> lst) {\n    int largest_negative = INT_MIN; // Initialize to the smallest possible integer\n    int smallest_positive = INT_MAX; // Initialize to the largest possible integer\n\n    for (int num : lst) {\n        if (num < 0) {\n            if (num > largest_negative) {\n                largest_negative = num; // Update largest negative\n            }\n        } else if (num > 0) {\n            if (num < smallest_positive) {\n                smallest_positive = num; // Update smallest positive\n            }\n        }\n    }\n\n    // If no negative number was found, set to 0\n    if (largest_negative == INT_MIN) {\n        largest_negative = 0;\n    }\n    \n    // If no positive number was found, set to 0\n    if (smallest_positive == INT_MAX) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n"}
{"task_id": "CPP/137", "generation": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <boost/any.hpp>\n#include <sstream>\n\nusing namespace std;\n\nboost::any compare_one(boost::any a, boost::any b) {\n    // Helper function to convert boost::any to double\n    auto to_double = [](boost::any value) -> double {\n        if (value.type() == typeid(int)) {\n            return boost::any_cast<int>(value);\n        } else if (value.type() == typeid(float)) {\n            return boost::any_cast<float>(value);\n        } else if (value.type() == typeid(string)) {\n            string str_value = boost::any_cast<string>(value);\n            // Replace ',' with '.' for proper float conversion\n            replace(str_value.begin(), str_value.end(), ',', '.');\n            return stod(str_value);\n        }\n        throw std::invalid_argument(\"Unsupported type\");\n    };\n\n    // Convert both values to double for comparison\n    double num1 = to_double(a);\n    double num2 = to_double(b);\n\n    // Compare the two values\n    if (num1 == num2) {\n        return \"None\";\n    } else {\n        // Return the larger value in its original type\n        if (num1 > num2) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n}\n"}
{"task_id": "CPP/138", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool is_equal_to_sum_even(int n) {\n    // Check if n is less than 8, as the smallest sum of 4 positive even numbers (2 + 2 + 2 + 2) is 8\n    if (n < 8) {\n        return false;\n    }\n    // Check if n is even, as the sum of even numbers is always even\n    return n % 2 == 0;\n}\n"}
{"task_id": "CPP/139", "generation": "#include<stdio.h>\nusing namespace std;\n\nlong long special_factorial(int n) {\n    long long result = 1;\n    for (int i = 1; i <= n; i++) {\n        long long factorial = 1;\n        for (int j = 1; j <= i; j++) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n"}
{"task_id": "CPP/140", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring fix_spaces(string text) {\n    string result;\n    int space_count = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n        } else {\n            if (space_count > 2) {\n                result += '-'; // Replace more than 2 spaces with a single '-'\n            } else if (space_count == 1) {\n                result += '_'; // Replace single space with '_'\n            } else if (space_count == 2) {\n                result += \"__\"; // Replace two consecutive spaces with '__'\n            }\n            result += c; // Add the current character\n            space_count = 0; // Reset space count\n        }\n    }\n\n    // Handle the case where the string ends with spaces\n    if (space_count > 2) {\n        result += '-';\n    } else if (space_count == 1) {\n        result += '_';\n    } else if (space_count == 2) {\n        result += \"__\";\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/141", "generation": "#include<stdio.h>\n#include<string>\n#include<regex>\nusing namespace std;\n\nstring file_name_check(string file_name) {\n    // Check for exactly one dot\n    size_t dotPos = file_name.find('.');\n    if (dotPos == string::npos || file_name.find('.', dotPos + 1) != string::npos) {\n        return \"No\";\n    }\n\n    // Split the file name into name and extension\n    string namePart = file_name.substr(0, dotPos);\n    string extPart = file_name.substr(dotPos + 1);\n\n    // Check if namePart is not empty and starts with a letter\n    if (namePart.empty() || !isalpha(namePart[0])) {\n        return \"No\";\n    }\n\n    // Check for valid extension\n    if (extPart != \"txt\" && extPart != \"exe\" && extPart != \"dll\") {\n        return \"No\";\n    }\n\n    // Count digits in the file name\n    int digitCount = 0;\n    for (char c : file_name) {\n        if (isdigit(c)) {\n            digitCount++;\n        }\n    }\n\n    // Check if there are more than three digits\n    if (digitCount > 3) {\n        return \"No\";\n    }\n\n    return \"Yes\";\n}\n"}
{"task_id": "CPP/142", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint sum_squares(vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            // Square the integer if index is a multiple of 3\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            // Cube the integer if index is a multiple of 4 and not a multiple of 3\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            // Add the integer as is if index is not a multiple of 3 or 4\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/143", "generation": "#include<stdio.h>\n#include<string>\n#include<vector>\n#include<sstream>\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstring words_in_sentence(string sentence) {\n    stringstream ss(sentence);\n    string word;\n    vector<string> result;\n\n    // Split the sentence into words\n    while (ss >> word) {\n        // Check if the length of the word is prime\n        if (isPrime(word.length())) {\n            result.push_back(word);\n        }\n    }\n\n    // Join the words back into a single string\n    string output;\n    for (size_t i = 0; i < result.size(); i++) {\n        output += result[i];\n        if (i < result.size() - 1) {\n            output += \" \"; // Add space between words\n        }\n    }\n\n    return output;\n}\n"}
{"task_id": "CPP/144", "generation": "#include<stdio.h>\n#include<string>\n#include<sstream>\n#include<vector>\nusing namespace std;\n\nbool simplify(string x, string n) {\n    // Split the fractions into numerator and denominator\n    int numX, denX, numN, denN;\n    char slash;\n\n    // Parse the first fraction x\n    stringstream ssX(x);\n    ssX >> numX >> slash >> denX;\n\n    // Parse the second fraction n\n    stringstream ssN(n);\n    ssN >> numN >> slash >> denN;\n\n    // Calculate the product of the fractions\n    int productNumerator = numX * numN;\n    int productDenominator = denX * denN;\n\n    // Check if the product is a whole number\n    return productNumerator % productDenominator == 0;\n}\n"}
{"task_id": "CPP/145", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n// Function to calculate the sum of digits of a number\nint digit_sum(int num) {\n    int sum = 0;\n    bool isNegative = num < 0; // Check if the number is negative\n    num = abs(num); // Work with the absolute value of the number\n\n    while (num > 0) {\n        sum += num % 10; // Add the last digit to the sum\n        num /= 10; // Remove the last digit\n    }\n\n    // If the number was negative, we consider the first digit as negative\n    return isNegative ? -sum : sum;\n}\n\n// Comparator function to sort based on digit sum and original index\nbool compare(const pair<int, int>& a, const pair<int, int>& b) {\n    if (a.first != b.first) {\n        return a.first < b.first; // Compare digit sums\n    }\n    return a.second < b.second; // Compare original indices if digit sums are equal\n}\n\nvector<int> order_by_points(vector<int> nums) {\n    vector<pair<int, int>> digitSums; // Pair to hold digit sum and original index\n\n    // Fill the vector with digit sums and original indices\n    for (int i = 0; i < nums.size(); i++) {\n        digitSums.push_back({digit_sum(nums[i]), i});\n    }\n\n    // Sort based on the custom comparator\n    sort(digitSums.begin(), digitSums.end(), compare);\n\n    // Create the output vector based on the sorted order\n    vector<int> sortedNums;\n    for (const auto& p : digitSums) {\n        sortedNums.push_back(nums[p.second]);\n    }\n\n    return sortedNums;\n}\n"}
{"task_id": "CPP/146", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nint specialFilter(vector<int> nums) {\n    int count = 0;\n\n    for (int num : nums) {\n        if (num > 10) {\n            string numStr = to_string(num);\n            char firstDigit = numStr[0];\n            char lastDigit = numStr[numStr.length() - 1];\n\n            if ((firstDigit == '1' || firstDigit == '3' || firstDigit == '5' || firstDigit == '7' || firstDigit == '9') &&\n                (lastDigit == '1' || lastDigit == '3' || lastDigit == '5' || lastDigit == '7' || lastDigit == '9')) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/147", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nint get_max_triples(int n) {\n    vector<int> a(n);\n    \n    // Fill the vector a with the given formula\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n    \n    int count = 0;\n    \n    // Check all combinations of triples (i, j, k)\n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            for (int k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n"}
{"task_id": "CPP/148", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> bf(string planet1, string planet2) {\n    vector<string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    \n    // Find the indices of the given planets\n    auto it1 = find(planets.begin(), planets.end(), planet1);\n    auto it2 = find(planets.begin(), planets.end(), planet2);\n    \n    // Check if both planets are valid\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {}; // Return empty vector if either planet is invalid\n    }\n    \n    // Get the indices of the planets\n    int index1 = distance(planets.begin(), it1);\n    int index2 = distance(planets.begin(), it2);\n    \n    // Ensure index1 is less than index2\n    if (index1 > index2) {\n        swap(index1, index2);\n    }\n    \n    // Collect planets between the two indices\n    vector<string> result;\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/149", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nvector<string> sorted_list_sum(vector<string> lst) {\n    // Remove strings with odd lengths\n    lst.erase(remove_if(lst.begin(), lst.end(), [](const string& s) {\n        return s.length() % 2 != 0;\n    }), lst.end());\n\n    // Sort the remaining strings first by length, then alphabetically\n    sort(lst.begin(), lst.end(), [](const string& a, const string& b) {\n        if (a.length() == b.length()) {\n            return a < b; // Sort alphabetically if lengths are equal\n        }\n        return a.length() < b.length(); // Sort by length\n    });\n\n    return lst;\n}\n"}
{"task_id": "CPP/150", "generation": "#include<stdio.h>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) return false; // 0 and 1 are not prime numbers\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false; // Found a divisor, not prime\n    }\n    return true; // No divisors found, it is prime\n}\n\nint x_or_y(int n, int x, int y) {\n    if (isPrime(n)) {\n        return x; // Return x if n is prime\n    } else {\n        return y; // Return y if n is not prime\n    }\n}\n"}
{"task_id": "CPP/151", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nlong long double_the_difference(vector<float> lst) {\n    long long sum = 0;\n    for (float num : lst) {\n        // Check if the number is a non-negative integer and odd\n        if (num >= 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<int>(num) * static_cast<int>(num); // Add the square of the odd number\n        }\n    }\n    return sum;\n}\n"}
{"task_id": "CPP/152", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n\nvector<int> compare(vector<int> game, vector<int> guess) {\n    vector<int> result;\n    for (size_t i = 0; i < game.size(); i++) {\n        result.push_back(abs(game[i] - guess[i]));\n    }\n    return result;\n}\n"}
{"task_id": "CPP/153", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring Strongest_Extension(string class_name, vector<string> extensions) {\n    int max_strength = -1; // Initialize to a value lower than any possible strength\n    string strongest_extension = \"\";\n\n    for (const string& ext : extensions) {\n        int CAP = 0, SM = 0;\n\n        // Calculate the strength of the current extension\n        for (char c : ext) {\n            if (isupper(c)) {\n                CAP++;\n            } else if (islower(c)) {\n                SM++;\n            }\n        }\n\n        int strength = CAP - SM;\n\n        // Check if this extension is stronger or if it's the first one\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = ext;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}\n"}
{"task_id": "CPP/154", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nbool cycpattern_check(string a, string b) {\n    // Check if b is longer than a, if so it can't be a substring\n    if (b.length() > a.length()) {\n        return false;\n    }\n    \n    // Create a new string that is the concatenation of b with itself\n    string b_rotated = b + b;\n    \n    // Check if b or any of its rotations is a substring of a\n    return b_rotated.find(a) != string::npos;\n}\n"}
{"task_id": "CPP/155", "generation": "#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\n\nvector<int> even_odd_count(int num) {\n    vector<int> count(2, 0); // count[0] for even, count[1] for odd\n    num = abs(num); // Consider absolute value for counting digits\n\n    while (num > 0) {\n        int digit = num % 10; // Get the last digit\n        if (digit % 2 == 0) {\n            count[0]++; // Increment even count\n        } else {\n            count[1]++; // Increment odd count\n        }\n        num /= 10; // Remove the last digit\n    }\n\n    return count;\n}\n"}
{"task_id": "CPP/156", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n\nstring int_to_mini_roman(int number) {\n    // Define the mapping of integers to their Roman numeral equivalents\n    vector<pair<int, string>> romanNumerals = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    string result = \"\";\n    \n    // Iterate through the mapping and build the Roman numeral string\n    for (const auto& pair : romanNumerals) {\n        while (number >= pair.first) {\n            result += pair.second;\n            number -= pair.first;\n        }\n    }\n    \n    return result;\n}\n"}
{"task_id": "CPP/157", "generation": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n\nbool right_angle_triangle(float a, float b, float c) {\n    // Sort the sides to identify the largest side\n    float sides[3] = {a, b, c};\n    std::sort(sides, sides + 3);\n    \n    // Check the Pythagorean theorem\n    return (fabs(sides[0] * sides[0] + sides[1] * sides[1] - sides[2] * sides[2]) < 1e-6);\n}\n"}
{"task_id": "CPP/158", "generation": "#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<unordered_set>\nusing namespace std;\n\nstring find_max(vector<string> words) {\n    string maxWord = \"\";\n    int maxUniqueCount = 0;\n\n    for (const string& word : words) {\n        unordered_set<char> uniqueChars(word.begin(), word.end());\n        int uniqueCount = uniqueChars.size();\n\n        if (uniqueCount > maxUniqueCount || \n           (uniqueCount == maxUniqueCount && word < maxWord)) {\n            maxUniqueCount = uniqueCount;\n            maxWord = word;\n        }\n    }\n    \n    return maxWord;\n}\n"}
{"task_id": "CPP/159", "generation": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nvector<int> eat(int number, int need, int remaining) {\n    int totalEaten = number;\n    int carrotsToEat = min(need, remaining);\n    \n    totalEaten += carrotsToEat;\n    int carrotsLeft = remaining - carrotsToEat;\n    \n    return {totalEaten, carrotsLeft};\n}\n"}
{"task_id": "CPP/160", "generation": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stdlib.h>\nusing namespace std;\n\nint do_algebra(vector<string> operato, vector<int> operand) {\n    int result = operand[0]; // Start with the first operand\n\n    for (size_t i = 0; i < operato.size(); i++) {\n        string op = operato[i];\n        int nextOperand = operand[i + 1]; // Get the next operand\n\n        if (op == \"+\") {\n            result += nextOperand;\n        } else if (op == \"-\") {\n            result -= nextOperand;\n        } else if (op == \"*\") {\n            result *= nextOperand;\n        } else if (op == \"//\") {\n            result /= nextOperand; // Assuming nextOperand is not zero\n        } else if (op == \"**\") {\n            result = pow(result, nextOperand);\n        }\n    }\n\n    return result;\n}\n"}
{"task_id": "CPP/161", "generation": "#include<stdio.h>\n#include<string>\nusing namespace std;\n\nstring solve(string s) {\n    bool hasLetter = false;\n    \n    // Check if there are any letters in the string\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n    \n    if (hasLetter) {\n        // Reverse case for letters\n        for (char &c : s) {\n            if (isalpha(c)) {\n                c = islower(c) ? toupper(c) : tolower(c);\n            }\n        }\n    } else {\n        // Reverse the string if no letters are present\n        reverse(s.begin(), s.end());\n    }\n    \n    return s;\n}\n"}
{"task_id": "CPP/162", "generation": "#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\n\nstring string_to_md5(string text) {\n    if (text.empty()) {\n        return \"\"; // Return empty string for None\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    char md5String[33];\n    for (int i = 0; i < 16; i++) {\n        sprintf(&md5String[i * 2], \"%02x\", (unsigned int)digest[i]);\n    }\n\n    return string(md5String);\n}\n"}
{"task_id": "CPP/163", "generation": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> generate_integers(int a, int b) {\n    vector<int> even_digits = {0, 2, 4, 6, 8}; // List of even digits\n    vector<int> result;\n\n    // Determine the range\n    int start = min(a, b);\n    int end = max(a, b);\n\n    // Collect even digits within the range\n    for (int digit : even_digits) {\n        if (digit >= start && digit <= end) {\n            result.push_back(digit);\n        }\n    }\n\n    return result;\n}\n"}
