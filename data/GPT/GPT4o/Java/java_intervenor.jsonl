{"task_id": "Java/0", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n    >>> has_close_elements(Arrays.asList(1.0, 2.0, 3.0), 0.5)\n    false\n    >>> has_close_elements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3)\n    true\n    */\n    public boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Sort the list to make it easier to find close elements\n        Collections.sort(numbers);\n        \n        // Check the difference between consecutive elements\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            if (Math.abs(numbers.get(i) - numbers.get(i + 1)) < threshold) {\n                return true; // Found two elements that are closer than the threshold\n            }\n        }\n        \n        return false; // No elements found that are closer than the threshold\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.has_close_elements(Arrays.asList(1.0, 2.0, 3.0), 0.5)); // false\n        System.out.println(solution.has_close_elements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3)); // true\n    }\n}\n"}
{"task_id": "Java/1", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> separate_paren_groups(String paren_string) {\n        List<String> result = new ArrayList<>();\n        StringBuilder currentGroup = new StringBuilder();\n        int balance = 0;\n\n        // Remove spaces from the input string\n        paren_string = paren_string.replaceAll(\"\\\\s+\", \"\");\n\n        // Iterate through each character in the string\n        for (char ch : paren_string.toCharArray()) {\n            currentGroup.append(ch); // Add the current character to the current group\n\n            // Update the balance\n            if (ch == '(') {\n                balance++;\n            } else if (ch == ')') {\n                balance--;\n            }\n\n            // If balance is zero, we have a complete group\n            if (balance == 0) {\n                result.add(currentGroup.toString()); // Add the complete group to the result\n                currentGroup.setLength(0); // Reset the current group for the next one\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.separate_paren_groups(\"( ) (( )) (( )( ))\"));\n        // Output: [\"()\", \"(())\", \"(()())\"]\n    }\n}\n"}
{"task_id": "Java/2", "generation": "class Solution {\n    /**\n    Given a positive floating point number, it can be decomposed into\n    an integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    */\n    public double truncate_number(double number) {\n        // Get the integer part of the number\n        double integerPart = Math.floor(number);\n        // Calculate and return the decimal part\n        return number - integerPart;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.truncate_number(3.5)); // Output: 0.5\n        System.out.println(solution.truncate_number(2.75)); // Output: 0.75\n        System.out.println(solution.truncate_number(5.0)); // Output: 0.0\n    }\n}\n"}
{"task_id": "Java/3", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account falls below zero, \n    and at that point function should return True. Otherwise it should return False.\n    >>> below_zero(Arrays.asList(1, 2, 3))\n    false\n    >>> below_zero(Arrays.asList(1, 2, -4, 5))\n    true\n    */\n    public boolean below_zero(List<Integer> operations) {\n        int balance = 0; // Start with a balance of zero\n        \n        for (int operation : operations) {\n            balance += operation; // Update the balance\n            \n            if (balance < 0) { // Check if the balance falls below zero\n                return true; // Return true if it does\n            }\n        }\n        \n        return false; // Return false if balance never goes below zero\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, 3))); // Output: false\n        System.out.println(solution.below_zero(Arrays.asList(1, 2, -4, 5))); // Output: true\n        System.out.println(solution.below_zero(Arrays.asList(-1, 1, -1))); // Output: true\n        System.out.println(solution.below_zero(Arrays.asList(5, -10, 5))); // Output: true\n    }\n}\n"}
{"task_id": "Java/4", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation(Arrays.asList(1.0, 2.0, 3.0, 4.0))\n    1.0\n    */\n    public double mean_absolute_deviation(List<Double> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            throw new IllegalArgumentException(\"The list of numbers cannot be null or empty.\");\n        }\n\n        // Step 1: Calculate the mean\n        double sum = 0.0;\n        for (double number : numbers) {\n            sum += number;\n        }\n        double mean = sum / numbers.size();\n\n        // Step 2: Calculate the absolute differences and their average\n        double madSum = 0.0;\n        for (double number : numbers) {\n            madSum += Math.abs(number - mean);\n        }\n        \n        // Step 3: Calculate the Mean Absolute Deviation\n        double mad = madSum / numbers.size();\n        return mad;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Double> numbers = Arrays.asList(1.0, 2.0, 3.0, 4.0);\n        System.out.println(solution.mean_absolute_deviation(numbers)); // Output: 1.0\n    }\n}\n"}
{"task_id": "Java/5", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Insert a number 'delimiter' between every two consecutive elements of input list `numbers'\n    >>> intersperse(List.of(), 4)\n    []\n    >>> intersperse(Arrays.asList(1, 2, 3), 4)\n    [1, 4, 2, 4, 3]\n    */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 0; i < numbers.size(); i++) {\n            result.add(numbers.get(i)); // Add the current element\n            \n            // If it's not the last element, add the delimiter\n            if (i < numbers.size() - 1) {\n                result.add(delimiter);\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.intersperse(List.of(), 4)); // []\n        System.out.println(solution.intersperse(Arrays.asList(1, 2, 3), 4)); // [1, 4, 2, 4, 3]\n    }\n}\n"}
{"task_id": "Java/6", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> parse_nested_parens(String paren_string) {\n        List<Integer> result = new ArrayList<>();\n        String[] groups = paren_string.split(\" \"); // Split the input string into groups\n\n        for (String group : groups) {\n            int currentDepth = 0; // Current depth of nesting\n            int maxDepth = 0; // Maximum depth encountered\n\n            for (char ch : group.toCharArray()) {\n                if (ch == '(') {\n                    currentDepth++; // Increment depth for '('\n                    maxDepth = Math.max(maxDepth, currentDepth); // Update max depth\n                } else if (ch == ')') {\n                    currentDepth--; // Decrement depth for ')'\n                }\n            }\n\n            result.add(maxDepth); // Add the maximum depth for the current group to the result\n        }\n\n        return result; // Return the list of maximum depths\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.parse_nested_parens(\"(()()) ((())) () ((())()())\")); // Output: [2, 3, 1, 3]\n    }\n}\n"}
{"task_id": "Java/7", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring(List.of(), \"a\")\n    []\n    >>> filter_by_substring(Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\"), \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    */\n    public List<String> filter_by_substring(List<String> strings, String substring) {\n        // Use streams to filter the list\n        return strings.stream()\n                      .filter(s -> s.contains(substring))\n                      .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.filter_by_substring(List.of(), \"a\")); // []\n        System.out.println(solution.filter_by_substring(Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\"), \"a\")); // [\"abc\", \"bacd\", \"array\"]\n    }\n}\n"}
{"task_id": "Java/8", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product(List.of())\n    [0, 1]\n    >>> sum_product(Arrays.asList(1, 2, 3, 4))\n    [10, 24]\n    */\n    public List<Integer> sum_product(List<Integer> numbers) {\n        // Initialize sum and product\n        int sum = 0;\n        int product = 1;\n\n        // If the list is empty, return the default values\n        if (numbers.isEmpty()) {\n            return Arrays.asList(sum, product);\n        }\n\n        // Calculate sum and product\n        for (int number : numbers) {\n            sum += number;\n            product *= number;\n        }\n\n        // Return the result as a list\n        return Arrays.asList(sum, product);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sum_product(List.of())); // Output: [0, 1]\n        System.out.println(solution.sum_product(Arrays.asList(1, 2, 3, 4))); // Output: [10, 24]\n    }\n}\n"}
{"task_id": "Java/9", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max(Arrays.asList(1, 2, 3, 2, 3, 4, 2))\n    [1, 2, 3, 3, 3, 4, 4]\n    */\n    public List<Integer> rolling_max(List<Integer> numbers) {\n        List<Integer> result = new ArrayList<>();\n        if (numbers == null || numbers.isEmpty()) {\n            return result; // Return empty list if input is null or empty\n        }\n\n        int currentMax = Integer.MIN_VALUE; // Initialize currentMax to the smallest integer value\n\n        for (int number : numbers) {\n            currentMax = Math.max(currentMax, number); // Update currentMax\n            result.add(currentMax); // Add currentMax to the result list\n        }\n\n        return result; // Return the list of rolling maximums\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> input = Arrays.asList(1, 2, 3, 2, 3, 4, 2);\n        List<Integer> output = solution.rolling_max(input);\n        System.out.println(output); // Output: [1, 2, 3, 3, 3, 4, 4]\n    }\n}\n"}
{"task_id": "Java/10", "generation": "public class PalindromeMaker {\n\n    public String makePalindrome(String string) {\n        // Edge case: if the input string is empty, return it\n        if (string.isEmpty()) {\n            return string;\n        }\n\n        // Find the longest palindromic suffix\n        int longestPalindromicSuffixLength = 0;\n        for (int i = 0; i < string.length(); i++) {\n            if (isPalindrome(string.substring(i))) {\n                longestPalindromicSuffixLength = string.length() - i;\n                break;\n            }\n        }\n\n        // Get the non-palindromic prefix\n        String nonPalindromicPrefix = string.substring(0, string.length() - longestPalindromicSuffixLength);\n        \n        // Create the palindrome by appending the reverse of the non-palindromic prefix\n        StringBuilder palindrome = new StringBuilder(string);\n        palindrome.append(new StringBuilder(nonPalindromicPrefix).reverse());\n\n        return palindrome.toString();\n    }\n\n    // Helper method to check if a string is a palindrome\n    private boolean isPalindrome(String str) {\n        int left = 0;\n        int right = str.length() - 1;\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        PalindromeMaker pm = new PalindromeMaker();\n        String result = pm.makePalindrome(\"race\");\n        System.out.println(result); // Output: racecar\n    }\n}\n"}
{"task_id": "Java/11", "generation": "class Solution {\n    /**\n    Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    */\n    public String string_xor(String a, String b) {\n        // Ensure both strings are of the same length\n        int length = Math.max(a.length(), b.length());\n        StringBuilder result = new StringBuilder();\n\n        // Pad the shorter string with leading zeros\n        while (a.length() < length) {\n            a = \"0\" + a;\n        }\n        while (b.length() < length) {\n            b = \"0\" + b;\n        }\n\n        // Perform XOR operation\n        for (int i = 0; i < length; i++) {\n            char bitA = a.charAt(i);\n            char bitB = b.charAt(i);\n            // XOR logic: if bits are the same, result is '0', otherwise '1'\n            if (bitA == bitB) {\n                result.append('0');\n            } else {\n                result.append('1');\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.string_xor(\"010\", \"110\")); // Output: \"100\"\n        System.out.println(solution.string_xor(\"1010\", \"0011\")); // Output: \"1001\"\n        System.out.println(solution.string_xor(\"111\", \"000\")); // Output: \"111\"\n    }\n}\n"}
{"task_id": "Java/12", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest(List.of())\n    Optional.empty\n    >>> longest(Arrays.asList(\"a\", \"b\", \"c\"))\n    Optional[a]\n    >>> longest(Arrays.asList(\"a\", \"bb\", \"ccc\"))\n    Optional[ccc]\n    */\n    public Optional<String> longest(List<String> strings) {\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n\n        String longestString = strings.get(0); // Start with the first string\n        for (String str : strings) {\n            if (str.length() > longestString.length()) {\n                longestString = str; // Update if a longer string is found\n            }\n        }\n        \n        return Optional.of(longestString); // Return the longest string wrapped in Optional\n    }\n}\n"}
{"task_id": "Java/13", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    */\n    public int greatest_common_divisor(int a, int b) {\n        // Ensure a and b are non-negative\n        a = Math.abs(a);\n        b = Math.abs(b);\n        \n        // Use the Euclidean algorithm to find the GCD\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.greatest_common_divisor(3, 5)); // Output: 1\n        System.out.println(solution.greatest_common_divisor(25, 15)); // Output: 5\n    }\n}\n"}
{"task_id": "Java/14", "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    /**\n    Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n    */\n    public List<String> all_prefixes(String string) {\n        List<String> prefixes = new ArrayList<>();\n        \n        for (int i = 1; i <= string.length(); i++) {\n            prefixes.add(string.substring(0, i));\n        }\n        \n        return prefixes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.all_prefixes(\"abc\")); // Output: [a, ab, abc]\n    }\n}\n"}
{"task_id": "Java/15", "generation": "class Solution {\n    /**\n    Return a string containing space-delimited numbers starting from 0 up to n inclusive.\n    >>> string_sequence(0)\n    \"0\"\n    >>> string_sequence(5)\n    \"0 1 2 3 4 5\"\n    */\n    public String string_sequence(int n) {\n        StringBuilder result = new StringBuilder();\n        \n        for (int i = 0; i <= n; i++) {\n            result.append(i);\n            if (i < n) {\n                result.append(\" \"); // Add a space after each number except the last one\n            }\n        }\n        \n        return result.toString();\n    }\n}\n"}
{"task_id": "Java/16", "generation": "import java.util.HashSet;\n\nclass Solution {\n    /**\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters(\"xyzXYZ\")\n    3\n    >>> count_distinct_characters(\"Jerry\")\n    4\n    */\n    public int count_distinct_characters(String string) {\n        // Create a HashSet to store distinct characters\n        HashSet<Character> distinctCharacters = new HashSet<>();\n        \n        // Iterate through each character in the string\n        for (char c : string.toCharArray()) {\n            // Convert character to lowercase and add to the set\n            distinctCharacters.add(Character.toLowerCase(c));\n        }\n        \n        // The size of the set is the number of distinct characters\n        return distinctCharacters.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.count_distinct_characters(\"xyzXYZ\")); // Output: 3\n        System.out.println(solution.count_distinct_characters(\"Jerry\"));  // Output: 4\n    }\n}\n"}
{"task_id": "Java/17", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> parse_music(String string) {\n        // Create a list to store the beats\n        List<Integer> beats = new ArrayList<>();\n        \n        // Split the input string by spaces to get individual notes\n        String[] notes = string.split(\" \");\n        \n        // Iterate through each note and determine its beat value\n        for (String note : notes) {\n            switch (note) {\n                case \"o\":\n                    beats.add(4); // whole note\n                    break;\n                case \"o|\":\n                    beats.add(2); // half note\n                    break;\n                case \".|\":\n                    beats.add(1); // quarter note\n                    break;\n                default:\n                    // If the note is not recognized, you can choose to handle it\n                    // For now, we'll just ignore it\n                    break;\n            }\n        }\n        \n        return beats; // Return the list of beats\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.parse_music(\"o o| .| o| o| .| .| .| .| o o\")); // Output: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    }\n}\n"}
{"task_id": "Java/18", "generation": "class Solution {\n    /**\n    Find how many times a given substring can be found in the original string. Count overlapping cases.\n    >>> how_many_times(\"\", \"a\")\n    0\n    >>> how_many_times(\"aaa\", \"a\")\n    3\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3\n    */\n    public int how_many_times(String string, String substring) {\n        if (substring.length() == 0 || string.length() == 0) {\n            return 0; // If either string or substring is empty, return 0\n        }\n\n        int count = 0;\n        int index = 0;\n\n        // Loop through the string to find occurrences of the substring\n        while ((index = string.indexOf(substring, index)) != -1) {\n            count++; // Increment the count for each found occurrence\n            index++; // Move to the next character to allow overlapping matches\n        }\n\n        return count;\n    }\n\n    // Example usage\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.how_many_times(\"\", \"a\")); // Output: 0\n        System.out.println(solution.how_many_times(\"aaa\", \"a\")); // Output: 3\n        System.out.println(solution.how_many_times(\"aaaa\", \"aa\")); // Output: 3\n    }\n}\n"}
{"task_id": "Java/19", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Input is a space-delimited string of numerals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> sort_numbers(\"three one five\")\n    \"one three five\"\n    */\n    public String sort_numbers(String numbers) {\n        // Map of words to their corresponding numeric values\n        Map<String, Integer> wordToNumber = new HashMap<>();\n        wordToNumber.put(\"zero\", 0);\n        wordToNumber.put(\"one\", 1);\n        wordToNumber.put(\"two\", 2);\n        wordToNumber.put(\"three\", 3);\n        wordToNumber.put(\"four\", 4);\n        wordToNumber.put(\"five\", 5);\n        wordToNumber.put(\"six\", 6);\n        wordToNumber.put(\"seven\", 7);\n        wordToNumber.put(\"eight\", 8);\n        wordToNumber.put(\"nine\", 9);\n        \n        // Split the input string into words\n        String[] words = numbers.split(\" \");\n        \n        // Sort the words based on their numeric values\n        Arrays.sort(words, new Comparator<String>() {\n            public int compare(String a, String b) {\n                return Integer.compare(wordToNumber.get(a), wordToNumber.get(b));\n            }\n        });\n        \n        // Join the sorted words back into a single string\n        return String.join(\" \", words);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sort_numbers(\"three one five\")); // Output: \"one three five\"\n        System.out.println(solution.sort_numbers(\"nine eight seven six five four three two one zero\")); // Output: \"zero one two three four five six seven eight nine\"\n    }\n}\n"}
{"task_id": "Java/20", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))\n    [2.0, 2.2]\n    >>> find_closest_elements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0))\n    [2.0, 2.0]\n    */\n    public List<Double> find_closest_elements(List<Double> numbers) {\n        // Step 1: Sort the list\n        Collections.sort(numbers);\n        \n        // Step 2: Initialize variables to track the closest pair\n        double minDiff = Double.MAX_VALUE;\n        List<Double> closestPair = new ArrayList<>();\n        \n        // Step 3: Iterate through the sorted list to find the closest pair\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            double num1 = numbers.get(i);\n            double num2 = numbers.get(i + 1);\n            double diff = num2 - num1; // Since the list is sorted, num2 >= num1\n            \n            if (diff < minDiff) {\n                minDiff = diff;\n                closestPair.clear();\n                closestPair.add(num1);\n                closestPair.add(num2);\n            }\n        }\n        \n        return closestPair;\n    }\n}\n"}
{"task_id": "Java/21", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1.\n    >>> rescale_to_unit(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0))\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    */\n    public List<Double> rescale_to_unit(List<Double> numbers) {\n        // Check if the list has at least two elements\n        if (numbers.size() < 2) {\n            throw new IllegalArgumentException(\"List must contain at least two elements.\");\n        }\n\n        // Find the minimum and maximum values in the list\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n\n        // Create a new list to store the rescaled values\n        List<Double> rescaled = new ArrayList<>();\n\n        // Rescale each number in the list\n        for (Double number : numbers) {\n            double scaledValue = (number - min) / (max - min);\n            rescaled.add(scaledValue);\n        }\n\n        return rescaled;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Double> result = solution.rescale_to_unit(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0));\n        System.out.println(result); // Output: [0.0, 0.25, 0.5, 0.75, 1.0]\n    }\n}\n"}
{"task_id": "Java/22", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Filter given list of any values only for integers\n    >>> filter_integers(Arrays.asList('a', 3.14, 5))\n    [5]\n    >>> filter_integers(Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of()))\n    [1, 2, 3]\n    */\n    public List<Integer> filter_integers(List<Object> values) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (Object value : values) {\n            if (value instanceof Integer) {\n                result.add((Integer) value);\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.filter_integers(Arrays.asList('a', 3.14, 5))); // Output: [5]\n        System.out.println(solution.filter_integers(Arrays.asList(1, 2, 3, \"abc\", new HashMap<>(), new ArrayList<>()))); // Output: [1, 2, 3]\n    }\n}\n"}
{"task_id": "Java/23", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return length of given string\n    >>> strlen(\"\")\n    0\n    >>> strlen(\"abc\")\n    3\n    */\n    public int strlen(String string) {\n        return string.length();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.strlen(\"\")); // Output: 0\n        System.out.println(solution.strlen(\"abc\")); // Output: 3\n        System.out.println(solution.strlen(\"Hello, World!\")); // Output: 13\n    }\n}\n"}
{"task_id": "Java/24", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    */\n    public int largest_divisor(int n) {\n        // Start from n-1 and go down to 1\n        for (int i = n - 1; i > 0; i--) {\n            if (n % i == 0) { // Check if i is a divisor of n\n                return i; // Return the first divisor found\n            }\n        }\n        return 1; // In case n is 1, the largest divisor is 1\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.largest_divisor(15)); // Output: 5\n        System.out.println(solution.largest_divisor(28)); // Output: 14\n        System.out.println(solution.largest_divisor(1));  // Output: 1\n    }\n}\n"}
{"task_id": "Java/25", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    */\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        \n        // Check for number of 2s that divide n\n        while (n % 2 == 0) {\n            factors.add(2);\n            n /= 2;\n        }\n        \n        // n must be odd at this point, so we can skip even numbers\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            // While i divides n, add i and divide n\n            while (n % i == 0) {\n                factors.add(i);\n                n /= i;\n            }\n        }\n        \n        // This condition is to check if n is a prime number greater than 2\n        if (n > 2) {\n            factors.add(n);\n        }\n        \n        return factors;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.factorize(8));   // Output: [2, 2, 2]\n        System.out.println(solution.factorize(25));  // Output: [5, 5]\n        System.out.println(solution.factorize(70));  // Output: [2, 5, 7]\n    }\n}\n"}
{"task_id": "Java/26", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates(Arrays.asList(1, 2, 3, 2, 4))\n    [1, 3, 4]\n    */\n    public List<Integer> remove_duplicates(List<Integer> numbers) {\n        // Step 1: Count occurrences of each number\n        Map<Integer, Long> frequencyMap = numbers.stream()\n            .collect(Collectors.groupingBy(num -> num, Collectors.counting()));\n\n        // Step 2: Filter out numbers that occur more than once\n        List<Integer> result = numbers.stream()\n            .filter(num -> frequencyMap.get(num) == 1)\n            .collect(Collectors.toList());\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> input = Arrays.asList(1, 2, 3, 2, 4);\n        List<Integer> output = solution.remove_duplicates(input);\n        System.out.println(output); // Output: [1, 3, 4]\n    }\n}\n"}
{"task_id": "Java/27", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flip_case(\"Hello\")\n    \"hELLO\"\n    */\n    public String flip_case(String string) {\n        StringBuilder flippedString = new StringBuilder();\n        \n        for (char c : string.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                flippedString.append(Character.toUpperCase(c));\n            } else if (Character.isUpperCase(c)) {\n                flippedString.append(Character.toLowerCase(c));\n            } else {\n                flippedString.append(c); // Append non-alphabetic characters unchanged\n            }\n        }\n        \n        return flippedString.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.flip_case(\"Hello\")); // Output: hELLO\n        System.out.println(solution.flip_case(\"World!\")); // Output: wORLD!\n        System.out.println(solution.flip_case(\"Java123\")); // Output: jAVA123\n    }\n}\n"}
{"task_id": "Java/28", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Concatenate list of strings into a single string\n    >>> concatenate(List.of())\n    \"\"\n    >>> concatenate(Arrays.asList(\"a\", \"b\", \"c\"))\n    \"abc\"\n    */\n    public String concatenate(List<String> strings) {\n        StringBuilder result = new StringBuilder();\n        for (String str : strings) {\n            result.append(str);\n        }\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.concatenate(List.of())); // Output: \"\"\n        System.out.println(solution.concatenate(Arrays.asList(\"a\", \"b\", \"c\"))); // Output: \"abc\"\n        System.out.println(solution.concatenate(Arrays.asList(\"Hello\", \" \", \"World\", \"!\"))); // Output: \"Hello World!\"\n    }\n}\n"}
{"task_id": "Java/29", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix(List.of(), \"a\")\n    []\n    >>> filter_by_prefix(Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\"), \"a\")\n    [\"abc\", \"array\"]\n    */\n    public List<String> filter_by_prefix(List<String> strings, String prefix) {\n        return strings.stream()\n                      .filter(s -> s.startsWith(prefix))\n                      .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.filter_by_prefix(List.of(), \"a\")); // []\n        System.out.println(solution.filter_by_prefix(Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\"), \"a\")); // [\"abc\", \"array\"]\n    }\n}\n"}
{"task_id": "Java/30", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    Return only positive numbers in the list.\n    >>> get_positive(Arrays.asList(-1, 2, -4, 5, 6))\n    [2, 5, 6]\n    >>> get_positive(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n    [5, 3, 2, 3, 9, 123, 1]\n    */\n    public List<Integer> get_positive(List<Integer> l) {\n        return l.stream()\n                .filter(num -> num > 0) // Filter only positive numbers\n                .collect(Collectors.toList()); // Collect the results into a list\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.get_positive(Arrays.asList(-1, 2, -4, 5, 6))); // Output: [2, 5, 6]\n        System.out.println(solution.get_positive(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))); // Output: [5, 3, 2, 3, 9, 123, 1]\n    }\n}\n"}
{"task_id": "Java/31", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    false\n    >>> is_prime(101)\n    true\n    >>> is_prime(11)\n    true\n    >>> is_prime(13441)\n    true\n    >>> is_prime(61)\n    true\n    >>> is_prime(4)\n    false\n    >>> is_prime(1)\n    false\n    */\n    public boolean is_prime(int n) {\n        // Check for numbers less than or equal to 1\n        if (n <= 1) {\n            return false;\n        }\n        // Check for factors from 2 to the square root of n\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false; // Found a divisor, not prime\n            }\n        }\n        return true; // No divisors found, it's prime\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        // Test cases\n        System.out.println(solution.is_prime(6));      // false\n        System.out.println(solution.is_prime(101));    // true\n        System.out.println(solution.is_prime(11));     // true\n        System.out.println(solution.is_prime(13441));  // true\n        System.out.println(solution.is_prime(61));     // true\n        System.out.println(solution.is_prime(4));      // false\n        System.out.println(solution.is_prime(1));      // false\n    }\n}\n"}
{"task_id": "Java/32", "generation": "import java.util.*;\n\nclass Solution {\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n\n    public double polyDerivative(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 1; i < xs.size(); i++) {\n            result += i * xs.get(i) * Math.pow(x, i - 1);\n        }\n        return result;\n    }\n\n    public double find_zero(List<Double> xs) {\n        // Initial guess (can be improved)\n        double x0 = 0.0;\n        double tolerance = 1e-7; // Tolerance for convergence\n        double maxIterations = 1000; // Maximum iterations to prevent infinite loop\n\n        for (int i = 0; i < maxIterations; i++) {\n            double fx = poly(xs, x0);\n            double fpx = polyDerivative(xs, x0);\n\n            // Check if the derivative is zero to avoid division by zero\n            if (Math.abs(fpx) < tolerance) {\n                throw new RuntimeException(\"Derivative is too small; no solution found.\");\n            }\n\n            // Newton-Raphson formula\n            double x1 = x0 - fx / fpx;\n\n            // Check for convergence\n            if (Math.abs(x1 - x0) < tolerance) {\n                return x1;\n            }\n\n            x0 = x1; // Update x0 for the next iteration\n        }\n\n        throw new RuntimeException(\"Maximum iterations reached; no solution found.\");\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.find_zero(Arrays.asList(1.0, 2.0))); // Should print -0.5\n        System.out.println(sol.find_zero(Arrays.asList(-6.0, 11.0, -6.0, 1.0))); // Should print 1.0\n    }\n}\n"}
{"task_id": "Java/33", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> sort_third(List<Integer> l) {\n        // Create a list to hold the values at indices divisible by 3\n        List<Integer> divisibleByThreeValues = new ArrayList<>();\n        \n        // Collect values at indices divisible by 3\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 3 == 0) {\n                divisibleByThreeValues.add(l.get(i));\n            }\n        }\n        \n        // Sort the collected values\n        Collections.sort(divisibleByThreeValues);\n        \n        // Create a new list to hold the result\n        List<Integer> result = new ArrayList<>(l);\n        \n        // Replace values at indices divisible by 3 with sorted values\n        int sortedIndex = 0;\n        for (int i = 0; i < result.size(); i++) {\n            if (i % 3 == 0) {\n                result.set(i, divisibleByThreeValues.get(sortedIndex));\n                sortedIndex++;\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sort_third(Arrays.asList(1, 2, 3))); // [1, 2, 3]\n        System.out.println(solution.sort_third(Arrays.asList(5, 6, 3, 4, 8, 9, 2))); // [2, 6, 3, 4, 8, 9, 5]\n    }\n}\n"}
{"task_id": "Java/34", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Return sorted unique elements in a list\n    >>> unique(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))\n    [0, 2, 3, 5, 9, 123]\n    */\n    public List<Integer> unique(List<Integer> l) {\n        // Create a Set to store unique elements\n        Set<Integer> uniqueSet = new HashSet<>(l);\n        \n        // Convert the Set back to a List\n        List<Integer> uniqueList = new ArrayList<>(uniqueSet);\n        \n        // Sort the List\n        Collections.sort(uniqueList);\n        \n        return uniqueList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> result = solution.unique(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123));\n        System.out.println(result); // Output: [0, 2, 3, 5, 9, 123]\n    }\n}\n"}
{"task_id": "Java/35", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Return maximum element in the list.\n    >>> max_element(Arrays.asList(1, 2, 3))\n    3\n    >>> max_element(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n    123\n    */\n    public int max_element(List<Integer> l) {\n        // Check if the list is empty\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List cannot be null or empty\");\n        }\n        \n        // Use Collections.max to find the maximum element\n        return Collections.max(l);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.max_element(Arrays.asList(1, 2, 3))); // Output: 3\n        System.out.println(solution.max_element(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))); // Output: 123\n    }\n}\n"}
{"task_id": "Java/36", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    */\n    public int fizz_buzz(int n) {\n        int count = 0;\n\n        for (int i = 1; i < n; i++) {\n            if (i % 11 == 0 || i % 13 == 0) {\n                // Convert the number to a string\n                String str = Integer.toString(i);\n                // Count occurrences of '7'\n                for (char c : str.toCharArray()) {\n                    if (c == '7') {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fizz_buzz(50)); // Output: 0\n        System.out.println(solution.fizz_buzz(78)); // Output: 2\n        System.out.println(solution.fizz_buzz(79)); // Output: 3\n    }\n}\n"}
{"task_id": "Java/37", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> sort_even(List<Integer> l) {\n        // List to hold even indexed values\n        List<Integer> evenValues = new ArrayList<>();\n        \n        // Extract even indexed values\n        for (int i = 0; i < l.size(); i += 2) {\n            evenValues.add(l.get(i));\n        }\n        \n        // Sort the even indexed values\n        Collections.sort(evenValues);\n        \n        // Create a new list to hold the result\n        List<Integer> result = new ArrayList<>(l);\n        \n        // Replace even indexed positions with sorted values\n        for (int i = 0; i < evenValues.size(); i++) {\n            result.set(i * 2, evenValues.get(i));\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.sort_even(Arrays.asList(1, 2, 3))); // Output: [1, 2, 3]\n        System.out.println(sol.sort_even(Arrays.asList(5, 6, 3, 4))); // Output: [3, 6, 5, 4]\n    }\n}\n"}
{"task_id": "Java/38", "generation": "class Solution {\n    /**\n    returns encoded string by cycling groups of three characters.\n    */\n    public String encodeCyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(1) + groups.get(i).charAt(0));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    /**\n    takes as input string encoded with encodeCyclic function. Returns decoded string.\n    */\n    public String decode_cyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // reverse the cycling of elements in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                String group = groups.get(i);\n                groups.set(i, group.charAt(group.length() - 1) + group.substring(0, group.length() - 1));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String original = \"abcdefg\";\n        String encoded = solution.encodeCyclic(original);\n        String decoded = solution.decode_cyclic(encoded);\n\n        System.out.println(\"Original: \" + original);\n        System.out.println(\"Encoded: \" + encoded);\n        System.out.println(\"Decoded: \" + decoded);\n    }\n}\n"}
{"task_id": "Java/39", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n     */\n    public int prime_fib(int n) {\n        if (n < 1) {\n            throw new IllegalArgumentException(\"n must be a positive integer.\");\n        }\n\n        List<Integer> primeFibs = new ArrayList<>();\n        int a = 0, b = 1;\n\n        while (primeFibs.size() < n) {\n            int nextFib = a + b;\n            a = b;\n            b = nextFib;\n\n            if (isPrime(nextFib)) {\n                primeFibs.add(nextFib);\n            }\n        }\n\n        return primeFibs.get(n - 1); // n-th prime Fibonacci number (1-indexed)\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        if (num <= 3) return true;\n        if (num % 2 == 0 || num % 3 == 0) return false;\n\n        for (int i = 5; i * i <= num; i += 6) {\n            if (num % i == 0 || num % (i + 2) == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.prime_fib(1)); // 2\n        System.out.println(sol.prime_fib(2)); // 3\n        System.out.println(sol.prime_fib(3)); // 5\n        System.out.println(sol.prime_fib(4)); // 13\n        System.out.println(sol.prime_fib(5)); // 89\n    }\n}\n"}
{"task_id": "Java/40", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))\n    false\n    >>> triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))\n    true\n    >>> triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))\n    false\n    >>> triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))\n    true\n    >>> triples_sum_to_zero(Arrays.asList(1))\n    false\n     */\n    public boolean triples_sum_to_zero(List<Integer> l) {\n        // Convert the list to an array for easier manipulation\n        Integer[] arr = l.toArray(new Integer[0]);\n        Arrays.sort(arr); // Sort the array\n\n        for (int i = 0; i < arr.length - 2; i++) {\n            // Skip duplicates for the first element\n            if (i > 0 && arr[i].equals(arr[i - 1])) {\n                continue;\n            }\n            int left = i + 1;\n            int right = arr.length - 1;\n\n            while (left < right) {\n                int sum = arr[i] + arr[left] + arr[right];\n                if (sum == 0) {\n                    return true; // Found a triplet\n                } else if (sum < 0) {\n                    left++; // Move left pointer to the right\n                } else {\n                    right--; // Move right pointer to the left\n                }\n            }\n        }\n        return false; // No triplet found\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.triples_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // false\n        System.out.println(sol.triples_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // true\n        System.out.println(sol.triples_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // false\n        System.out.println(sol.triples_sum_to_zero(Arrays.asList(2, 4, -5, 3, 9, 7))); // true\n        System.out.println(sol.triples_sum_to_zero(Arrays.asList(1))); // false\n    }\n}\n"}
{"task_id": "Java/41", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right; simultaneously, a different set of n cars\n    are driving right to left. The two sets of cars start out being very far from\n    each other. All cars move at the same speed. Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n    */\n    public int car_race_collision(int n) {\n        // Each car from the left will collide with each car from the right\n        return n * n; // Total collisions = n (left) * n (right)\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n = 5; // Example input\n        int collisions = solution.car_race_collision(n);\n        System.out.println(\"Number of collisions: \" + collisions); // Output: 25\n    }\n}\n"}
{"task_id": "Java/42", "generation": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    Return list with elements incremented by 1.\n    >>> incr_list(Arrays.asList(1, 2, 3))\n    [2, 3, 4]\n    >>> incr_list(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    */\n    public List<Integer> incr_list(List<Integer> l) {\n        return l.stream()\n                .map(n -> n + 1) // Increment each element by 1\n                .collect(Collectors.toList()); // Collect the results into a new list\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.incr_list(Arrays.asList(1, 2, 3))); // Output: [2, 3, 4]\n        System.out.println(solution.incr_list(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))); // Output: [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    }\n}\n"}
{"task_id": "Java/43", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    >>> pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))\n    false\n    >>> pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))\n    false\n    >>> pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))\n    false\n    >>> pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))\n    true\n    >>> pairs_sum_to_zero(Arrays.asList(1))\n    false\n     */\n    public boolean pairs_sum_to_zero(List<Integer> l) {\n        Set<Integer> seen = new HashSet<>();\n        \n        for (Integer num : l) {\n            // Check if the negation of the current number exists in the set\n            if (seen.contains(-num)) {\n                return true; // Found a pair that sums to zero\n            }\n            // Add the current number to the set\n            seen.add(num);\n        }\n        \n        return false; // No pairs found that sum to zero\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, 5, 0))); // false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 3, -2, 1))); // false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1, 2, 3, 7))); // false\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(2, 4, -5, 3, 5, 7))); // true\n        System.out.println(solution.pairs_sum_to_zero(Arrays.asList(1))); // false\n    }\n}\n"}
{"task_id": "Java/44", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    \"22\"\n    >>> change_base(8, 2)\n    \"1000\"\n    >>> change_base(7, 2)\n    \"111\"\n     */\n    public String change_base(int x, int base) {\n        if (x == 0) {\n            return \"0\"; // Handle the case where x is 0\n        }\n        \n        StringBuilder result = new StringBuilder();\n        \n        while (x > 0) {\n            int remainder = x % base; // Get the remainder\n            result.append(remainder); // Append the remainder to the result\n            x /= base; // Divide x by the base\n        }\n        \n        // The digits are collected in reverse order, so we need to reverse the result\n        return result.reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.change_base(8, 3)); // Output: \"22\"\n        System.out.println(solution.change_base(8, 2)); // Output: \"1000\"\n        System.out.println(solution.change_base(7, 2)); // Output: \"111\"\n    }\n}\n"}
{"task_id": "Java/45", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given length of a side and height return area for a triangle.\n    >>> triangle_area(5, 3)\n    7.5\n    */\n    public double triangle_area(double a, double h) {\n        return 0.5 * a * h; // Calculate the area using the formula\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.triangle_area(5, 3)); // Example usage\n    }\n}\n"}
{"task_id": "Java/46", "generation": "class Solution {\n    public int fib4(int n) {\n        // Base cases\n        if (n == 0) return 0;\n        if (n == 1) return 0;\n        if (n == 2) return 2;\n        if (n == 3) return 0;\n\n        // Array to hold the last four values\n        int[] fib4 = new int[4];\n        fib4[0] = 0; // fib4(0)\n        fib4[1] = 0; // fib4(1)\n        fib4[2] = 2; // fib4(2)\n        fib4[3] = 0; // fib4(3)\n\n        // Compute fib4(n) iteratively\n        for (int i = 4; i <= n; i++) {\n            int nextValue = fib4[0] + fib4[1] + fib4[2] + fib4[3];\n            // Shift the values in the array\n            fib4[0] = fib4[1];\n            fib4[1] = fib4[2];\n            fib4[2] = fib4[3];\n            fib4[3] = nextValue;\n        }\n\n        // The result for fib4(n) will be in fib4[3] after the loop\n        return fib4[3];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fib4(5)); // Output: 4\n        System.out.println(solution.fib4(6)); // Output: 8\n        System.out.println(solution.fib4(7)); // Output: 14\n    }\n}\n"}
{"task_id": "Java/47", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Return median of elements in the list l.\n    >>> median(Arrays.asList(3, 1, 2, 4, 5))\n    3\n    >>> median(Arrays.asList(-10, 4, 6, 1000, 10, 20))\n    8.0\n    */\n    public double median(List<Integer> l) {\n        // Step 1: Sort the list\n        Collections.sort(l);\n        \n        // Step 2: Determine the size of the list\n        int size = l.size();\n        \n        // Step 3: Calculate the median\n        if (size % 2 == 1) {\n            // If odd, return the middle element\n            return l.get(size / 2);\n        } else {\n            // If even, return the average of the two middle elements\n            return (l.get(size / 2 - 1) + l.get(size / 2)) / 2.0;\n        }\n    }\n}\n"}
{"task_id": "Java/48", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Checks if given string is a palindrome\n    >>> is_palindrome(\"\")\n    true\n    >>> is_palindrome(\"aba\")\n    true\n    >>> is_palindrome(\"aaaaa\")\n    true\n    >>> is_palindrome(\"zbcd\")\n    false\n    */\n    public boolean is_palindrome(String text) {\n        // A null or empty string is considered a palindrome\n        if (text == null || text.isEmpty()) {\n            return true;\n        }\n\n        int left = 0;\n        int right = text.length() - 1;\n\n        while (left < right) {\n            if (text.charAt(left) != text.charAt(right)) {\n                return false; // Not a palindrome\n            }\n            left++;\n            right--;\n        }\n\n        return true; // It's a palindrome\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.is_palindrome(\"\")); // true\n        System.out.println(solution.is_palindrome(\"aba\")); // true\n        System.out.println(solution.is_palindrome(\"aaaaa\")); // true\n        System.out.println(solution.is_palindrome(\"zbcd\")); // false\n    }\n}\n"}
{"task_id": "Java/49", "generation": "class Solution {\n    /**\n    Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    */\n    public int modp(int n, int p) {\n        if (p == 1) return 0; // Since any number mod 1 is 0\n        long result = 1; // Use long to prevent overflow\n        long base = 2; // We are calculating powers of 2\n\n        // Exponentiation by squaring\n        while (n > 0) {\n            if ((n & 1) == 1) { // If n is odd\n                result = (result * base) % p;\n            }\n            base = (base * base) % p; // Square the base\n            n >>= 1; // Divide n by 2\n        }\n        \n        return (int) result; // Cast back to int before returning\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.modp(3, 5)); // Output: 3\n        System.out.println(sol.modp(1101, 101)); // Output: 2\n        System.out.println(sol.modp(0, 101)); // Output: 1\n        System.out.println(sol.modp(3, 11)); // Output: 8\n        System.out.println(sol.modp(100, 101)); // Output: 1\n    }\n}\n"}
{"task_id": "Java/50", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Returns encoded string by shifting every character by 5 in the alphabet.\n    */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            // Shift character by 5 positions\n            sb.append((char) ('a' + ((ch - 'a' + 5) % 26)));\n        }\n        return sb.toString();\n    }\n\n    /**\n    Takes as input string encoded with encodeShift function. Returns decoded string.\n    */\n    public String decode_shift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            // Shift character back by 5 positions\n            sb.append((char) ('a' + ((ch - 'a' - 5 + 26) % 26)));\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        String original = \"hello\";\n        String encoded = solution.encodeShift(original);\n        String decoded = solution.decode_shift(encoded);\n        \n        System.out.println(\"Original: \" + original);\n        System.out.println(\"Encoded: \" + encoded);\n        System.out.println(\"Decoded: \" + decoded);\n    }\n}\n"}
{"task_id": "Java/51", "generation": "class Solution {\n    /**\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels(\"\")\n    \"\"\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    \"bcdf\\nghjklm\"\n    >>> remove_vowels(\"abcdef\")\n    \"bcdf\"\n    >>> remove_vowels(\"aaaaa\")\n    \"\"\n    >>> remove_vowels(\"aaBAA\")\n    \"B\"\n    >>> remove_vowels(\"zbcd\")\n    \"zbcd\"\n    */\n    public String remove_vowels(String text) {\n        // Define a set of vowels (both lowercase and uppercase)\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u', \n                                                              'A', 'E', 'I', 'O', 'U'));\n        StringBuilder result = new StringBuilder();\n\n        // Iterate through each character in the input string\n        for (char c : text.toCharArray()) {\n            // If the character is not a vowel, append it to the result\n            if (!vowels.contains(c)) {\n                result.append(c);\n            }\n        }\n\n        // Convert StringBuilder to String and return\n        return result.toString();\n    }\n}\n"}
{"task_id": "Java/52", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Return True if all numbers in the list l are below threshold t.\n    >>> below_threshold(Arrays.asList(1, 2, 4, 10), 100)\n    true\n    >>> below_threshold(Arrays.asList(1, 20, 4, 10), 5)\n    false\n    */\n    public boolean below_threshold(List<Integer> l, int t) {\n        for (int num : l) {\n            if (num >= t) {\n                return false; // Found a number that is not below the threshold\n            }\n        }\n        return true; // All numbers are below the threshold\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.below_threshold(Arrays.asList(1, 2, 4, 10), 100)); // true\n        System.out.println(solution.below_threshold(Arrays.asList(1, 20, 4, 10), 5)); // false\n    }\n}\n"}
{"task_id": "Java/53", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    */\n    public int add(int x, int y) {\n        return x + y;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(\"add(2, 3) = \" + solution.add(2, 3)); // Expected output: 5\n        System.out.println(\"add(5, 7) = \" + solution.add(5, 7)); // Expected output: 12\n    }\n}\n"}
{"task_id": "Java/54", "generation": "import java.util.HashSet;\n\nclass Solution {\n    /**\n    Check if two words have the same kind of characters.\n    >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n    true\n    >>> same_chars(\"abcd\", \"dddddddabc\")\n    true\n    >>> same_chars(\"dddddddabc\", \"abcd\")\n    true\n    >>> same_chars(\"eabcd\", \"dddddddabc\")\n    false\n    >>> same_chars(\"abcd\", \"dddddddabce\")\n    false\n    >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n    false\n    */\n    public boolean same_chars(String s0, String s1) {\n        // Create sets to hold unique characters\n        HashSet<Character> set1 = new HashSet<>();\n        HashSet<Character> set2 = new HashSet<>();\n        \n        // Add characters from the first string to set1\n        for (char c : s0.toCharArray()) {\n            set1.add(c);\n        }\n        \n        // Add characters from the second string to set2\n        for (char c : s1.toCharArray()) {\n            set2.add(c);\n        }\n        \n        // Compare the two sets\n        return set1.equals(set2);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // true\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabc\")); // true\n        System.out.println(solution.same_chars(\"dddddddabc\", \"abcd\")); // true\n        System.out.println(solution.same_chars(\"eabcd\", \"dddddddabc\")); // false\n        System.out.println(solution.same_chars(\"abcd\", \"dddddddabce\")); // false\n        System.out.println(solution.same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")); // false\n    }\n}\n"}
{"task_id": "Java/55", "generation": "class Solution {\n    /**\n    Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    */\n    public int fib(int n) {\n        if (n <= 0) {\n            return 0; // Fibonacci of 0 is 0\n        } else if (n == 1) {\n            return 1; // Fibonacci of 1 is 1\n        }\n\n        int a = 0; // F(0)\n        int b = 1; // F(1)\n        int fib = 0;\n\n        for (int i = 2; i <= n; i++) {\n            fib = a + b; // F(n) = F(n-1) + F(n-2)\n            a = b; // Move to the next Fibonacci number\n            b = fib; // Update b to the current Fibonacci number\n        }\n\n        return fib; // Return the n-th Fibonacci number\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fib(10)); // Output: 55\n        System.out.println(solution.fib(1));  // Output: 1\n        System.out.println(solution.fib(8));  // Output: 21\n    }\n}\n"}
{"task_id": "Java/56", "generation": "class Solution {\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0; // Counter to track the balance of brackets\n        \n        for (char ch : brackets.toCharArray()) {\n            if (ch == '<') {\n                balance++; // Increment for opening bracket\n            } else if (ch == '>') {\n                balance--; // Decrement for closing bracket\n            }\n            \n            // If balance goes negative, there are unmatched closing brackets\n            if (balance < 0) {\n                return false;\n            }\n        }\n        \n        // At the end, balance should be zero for all brackets to be matched\n        return balance == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.correct_bracketing(\"<\")); // false\n        System.out.println(solution.correct_bracketing(\"<>\")); // true\n        System.out.println(solution.correct_bracketing(\"<<><>>\")); // true\n        System.out.println(solution.correct_bracketing(\"><<>\")); // false\n    }\n}\n"}
{"task_id": "Java/57", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Return True if list elements are monotonically increasing or decreasing.\n    >>> monotonic(Arrays.asList(1, 2, 4, 20))\n    true\n    >>> monotonic(Arrays.asList(1, 20, 4, 10))\n    false\n    >>> monotonic(Arrays.asList(4, 1, 0, -10))\n    true\n    */\n    public boolean monotonic(List<Integer> l) {\n        if (l.size() < 2) {\n            return true; // A list with 0 or 1 element is trivially monotonic\n        }\n\n        boolean increasing = true;\n        boolean decreasing = true;\n\n        for (int i = 1; i < l.size(); i++) {\n            if (l.get(i) > l.get(i - 1)) {\n                decreasing = false; // If we find an increasing pair, it's not decreasing\n            } else if (l.get(i) < l.get(i - 1)) {\n                increasing = false; // If we find a decreasing pair, it's not increasing\n            }\n        }\n\n        return increasing || decreasing; // Return true if either is still true\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.monotonic(Arrays.asList(1, 2, 4, 20))); // true\n        System.out.println(sol.monotonic(Arrays.asList(1, 20, 4, 10))); // false\n        System.out.println(sol.monotonic(Arrays.asList(4, 1, 0, -10))); // true\n    }\n}\n"}
{"task_id": "Java/58", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Return sorted unique common elements for two lists.\n    >>> common(Arrays.asList(1, 4, 3, 34, 653, 2, 5), Arrays.asList(5, 7, 1, 5, 9, 653, 121))\n    [1, 5, 653]\n    >>> common(Arrays.asList(5, 3, 2, 8), Arrays.asList(3, 2))\n    [2, 3]\n    */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        // Convert lists to sets to eliminate duplicates\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n        \n        // Retain only the common elements\n        set1.retainAll(set2);\n        \n        // Convert the set back to a list\n        List<Integer> commonList = new ArrayList<>(set1);\n        \n        // Sort the list\n        Collections.sort(commonList);\n        \n        return commonList;\n    }\n}\n"}
{"task_id": "Java/59", "generation": "class Solution {\n    /**\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    */\n    public int largest_prime_factor(int n) {\n        int largestFactor = -1;\n\n        // Check for number of 2s that divide n\n        while (n % 2 == 0) {\n            largestFactor = 2;\n            n /= 2;\n        }\n\n        // n must be odd at this point, so we can skip even numbers\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            // While i divides n, update n and largestFactor\n            while (n % i == 0) {\n                largestFactor = i;\n                n /= i;\n            }\n        }\n\n        // This condition is to check if n is a prime number greater than 2\n        if (n > 2) {\n            largestFactor = n;\n        }\n\n        return largestFactor;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.largest_prime_factor(13195)); // Output: 29\n        System.out.println(solution.largest_prime_factor(2048));  // Output: 2\n    }\n}\n"}
{"task_id": "Java/60", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    sum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    */\n    public int sum_to_n(int n) {\n        // Using the formula for the sum of the first n natural numbers\n        return n * (n + 1) / 2;\n    }\n\n    // Main method for testing\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sum_to_n(30));  // Output: 465\n        System.out.println(solution.sum_to_n(100)); // Output: 5050\n        System.out.println(solution.sum_to_n(5));   // Output: 15\n        System.out.println(solution.sum_to_n(10));  // Output: 55\n        System.out.println(solution.sum_to_n(1));   // Output: 1\n    }\n}\n"}
{"task_id": "Java/61", "generation": "class Solution {\n    /**\n    brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"(\")\n    false\n    >>> correct_bracketing(\"()\")\n    true\n    >>> correct_bracketing(\"(()())\")\n    true\n    >>> correct_bracketing(\")(()\")\n    false\n    */\n    public boolean correct_bracketing(String brackets) {\n        int balance = 0; // Initialize a balance counter\n\n        for (char ch : brackets.toCharArray()) {\n            if (ch == '(') {\n                balance++; // Increment for opening bracket\n            } else if (ch == ')') {\n                balance--; // Decrement for closing bracket\n            }\n\n            // If balance goes negative, we have more closing brackets\n            if (balance < 0) {\n                return false; // Invalid bracketing\n            }\n        }\n\n        // At the end, balance should be zero for valid bracketing\n        return balance == 0;\n    }\n}\n"}
{"task_id": "Java/62", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative(Arrays.asList(3, 1, 2, 4, 5))\n    [1, 4, 12, 20]\n    >>> derivative(Arrays.asList(1, 2, 3))\n    [2, 6]\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        List<Integer> result = new ArrayList<>();\n        \n        // Start from index 1 because the derivative of the constant term (index 0) is 0\n        for (int i = 1; i < xs.size(); i++) {\n            // Calculate the derivative coefficient\n            result.add(xs.get(i) * i);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.derivative(Arrays.asList(3, 1, 2, 4, 5))); // Output: [1, 4, 12, 20]\n        System.out.println(sol.derivative(Arrays.asList(1, 2, 3))); // Output: [2, 6]\n    }\n}\n"}
{"task_id": "Java/63", "generation": "import java.util.*;\n\nclass Solution {\n    public int fibfib(int n) {\n        // Handle base cases\n        if (n == 0) return 0;\n        if (n == 1) return 0;\n        if (n == 2) return 1;\n\n        // Create an array to store the fibfib values\n        int[] fibfib = new int[n + 1];\n        fibfib[0] = 0; // fibfib(0)\n        fibfib[1] = 0; // fibfib(1)\n        fibfib[2] = 1; // fibfib(2)\n\n        // Fill the array using the defined relation\n        for (int i = 3; i <= n; i++) {\n            fibfib[i] = fibfib[i - 1] + fibfib[i - 2] + fibfib[i - 3];\n        }\n\n        // Return the n-th fibfib number\n        return fibfib[n];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fibfib(1)); // Output: 0\n        System.out.println(solution.fibfib(5)); // Output: 4\n        System.out.println(solution.fibfib(8)); // Output: 24\n    }\n}\n"}
{"task_id": "Java/64", "generation": "class Solution {\n    public int vowels_count(String s) {\n        // Convert the string to lowercase to handle case insensitivity\n        s = s.toLowerCase();\n        int count = 0;\n        \n        // Get the length of the string\n        int length = s.length();\n        \n        // Iterate through each character in the string\n        for (int i = 0; i < length; i++) {\n            char ch = s.charAt(i);\n            // Check if the character is a vowel\n            if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') {\n                count++;\n            }\n            // Check if the character is 'y' and it's the last character\n            if (ch == 'y' && i == length - 1) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.vowels_count(\"abcde\"));  // Output: 2\n        System.out.println(solution.vowels_count(\"ACEDY\"));  // Output: 3\n        System.out.println(solution.vowels_count(\"sky\"));     // Output: 1\n        System.out.println(solution.vowels_count(\"rhythm\"));  // Output: 0\n    }\n}\n"}
{"task_id": "Java/65", "generation": "class Solution {\n    /**\n    Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    */\n    public String circular_shift(int x, int shift) {\n        // Convert the integer to a string\n        String str = Integer.toString(x);\n        int length = str.length();\n        \n        // If shift is greater than the number of digits, reverse the string\n        if (shift >= length) {\n            return new StringBuilder(str).reverse().toString();\n        }\n        \n        // Calculate the effective shift\n        shift = shift % length;\n        \n        // Perform the circular shift\n        String rightPart = str.substring(length - shift);\n        String leftPart = str.substring(0, length - shift);\n        \n        return rightPart + leftPart;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.circular_shift(12, 1)); // Output: \"21\"\n        System.out.println(solution.circular_shift(12, 2)); // Output: \"12\"\n        System.out.println(solution.circular_shift(12345, 2)); // Output: \"45123\"\n        System.out.println(solution.circular_shift(12345, 5)); // Output: \"54321\"\n        System.out.println(solution.circular_shift(12345, 6)); // Output: \"54321\"\n    }\n}\n"}
{"task_id": "Java/66", "generation": "class Solution {\n    public int digitSum(String s) {\n        int sum = 0; // Initialize sum to 0\n        \n        // Iterate through each character in the string\n        for (char c : s.toCharArray()) {\n            // Check if the character is an uppercase letter\n            if (Character.isUpperCase(c)) {\n                sum += (int) c; // Add the ASCII value of the uppercase letter to the sum\n            }\n        }\n        \n        return sum; // Return the final sum\n    }\n\n    // Example usage\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.digitSum(\"\")); // Output: 0\n        System.out.println(solution.digitSum(\"abAB\")); // Output: 131\n        System.out.println(solution.digitSum(\"abcCd\")); // Output: 67\n        System.out.println(solution.digitSum(\"helloE\")); // Output: 69\n        System.out.println(solution.digitSum(\"woArBld\")); // Output: 131\n        System.out.println(solution.digitSum(\"aAaaaXa\")); // Output: 153\n    }\n}\n"}
{"task_id": "Java/67", "generation": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass Solution {\n    public int fruit_distribution(String s, int n) {\n        // Regular expression to match the number of apples and oranges\n        Pattern pattern = Pattern.compile(\"(\\\\d+) apples and (\\\\d+) oranges\");\n        Matcher matcher = pattern.matcher(s);\n        \n        int apples = 0;\n        int oranges = 0;\n\n        // If the pattern matches, extract the numbers\n        if (matcher.find()) {\n            apples = Integer.parseInt(matcher.group(1));\n            oranges = Integer.parseInt(matcher.group(2));\n        }\n\n        // Calculate the number of mangoes\n        int mangoes = n - apples - oranges;\n        return mangoes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fruit_distribution(\"5 apples and 6 oranges\", 19)); // Output: 8\n        System.out.println(solution.fruit_distribution(\"0 apples and 1 oranges\", 3)); // Output: 2\n        System.out.println(solution.fruit_distribution(\"2 apples and 3 oranges\", 100)); // Output: 95\n        System.out.println(solution.fruit_distribution(\"100 apples and 1 oranges\", 120)); // Output: 19\n    }\n}\n"}
{"task_id": "Java/68", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n        int smallestEven = Integer.MAX_VALUE;\n        int smallestIndex = -1;\n\n        for (int i = 0; i < arr.size(); i++) {\n            int value = arr.get(i);\n            if (value % 2 == 0) { // Check if the number is even\n                if (value < smallestEven) { // Check if it's smaller than the current smallest even\n                    smallestEven = value;\n                    smallestIndex = i; // Update the index\n                }\n            }\n        }\n\n        // If no even number was found, return an empty list\n        if (smallestIndex == -1) {\n            return new ArrayList<>();\n        }\n\n        // Return the smallest even value and its index\n        return Arrays.asList(smallestEven, smallestIndex);\n    }\n}\n"}
{"task_id": "Java/69", "generation": "import java.util.*;\n\nclass Solution {\n    public int search(List<Integer> lst) {\n        // Step 1: Count the frequency of each integer\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        for (int num : lst) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n\n        // Step 2: Find the maximum integer that meets the condition\n        int maxInteger = -1;\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            int value = entry.getKey();\n            int frequency = entry.getValue();\n            // Check if the frequency is greater than or equal to the value\n            if (frequency >= value) {\n                maxInteger = Math.max(maxInteger, value);\n            }\n        }\n\n        // Step 3: Return the result\n        return maxInteger;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.search(Arrays.asList(4, 1, 2, 2, 3, 1))); // Output: 2\n        System.out.println(solution.search(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4))); // Output: 3\n        System.out.println(solution.search(Arrays.asList(5, 5, 4, 4, 4))); // Output: -1\n    }\n}\n"}
{"task_id": "Java/70", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list(Arrays.asList(1, 2, 3, 4)) == Arrays.asList(1, 4, 2, 3)\n    strange_sort_list(Arrays.asList(5, 5, 5, 5)) == Arrays.asList(5, 5, 5, 5)\n    strange_sort_list(Arrays.asList()) == Arrays.asList()\n     */\n    public List<Integer> strange_sort_list(List<Integer> lst) {\n        // Sort the list\n        Collections.sort(lst);\n        \n        List<Integer> result = new ArrayList<>();\n        int left = 0; // Pointer for the minimum values\n        int right = lst.size() - 1; // Pointer for the maximum values\n        \n        // Alternate between minimum and maximum\n        while (left <= right) {\n            if (left == right) {\n                result.add(lst.get(left)); // Add the last remaining element\n            } else {\n                result.add(lst.get(left)); // Add minimum\n                result.add(lst.get(right)); // Add maximum\n            }\n            left++;\n            right--;\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.strange_sort_list(Arrays.asList(1, 2, 3, 4))); // Output: [1, 4, 2, 3]\n        System.out.println(solution.strange_sort_list(Arrays.asList(5, 5, 5, 5))); // Output: [5, 5, 5, 5]\n        System.out.println(solution.strange_sort_list(Arrays.asList())); // Output: []\n    }\n}\n"}
{"task_id": "Java/71", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater\n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    */\n    public double triangle_area(double a, double b, double c) {\n        // Check for valid triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1; // Not a valid triangle\n        }\n\n        // Calculate the semi-perimeter\n        double s = (a + b + c) / 2;\n\n        // Calculate the area using Heron's formula\n        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n\n        // Return the area rounded to 2 decimal points\n        return Math.round(area * 100.0) / 100.0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.triangle_area(3, 4, 5)); // Output: 6.00\n        System.out.println(solution.triangle_area(1, 2, 10)); // Output: -1\n    }\n}\n"}
{"task_id": "Java/72", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean will_it_fly(List<Integer> q, int w) {\n        // Check if the list is palindromic\n        if (!isBalanced(q)) {\n            return false;\n        }\n        \n        // Calculate the sum of the elements\n        int sum = 0;\n        for (int num : q) {\n            sum += num;\n        }\n        \n        // Check if the sum is less than or equal to w\n        return sum <= w;\n    }\n    \n    private boolean isBalanced(List<Integer> q) {\n        int left = 0;\n        int right = q.size() - 1;\n        \n        while (left < right) {\n            if (!q.get(left).equals(q.get(right))) {\n                return false; // Not a palindrome\n            }\n            left++;\n            right--;\n        }\n        \n        return true; // It's a palindrome\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.will_it_fly(Arrays.asList(1, 2), 5)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 1)); // false\n        System.out.println(solution.will_it_fly(Arrays.asList(3, 2, 3), 9)); // true\n        System.out.println(solution.will_it_fly(Arrays.asList(3), 5)); // true\n    }\n}\n"}
{"task_id": "Java/73", "generation": "import java.util.*;\n\nclass Solution {\n    public int smallest_change(List<Integer> arr) {\n        int left = 0;\n        int right = arr.size() - 1;\n        int changes = 0;\n\n        while (left < right) {\n            if (!arr.get(left).equals(arr.get(right))) {\n                changes++;\n            }\n            left++;\n            right--;\n        }\n\n        return changes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6))); // Output: 4\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 4, 3, 2, 2))); // Output: 1\n        System.out.println(solution.smallest_change(Arrays.asList(1, 2, 3, 2, 1))); // Output: 0\n    }\n}\n"}
{"task_id": "Java/74", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> total_match(List<String> lst1, List<String> lst2) {\n        // Calculate total characters in lst1\n        int total1 = 0;\n        for (String str : lst1) {\n            total1 += str.length();\n        }\n\n        // Calculate total characters in lst2\n        int total2 = 0;\n        for (String str : lst2) {\n            total2 += str.length();\n        }\n\n        // Compare totals and return the appropriate list\n        if (total1 < total2) {\n            return lst1;\n        } else {\n            return lst2; // This includes the case where totals are equal\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.total_match(Arrays.asList(), Arrays.asList())); // []\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\"))); // [\"hI\", \"Hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))); // [\"hi\", \"admin\"]\n        System.out.println(solution.total_match(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\"))); // [\"hI\", \"hi\", \"hi\"]\n        System.out.println(solution.total_match(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))); // [\"4\"]\n    }\n}\n"}
{"task_id": "Java/75", "generation": "import java.util.*;\n\nclass Solution {\n    // Function to check if a number is the product of three prime numbers\n    public boolean is_multiply_prime(int a) {\n        // Generate a list of prime numbers less than 100\n        List<Integer> primes = generatePrimesLessThan100();\n        \n        // Check all combinations of three primes\n        for (int i = 0; i < primes.size(); i++) {\n            for (int j = i; j < primes.size(); j++) {\n                for (int k = j; k < primes.size(); k++) {\n                    int product = primes.get(i) * primes.get(j) * primes.get(k);\n                    if (product == a) {\n                        return true; // Found a combination that multiplies to 'a'\n                    }\n                }\n            }\n        }\n        \n        return false; // No combination found\n    }\n\n    // Helper function to generate all prime numbers less than 100\n    private List<Integer> generatePrimesLessThan100() {\n        List<Integer> primes = new ArrayList<>();\n        boolean[] isPrime = new boolean[100];\n        \n        // Initialize all numbers as prime\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false; // 0 and 1 are not prime\n        \n        // Sieve of Eratosthenes\n        for (int i = 2; i < 100; i++) {\n            if (isPrime[i]) {\n                primes.add(i);\n                for (int j = i * 2; j < 100; j += i) {\n                    isPrime[j] = false; // Mark multiples as non-prime\n                }\n            }\n        }\n        \n        return primes;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.is_multiply_prime(30)); // true\n        System.out.println(solution.is_multiply_prime(60)); // true (2 * 3 * 10, but 10 is not prime)\n        System.out.println(solution.is_multiply_prime(100)); // false\n        System.out.println(solution.is_multiply_prime(105)); // true (3 * 5 * 7)\n        System.out.println(solution.is_multiply_prime(1)); // false\n    }\n}\n"}
{"task_id": "Java/76", "generation": "class Solution {\n    public boolean is_simple_power(int x, int n) {\n        // Handle special cases\n        if (n == 1) {\n            return x == 1; // 1^k = 1 for any k\n        }\n        if (x == 1) {\n            return true; // n^0 = 1 for any n\n        }\n        if (n <= 0) {\n            return false; // n must be greater than 0 for valid powers\n        }\n\n        int power = 1; // Start with n^0\n        while (power < x) {\n            power *= n; // Calculate n^k\n        }\n        \n        return power == x; // Check if we found x\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.is_simple_power(1, 4)); // true\n        System.out.println(solution.is_simple_power(2, 2)); // true\n        System.out.println(solution.is_simple_power(8, 2)); // true\n        System.out.println(solution.is_simple_power(3, 2)); // false\n        System.out.println(solution.is_simple_power(3, 1)); // false\n        System.out.println(solution.is_simple_power(5, 3)); // false\n    }\n}\n"}
{"task_id": "Java/77", "generation": "class Solution {\n    public boolean iscube(int a) {\n        // Calculate the cube root of the absolute value of a\n        int cubeRoot = (int) Math.round(Math.cbrt(a));\n        \n        // Check if the cube of the calculated cube root equals a\n        return cubeRoot * cubeRoot * cubeRoot == a;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.iscube(1));   // true\n        System.out.println(solution.iscube(2));   // false\n        System.out.println(solution.iscube(-1));  // true\n        System.out.println(solution.iscube(64));  // true\n        System.out.println(solution.iscube(0));   // true\n        System.out.println(solution.iscube(180)); // false\n    }\n}\n"}
{"task_id": "Java/78", "generation": "import java.util.*;\n\nclass Solution {\n    public int hex_key(String num) {\n        // Set of prime hexadecimal digits\n        Set<Character> primeHexDigits = new HashSet<>(Arrays.asList('2', '3', '5', '7', 'B', 'D'));\n        int count = 0;\n\n        // Iterate through each character in the input string\n        for (char ch : num.toCharArray()) {\n            // Check if the character is in the set of prime hexadecimal digits\n            if (primeHexDigits.contains(ch)) {\n                count++;\n            }\n        }\n\n        return count; // Return the count of prime hexadecimal digits\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.hex_key(\"AB\")); // Output: 1\n        System.out.println(solution.hex_key(\"1077E\")); // Output: 2\n        System.out.println(solution.hex_key(\"ABED1A33\")); // Output: 4\n        System.out.println(solution.hex_key(\"123456789ABCDEF0\")); // Output: 6\n        System.out.println(solution.hex_key(\"2020\")); // Output: 2\n    }\n}\n"}
{"task_id": "Java/79", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n\n    Examples:\n    decimal_to_binary(15)   // returns \"db1111db\"\n    decimal_to_binary(32)   // returns \"db100000db\"\n     */\n    public String decimal_to_binary(int decimal) {\n        // Convert the decimal number to binary string\n        String binaryString = Integer.toBinaryString(decimal);\n        \n        // Format the string with 'db' at the beginning and end\n        return \"db\" + binaryString + \"db\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.decimal_to_binary(15));  // Output: \"db1111db\"\n        System.out.println(solution.decimal_to_binary(32));  // Output: \"db100000db\"\n        System.out.println(solution.decimal_to_binary(0));   // Output: \"db0db\"\n        System.out.println(solution.decimal_to_binary(1));   // Output: \"db1db\"\n        System.out.println(solution.decimal_to_binary(255)); // Output: \"db11111111db\"\n    }\n}\n"}
{"task_id": "Java/80", "generation": "class Solution {\n    public boolean is_happy(String s) {\n        // Check if the length of the string is at least 3\n        if (s.length() < 3) {\n            return false;\n        }\n        \n        // Iterate through the string, checking each group of 3 consecutive characters\n        for (int i = 0; i <= s.length() - 3; i++) {\n            // Get the current group of 3 characters\n            char first = s.charAt(i);\n            char second = s.charAt(i + 1);\n            char third = s.charAt(i + 2);\n            \n            // Check if all three characters are distinct\n            if (first == second || first == third || second == third) {\n                return false; // Found a group of 3 that are not distinct\n            }\n        }\n        \n        // If we passed all checks, the string is happy\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.is_happy(\"a\"));       // false\n        System.out.println(solution.is_happy(\"aa\"));      // false\n        System.out.println(solution.is_happy(\"abcd\"));    // true\n        System.out.println(solution.is_happy(\"aabb\"));    // false\n        System.out.println(solution.is_happy(\"adb\"));     // true\n        System.out.println(solution.is_happy(\"xyy\"));     // false\n    }\n}\n"}
{"task_id": "Java/81", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> numerical_letter_grade(List<Double> grades) {\n        List<String> letterGrades = new ArrayList<>();\n        \n        for (Double gpa : grades) {\n            if (gpa == 4.0) {\n                letterGrades.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letterGrades.add(\"A\");\n            } else if (gpa > 3.3) {\n                letterGrades.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letterGrades.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letterGrades.add(\"B\");\n            } else if (gpa > 2.3) {\n                letterGrades.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letterGrades.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letterGrades.add(\"C\");\n            } else if (gpa > 1.3) {\n                letterGrades.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letterGrades.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letterGrades.add(\"D\");\n            } else if (gpa > 0.0) {\n                letterGrades.add(\"D-\");\n            } else {\n                letterGrades.add(\"E\");\n            }\n        }\n        \n        return letterGrades;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Double> grades = Arrays.asList(4.0, 3.0, 1.7, 2.0, 3.5);\n        List<String> result = solution.numerical_letter_grade(grades);\n        System.out.println(result); // Output: [A+, B+, C-, C, A-]\n    }\n}\n"}
{"task_id": "Java/82", "generation": "class Solution {\n    public boolean prime_length(String string) {\n        int length = string.length();\n        return isPrime(length);\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false; // 0 and 1 are not prime numbers\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false; // num is divisible by i, hence not prime\n            }\n        }\n        return true; // num is prime\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.prime_length(\"Hello\")); // true\n        System.out.println(solution.prime_length(\"abcdcba\")); // true\n        System.out.println(solution.prime_length(\"kittens\")); // true\n        System.out.println(solution.prime_length(\"orange\")); // false\n    }\n}\n"}
{"task_id": "Java/83", "generation": "class Solution {\n    /**\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    */\n    public int starts_one_ends(int n) {\n        if (n == 1) {\n            // For n = 1, the only number is '1'\n            return 1;\n        }\n\n        // Count of n-digit integers that start with '1'\n        int startWithOne = (int) Math.pow(10, n - 1);\n\n        // Count of n-digit integers that end with '1'\n        int endWithOne = 9 * (int) Math.pow(10, n - 2);\n\n        // Count of n-digit integers that start and end with '1'\n        int startAndEndWithOne = (int) Math.pow(10, n - 2);\n\n        // Total count using inclusion-exclusion principle\n        return startWithOne + endWithOne - startAndEndWithOne;\n    }\n}\n"}
{"task_id": "Java/84", "generation": "class Solution {\n    public String solve(int N) {\n        // Step 1: Convert the integer N to a string\n        String numberString = Integer.toString(N);\n        \n        // Step 2: Initialize a sum variable\n        int sum = 0;\n        \n        // Step 3: Iterate through each character in the string\n        for (char digit : numberString.toCharArray()) {\n            // Convert the character to an integer and add to sum\n            sum += Character.getNumericValue(digit);\n        }\n        \n        // Step 4: Convert the sum to binary\n        String binarySum = Integer.toBinaryString(sum);\n        \n        // Step 5: Return the binary representation\n        return binarySum;\n    }\n}\n"}
{"task_id": "Java/85", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add(Arrays.asList(4, 2, 6, 7)) ==> 2\n    */\n    public int add(List<Integer> lst) {\n        int sum = 0;\n        \n        // Iterate through the list\n        for (int i = 0; i < lst.size(); i++) {\n            // Check if the index is odd and the element is even\n            if (i % 2 != 0 && lst.get(i) % 2 == 0) {\n                sum += lst.get(i);\n            }\n        }\n        \n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.add(Arrays.asList(4, 2, 6, 7))); // Output: 2\n        System.out.println(solution.add(Arrays.asList(1, 2, 3, 4, 5))); // Output: 0\n        System.out.println(solution.add(Arrays.asList(10, 15, 20, 25, 30))); // Output: 0\n        System.out.println(solution.add(Arrays.asList(1, 2, 4, 6, 8))); // Output: 6\n    }\n}\n"}
{"task_id": "Java/86", "generation": "import java.util.*;\n\nclass Solution {\n    public String anti_shuffle(String s) {\n        // Split the input string by spaces\n        String[] words = s.split(\"(?<= )|(?= )\"); // This regex keeps the spaces in the result\n        \n        StringBuilder result = new StringBuilder();\n        \n        for (String word : words) {\n            if (word.trim().isEmpty()) {\n                // If the word is just a space, keep it as is\n                result.append(word);\n            } else {\n                // Sort the characters of the word\n                char[] charArray = word.toCharArray();\n                Arrays.sort(charArray);\n                // Append the sorted word to the result\n                result.append(new String(charArray));\n            }\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.anti_shuffle(\"Hi\")); // Output: \"Hi\"\n        System.out.println(solution.anti_shuffle(\"hello\")); // Output: \"ehllo\"\n        System.out.println(solution.anti_shuffle(\"Hello World!!!\")); // Output: \"Hello !!!Wdlor\"\n    }\n}\n"}
{"task_id": "Java/87", "generation": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> get_row(List<List<Integer>> lst, int x) {\n        List<List<Integer>> coordinates = new ArrayList<>();\n\n        // Iterate through each row\n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = lst.get(i);\n            // Iterate through each element in the row\n            for (int j = 0; j < row.size(); j++) {\n                // Check if the current element matches x\n                if (row.get(j) == x) {\n                    // Add the coordinates to the list\n                    coordinates.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        // Sort the coordinates first by row (ascending) and then by column (descending)\n        coordinates.sort((a, b) -> {\n            if (!a.get(0).equals(b.get(0))) {\n                return a.get(0) - b.get(0); // Sort by row\n            } else {\n                return b.get(1) - a.get(1); // Sort by column (descending)\n            }\n        });\n\n        return coordinates;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.get_row(Arrays.asList(\n            Arrays.asList(1, 2, 3, 4, 5, 6),\n            Arrays.asList(1, 2, 3, 4, 1, 6),\n            Arrays.asList(1, 2, 3, 4, 5, 1)\n        ), 1)); // Output: [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n\n        System.out.println(solution.get_row(new ArrayList<>(), 1)); // Output: []\n\n        System.out.println(solution.get_row(Arrays.asList(\n            new ArrayList<>(),\n            Arrays.asList(1),\n            Arrays.asList(1, 2, 3)\n        ), 3)); // Output: [[2, 2]]\n    }\n}\n"}
{"task_id": "Java/88", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> array) {\n        // Step 1: Check if the array is empty\n        if (array.isEmpty()) {\n            return new ArrayList<>();\n        }\n        \n        // Step 2: Check if the array has only one element\n        if (array.size() == 1) {\n            return new ArrayList<>(array);\n        }\n        \n        // Step 3: Calculate the sum of the first and last elements\n        int first = array.get(0);\n        int last = array.get(array.size() - 1);\n        int sum = first + last;\n        \n        // Step 4: Sort the array based on the sum\n        List<Integer> sortedArray = new ArrayList<>(array); // Create a copy of the original array\n        if (sum % 2 == 0) {\n            // Even sum: sort in descending order\n            Collections.sort(sortedArray, Collections.reverseOrder());\n        } else {\n            // Odd sum: sort in ascending order\n            Collections.sort(sortedArray);\n        }\n        \n        // Step 5: Return the sorted array\n        return sortedArray;\n    }\n}\n"}
{"task_id": "Java/89", "generation": "class Solution {\n    public String encrypt(String s) {\n        StringBuilder encrypted = new StringBuilder();\n        \n        for (char c : s.toCharArray()) {\n            // Check if the character is a lowercase letter\n            if (c >= 'a' && c <= 'z') {\n                // Shift the character by 4 positions\n                char shifted = (char) ((c - 'a' + 4) % 26 + 'a');\n                encrypted.append(shifted);\n            } else {\n                // If it's not a lowercase letter, we can choose to ignore it or handle it differently\n                // For this implementation, we'll ignore non-lowercase letters\n                // encrypted.append(c); // Uncomment this line if you want to keep non-lowercase letters\n            }\n        }\n        \n        return encrypted.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.encrypt(\"hi\")); // Output: \"lm\"\n        System.out.println(solution.encrypt(\"asdfghjkl\")); // Output: \"ewhjklnop\"\n        System.out.println(solution.encrypt(\"gf\")); // Output: \"kj\"\n        System.out.println(solution.encrypt(\"et\")); // Output: \"ix\"\n    }\n}\n"}
{"task_id": "Java/90", "generation": "import java.util.*;\n\nclass Solution {\n    public Optional<Integer> next_smallest(List<Integer> lst) {\n        // Use a TreeSet to store unique elements in sorted order\n        TreeSet<Integer> uniqueElements = new TreeSet<>(lst);\n        \n        // Check if there are at least two unique elements\n        if (uniqueElements.size() < 2) {\n            return Optional.empty();\n        }\n        \n        // Get the second smallest element\n        Iterator<Integer> iterator = uniqueElements.iterator();\n        iterator.next(); // Skip the smallest element\n        return Optional.of(iterator.next()); // Return the second smallest element\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.next_smallest(Arrays.asList(1, 2, 3, 4, 5))); // Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList(5, 1, 4, 3, 2))); // Optional[2]\n        System.out.println(solution.next_smallest(Arrays.asList())); // Optional.empty\n        System.out.println(solution.next_smallest(Arrays.asList(1, 1))); // Optional.empty\n    }\n}\n"}
{"task_id": "Java/91", "generation": "import java.util.*;\n\nclass Solution {\n    public int is_bored(String S) {\n        // Split the string into sentences using the specified delimiters\n        String[] sentences = S.split(\"[.!?]\");\n        int boredomCount = 0;\n\n        // Iterate through each sentence\n        for (String sentence : sentences) {\n            // Trim whitespace from the sentence\n            String trimmedSentence = sentence.trim();\n            // Check if the sentence starts with \"I\"\n            if (trimmedSentence.startsWith(\"I\")) {\n                boredomCount++;\n            }\n        }\n\n        return boredomCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.is_bored(\"Hello world\")); // Output: 0\n        System.out.println(solution.is_bored(\"The sky is blue. The sun is shining. I love this weather\")); // Output: 1\n        System.out.println(solution.is_bored(\"I am happy! Are you? I hope so.\")); // Output: 2\n    }\n}\n"}
{"task_id": "Java/92", "generation": "class Solution {\n    /**\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n\n    Examples\n    any_int(5, 2, 7) -> true\n\n    any_int(3, 2, 2) -> false\n\n    any_int(3, -2, 1) -> true\n\n    any_int(3.6, -2.2, 2) -> false\n     */\n    public boolean any_int(Object x, Object y, Object z) {\n        // Check if all inputs are instances of Integer\n        if (x instanceof Integer && y instanceof Integer && z instanceof Integer) {\n            int a = (Integer) x;\n            int b = (Integer) y;\n            int c = (Integer) z;\n\n            // Check if any number is equal to the sum of the other two\n            return (a == b + c) || (b == a + c) || (c == a + b);\n        }\n        // If any of the inputs is not an integer, return false\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.any_int(5, 2, 7)); // true\n        System.out.println(solution.any_int(3, 2, 2)); // false\n        System.out.println(solution.any_int(3, -2, 1)); // true\n        System.out.println(solution.any_int(3.6, -2.2, 2)); // false\n    }\n}\n"}
{"task_id": "Java/93", "generation": "class Solution {\n    public String encode(String message) {\n        StringBuilder encodedMessage = new StringBuilder();\n        \n        for (char ch : message.toCharArray()) {\n            // Check if the character is a letter\n            if (Character.isLetter(ch)) {\n                // Swap case\n                char swappedCase = Character.isUpperCase(ch) ? Character.toLowerCase(ch) : Character.toUpperCase(ch);\n                \n                // Replace vowels\n                if (\"aeiouAEIOU\".indexOf(swappedCase) != -1) {\n                    // Calculate the new character that is 2 places ahead\n                    char newChar = (char) (swappedCase + 2);\n                    // Handle wrap-around for 'y' and 'Y'\n                    if (swappedCase == 'y') newChar = 'a';\n                    if (swappedCase == 'Y') newChar = 'A';\n                    // Append the new character\n                    encodedMessage.append(newChar);\n                } else {\n                    // Append the swapped case character\n                    encodedMessage.append(swappedCase);\n                }\n            } else {\n                // If it's not a letter, just append it as is\n                encodedMessage.append(ch);\n            }\n        }\n        \n        return encodedMessage.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.encode(\"test\")); // \"TGST\"\n        System.out.println(solution.encode(\"This is a message\")); // \"tHKS KS C MGSSCGG\"\n    }\n}\n"}
{"task_id": "Java/94", "generation": "import java.util.*;\n\nclass Solution {\n    // Method to check if a number is prime\n    private boolean isPrime(int num) {\n        if (num <= 1) return false; // 0 and 1 are not prime\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) return false; // Found a divisor, not prime\n        }\n        return true; // No divisors found, it's prime\n    }\n\n    // Method to calculate the sum of digits of a number\n    private int sumOfDigits(int num) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10; // Add the last digit\n            num /= 10; // Remove the last digit\n        }\n        return sum;\n    }\n\n    // Main method to find the largest prime and return the sum of its digits\n    public int largestPrimeDigitSum(List<Integer> lst) {\n        int largestPrime = -1; // Initialize to -1 to indicate no prime found\n\n        // Iterate through the list to find the largest prime\n        for (int num : lst) {\n            if (isPrime(num) && num > largestPrime) {\n                largestPrime = num; // Update largest prime found\n            }\n        }\n\n        // If no prime was found, return 0 or handle as needed\n        if (largestPrime == -1) {\n            return 0; // or throw an exception, or return some other value\n        }\n\n        // Calculate and return the sum of digits of the largest prime\n        return sumOfDigits(largestPrime);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.largestPrimeDigitSum(Arrays.asList(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3))); // Output: 10\n        System.out.println(solution.largestPrimeDigitSum(Arrays.asList(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1))); // Output: 25\n        System.out.println(solution.largestPrimeDigitSum(Arrays.asList(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3))); // Output: 13\n        System.out.println(solution.largestPrimeDigitSum(Arrays.asList(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6))); // Output: 11\n        System.out.println(solution.largestPrimeDigitSum(Arrays.asList(0, 81, 12, 3, 1, 21))); // Output: 3\n        System.out.println(solution.largestPrimeDigitSum(Arrays.asList(0, 8, 1, 2, 1, 7))); // Output: 7\n    }\n}\n"}
{"task_id": "Java/95", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean check_dict_case(Map<Object, Object> dict) {\n        // Check if the map is empty\n        if (dict.isEmpty()) {\n            return false;\n        }\n\n        boolean allLowerCase = true;\n        boolean allUpperCase = true;\n\n        for (Object key : dict.keySet()) {\n            // Check if the key is a String\n            if (!(key instanceof String)) {\n                return false;\n            }\n\n            String strKey = (String) key;\n\n            // Check if the key is in lower case\n            if (!strKey.equals(strKey.toLowerCase())) {\n                allLowerCase = false;\n            }\n\n            // Check if the key is in upper case\n            if (!strKey.equals(strKey.toUpperCase())) {\n                allUpperCase = false;\n            }\n        }\n\n        // Return true if all keys are either lower case or upper case\n        return allLowerCase || allUpperCase;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", \"b\", \"banana\"))); // True\n        System.out.println(solution.check_dict_case(Map.of(\"a\", \"apple\", \"A\", \"banana\", \"B\", \"banana\"))); // False\n        System.out.println(solution.check_dict_case(Map.of(8, \"banana\", \"a\", \"apple\"))); // False\n        System.out.println(solution.check_dict_case(Map.of(\"Name\", \"John\", \"Age\", \"36\", \"City\", \"Houston\"))); // False\n        System.out.println(solution.check_dict_case(Map.of(\"STATE\", \"NC\", \"ZIP\", \"12345\"))); // True\n    }\n}\n"}
{"task_id": "Java/96", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> count_up_to(int n) {\n        List<Integer> primes = new ArrayList<>();\n        \n        for (int i = 2; i < n; i++) {\n            if (isPrime(i)) {\n                primes.add(i);\n            }\n        }\n        \n        return primes;\n    }\n    \n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.count_up_to(5));  // Output: [2, 3]\n        System.out.println(solution.count_up_to(11)); // Output: [2, 3, 5, 7]\n        System.out.println(solution.count_up_to(0));  // Output: []\n        System.out.println(solution.count_up_to(20)); // Output: [2, 3, 5, 7, 11, 13, 17, 19]\n        System.out.println(solution.count_up_to(1));  // Output: []\n        System.out.println(solution.count_up_to(18)); // Output: [2, 3, 5, 7, 11, 13, 17]\n    }\n}\n"}
{"task_id": "Java/97", "generation": "class Solution {\n    /**\n    Complete the function that takes two integers and returns\n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15) should return 20.\n     */\n    public int multiply(int a, int b) {\n        // Get the unit digits of both numbers\n        int unitDigitA = Math.abs(a) % 10; // Use abs to handle negative numbers\n        int unitDigitB = Math.abs(b) % 10; // Use abs to handle negative numbers\n        \n        // Return the product of the unit digits\n        return unitDigitA * unitDigitB;\n    }\n}\n"}
{"task_id": "Java/98", "generation": "class Solution {\n    /**\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper(\"aBCdEf\") returns 1\n    count_upper(\"abcdefg\") returns 0\n    count_upper(\"dBBE\") returns 0\n    */    \n    public int count_upper(String s) {\n        int count = 0;\n        // Define a set of uppercase vowels\n        Set<Character> uppercaseVowels = new HashSet<>(Arrays.asList('A', 'E', 'I', 'O', 'U'));\n        \n        // Loop through the string, checking only even indices\n        for (int i = 0; i < s.length(); i += 2) {\n            char currentChar = s.charAt(i);\n            // Check if the character is an uppercase vowel\n            if (uppercaseVowels.contains(currentChar)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n}\n"}
{"task_id": "Java/99", "generation": "import java.util.*;\n\nclass Solution {\n    public int closest_integer(String value) {\n        // Parse the string to a double\n        double number = Double.parseDouble(value);\n        \n        // Get the floor and ceil values\n        int lower = (int) Math.floor(number);\n        int upper = (int) Math.ceil(number);\n        \n        // Calculate the distances\n        double distanceToLower = Math.abs(number - lower);\n        double distanceToUpper = Math.abs(number - upper);\n        \n        // Determine which integer to return\n        if (distanceToLower < distanceToUpper) {\n            return lower; // Closer to lower\n        } else if (distanceToUpper < distanceToLower) {\n            return upper; // Closer to upper\n        } else {\n            // Equidistant case: round away from zero\n            if (number > 0) {\n                return upper; // Round up for positive numbers\n            } else {\n                return lower; // Round down for negative numbers\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.closest_integer(\"10\"));    // Output: 10\n        System.out.println(solution.closest_integer(\"15.3\"));  // Output: 15\n        System.out.println(solution.closest_integer(\"14.5\"));  // Output: 15\n        System.out.println(solution.closest_integer(\"-14.5\")); // Output: -15\n        System.out.println(solution.closest_integer(\"0.5\"));   // Output: 1\n        System.out.println(solution.closest_integer(\"-0.5\"));  // Output: -1\n    }\n}\n"}
{"task_id": "Java/100", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> make_a_pile(int n) {\n        List<Integer> stones = new ArrayList<>();\n        \n        for (int i = 0; i < n; i++) {\n            // Calculate the number of stones for the current level\n            int stonesInLevel;\n            if (n % 2 == 0) { // n is even\n                stonesInLevel = n + 2 * i; // next even number\n            } else { // n is odd\n                stonesInLevel = n + 2 * i; // next odd number\n            }\n            stones.add(stonesInLevel);\n        }\n        \n        return stones;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.make_a_pile(3)); // Output: [3, 5, 7]\n        System.out.println(solution.make_a_pile(4)); // Output: [4, 6, 8, 10]\n    }\n}\n"}
{"task_id": "Java/101", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\").equals(Arrays.asList(\"Hi\", \"my\", \"name\", \"is\", \"John\"))\n    words_string(\"One, two, three, four, five, six\").equals(Arrays.asList(\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"))\n    */\n    public List<String> words_string(String s) {\n        // Split the string by commas and spaces using regex\n        String[] wordsArray = s.split(\"[,\\\\s]+\");\n        \n        // Convert the array to a List and return it\n        return Arrays.asList(wordsArray);\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.words_string(\"Hi, my name is John\")); // Output: [Hi, my, name, is, John]\n        System.out.println(solution.words_string(\"One, two, three, four, five, six\")); // Output: [One, two, three, four, five, six]\n    }\n}\n"}
{"task_id": "Java/102", "generation": "class Solution {\n    public int choose_num(int x, int y) {\n        // Check if y is less than x\n        if (y < x) {\n            return -1;\n        }\n        \n        // Find the largest even number in the range [x, y]\n        if (y % 2 == 0) {\n            // y is even\n            return (y >= x) ? y : -1;\n        } else {\n            // y is odd, check y - 1\n            int largestEven = y - 1;\n            return (largestEven >= x) ? largestEven : -1;\n        }\n    }\n}\n"}
{"task_id": "Java/103", "generation": "import java.util.*;\n\nclass Solution {\n    public Object rounded_avg(int n, int m) {\n        // Check if n is greater than m\n        if (n > m) {\n            return -1;\n        }\n\n        // Calculate the average\n        double average = (n + m) / 2.0;\n        int roundedAverage = (int) Math.round(average);\n\n        // Convert to binary\n        return Integer.toBinaryString(roundedAverage);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.rounded_avg(1, 5)); // Output: \"11\"\n        System.out.println(solution.rounded_avg(7, 5)); // Output: -1\n        System.out.println(solution.rounded_avg(10, 20)); // Output: \"1111\"\n        System.out.println(solution.rounded_avg(20, 33)); // Output: \"11011\"\n    }\n}\n"}
{"task_id": "Java/104", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> unique_digits(List<Integer> x) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (Integer num : x) {\n            if (containsEvenDigit(num)) {\n                continue; // Skip numbers with even digits\n            }\n            result.add(num);\n        }\n        \n        Collections.sort(result); // Sort the result list in increasing order\n        return result;\n    }\n    \n    private boolean containsEvenDigit(int num) {\n        while (num > 0) {\n            int digit = num % 10; // Get the last digit\n            if (digit % 2 == 0) { // Check if the digit is even\n                return true; // Found an even digit\n            }\n            num /= 10; // Remove the last digit\n        }\n        return false; // No even digits found\n    }\n    \n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.unique_digits(Arrays.asList(15, 33, 1422, 1))); // Output: [1, 15, 33]\n        System.out.println(sol.unique_digits(Arrays.asList(152, 323, 1422, 10))); // Output: []\n    }\n}\n"}
{"task_id": "Java/105", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> by_length(List<Integer> arr) {\n        // Step 1: Filter numbers between 1 and 9\n        List<Integer> filtered = new ArrayList<>();\n        for (Integer num : arr) {\n            if (num >= 1 && num <= 9) {\n                filtered.add(num);\n            }\n        }\n\n        // Step 2: Sort the filtered list\n        Collections.sort(filtered);\n\n        // Step 3: Reverse the sorted list\n        Collections.reverse(filtered);\n\n        // Step 4: Map numbers to their corresponding names\n        String[] names = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n        List<String> result = new ArrayList<>();\n        for (Integer num : filtered) {\n            result.add(names[num]);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Example test cases\n        System.out.println(solution.by_length(Arrays.asList(2, 1, 1, 4, 5, 8, 2, 3))); // [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n        System.out.println(solution.by_length(Arrays.asList())); // []\n        System.out.println(solution.by_length(Arrays.asList(1, -1, 55))); // [\"One\"]\n    }\n}\n"}
{"task_id": "Java/106", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                // Calculate factorial of i\n                result.add(factorial(i));\n            } else {\n                // Calculate sum of numbers from 1 to i\n                result.add(sumTo(i));\n            }\n        }\n        \n        return result;\n    }\n    \n    private int factorial(int num) {\n        int fact = 1;\n        for (int j = 1; j <= num; j++) {\n            fact *= j;\n        }\n        return fact;\n    }\n    \n    private int sumTo(int num) {\n        return (num * (num + 1)) / 2; // Using the formula for the sum of the first n natural numbers\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.f(5)); // Output: [1, 2, 6, 24, 15]\n    }\n}\n"}
{"task_id": "Java/107", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> even_odd_palindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n\n        // Create a list to hold the result\n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n        return result;\n    }\n\n    // Helper method to check if a number is a palindrome\n    private boolean isPalindrome(int num) {\n        int original = num;\n        int reversed = 0;\n\n        while (num > 0) {\n            int digit = num % 10;\n            reversed = reversed * 10 + digit;\n            num /= 10;\n        }\n\n        return original == reversed;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.even_odd_palindrome(3));  // Output: [1, 2]\n        System.out.println(solution.even_odd_palindrome(12)); // Output: [4, 6]\n    }\n}\n"}
{"task_id": "Java/108", "generation": "import java.util.*;\n\nclass Solution {\n    public int count_nums(List<Integer> arr) {\n        int count = 0;\n        \n        for (int num : arr) {\n            if (sumOfDigits(num) > 0) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n    \n    private int sumOfDigits(int num) {\n        int sum = 0;\n        boolean isNegative = num < 0;\n        num = Math.abs(num); // Work with the absolute value for digit extraction\n        \n        // Calculate the sum of digits\n        while (num > 0) {\n            sum += num % 10; // Add the last digit\n            num /= 10; // Remove the last digit\n        }\n        \n        // If the original number was negative, subtract twice the first digit\n        if (isNegative) {\n            // The first digit is the last digit of the absolute value\n            int firstDigit = Integer.parseInt(Integer.toString(Math.abs(num)).substring(0, 1));\n            sum -= 2 * firstDigit; // Adjust for the signed first digit\n        }\n        \n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.count_nums(Arrays.asList())); // Output: 0\n        System.out.println(sol.count_nums(Arrays.asList(-1, 11, -11))); // Output: 1\n        System.out.println(sol.count_nums(Arrays.asList(1, 1, 2))); // Output: 3\n    }\n}\n"}
{"task_id": "Java/109", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean move_one_ball(List<Integer> arr) {\n        // If the array is empty, return true\n        if (arr.isEmpty()) {\n            return true;\n        }\n\n        int n = arr.size();\n        int breakCount = 0;\n\n        // Loop through the array to count breaks\n        for (int i = 0; i < n; i++) {\n            // Compare current element with the next element (circularly)\n            if (arr.get(i) > arr.get((i + 1) % n)) {\n                breakCount++;\n            }\n        }\n\n        // If there are 0 or 1 breaks, it's possible to sort the array\n        return breakCount <= 1;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.move_one_ball(Arrays.asList(3, 4, 5, 1, 2))); // true\n        System.out.println(sol.move_one_ball(Arrays.asList(3, 5, 4, 1, 2))); // false\n    }\n}\n"}
{"task_id": "Java/110", "generation": "import java.util.*;\n\nclass Solution {\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        int oddCountInLst1 = 0;\n        int evenCountInLst2 = 0;\n\n        // Count odd numbers in lst1\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                oddCountInLst1++;\n            }\n        }\n\n        // Count even numbers in lst2\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                evenCountInLst2++;\n            }\n        }\n\n        // Check if we can replace all odd numbers in lst1 with even numbers from lst2\n        if (oddCountInLst1 <= evenCountInLst2) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n\n    // Example usage\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4))); // Output: \"YES\"\n        System.out.println(solution.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4))); // Output: \"NO\"\n    }\n}\n"}
{"task_id": "Java/111", "generation": "import java.util.*;\n\nclass Solution {\n    public Map<String, Integer> histogram(String test) {\n        // Create a map to store the frequency of each letter\n        Map<String, Integer> frequencyMap = new HashMap<>();\n        \n        // Split the input string by spaces to get individual letters\n        String[] letters = test.split(\" \");\n        \n        // Count the occurrences of each letter\n        for (String letter : letters) {\n            if (!letter.isEmpty()) { // Check for empty strings\n                frequencyMap.put(letter, frequencyMap.getOrDefault(letter, 0) + 1);\n            }\n        }\n        \n        // Find the maximum occurrence count\n        int maxCount = 0;\n        for (int count : frequencyMap.values()) {\n            maxCount = Math.max(maxCount, count);\n        }\n        \n        // Create a result map for letters with the maximum count\n        Map<String, Integer> result = new HashMap<>();\n        for (Map.Entry<String, Integer> entry : frequencyMap.entrySet()) {\n            if (entry.getValue() == maxCount) {\n                result.put(entry.getKey(), entry.getValue());\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.histogram(\"a b c\")); // {\"a\": 1, \"b\": 1, \"c\": 1}\n        System.out.println(solution.histogram(\"a b b a\")); // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"a b c a b\")); // {\"a\": 2, \"b\": 2}\n        System.out.println(solution.histogram(\"b b b b a\")); // {\"b\": 4}\n        System.out.println(solution.histogram(\"\")); // {}\n    }\n}\n"}
{"task_id": "Java/112", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Object> reverse_delete(String s, String c) {\n        // Create a set of characters to remove\n        Set<Character> charsToRemove = new HashSet<>();\n        for (char ch : c.toCharArray()) {\n            charsToRemove.add(ch);\n        }\n\n        // Build the result string by excluding characters in charsToRemove\n        StringBuilder result = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (!charsToRemove.contains(ch)) {\n                result.append(ch);\n            }\n        }\n\n        // Convert StringBuilder to String\n        String resultString = result.toString();\n\n        // Check if the result string is a palindrome\n        boolean isPalindrome = isPalindrome(resultString);\n\n        // Prepare the result as a list\n        List<Object> resultList = new ArrayList<>();\n        resultList.add(resultString);\n        resultList.add(isPalindrome);\n\n        return resultList;\n    }\n\n    private boolean isPalindrome(String str) {\n        int left = 0;\n        int right = str.length() - 1;\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.reverse_delete(\"abcde\", \"ae\")); // Output: [\"bcd\", false]\n        System.out.println(solution.reverse_delete(\"abcdef\", \"b\")); // Output: [\"acdef\", false]\n        System.out.println(solution.reverse_delete(\"abcdedcba\", \"ab\")); // Output: [\"cdedc\", true]\n    }\n}\n"}
{"task_id": "Java/113", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> odd_count(List<String> lst) {\n        List<String> result = new ArrayList<>();\n        \n        for (int i = 0; i < lst.size(); i++) {\n            String str = lst.get(i);\n            int oddCount = 0;\n            \n            // Count the number of odd digits in the string\n            for (char ch : str.toCharArray()) {\n                if ((ch - '0') % 2 != 0) { // Check if the digit is odd\n                    oddCount++;\n                }\n            }\n            \n            // Create the output string with the count of odd digits\n            String output = String.format(\"the number of odd elements %dn the str%ng %d of the %dnput.\", \n                                           oddCount, oddCount, oddCount);\n            result.add(output);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.odd_count(Arrays.asList(\"1234567\"))); // [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n        System.out.println(solution.odd_count(Arrays.asList(\"3\", \"11111111\"))); // [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    }\n}\n"}
{"task_id": "Java/114", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum(Arrays.asList(2, 3, 4, 1, 2, 4)) == 1\n    minSubArraySum(Arrays.asList(-1, -2, -3)) == -6\n    */\n    public int minSubArraySum(List<Integer> nums) {\n        // Initialize variables\n        int currentSum = 0;\n        int minSum = Integer.MAX_VALUE;\n\n        // Iterate through the list\n        for (int num : nums) {\n            // Update the current sum\n            currentSum += num;\n\n            // Update the minimum sum if the current sum is less\n            if (currentSum < minSum) {\n                minSum = currentSum;\n            }\n\n            // If current sum is positive, reset it to 0\n            if (currentSum > 0) {\n                currentSum = 0;\n            }\n        }\n\n        return minSum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.minSubArraySum(Arrays.asList(2, 3, 4, 1, 2, 4))); // Output: 1\n        System.out.println(solution.minSubArraySum(Arrays.asList(-1, -2, -3))); // Output: -6\n    }\n}\n"}
{"task_id": "Java/115", "generation": "import java.util.*;\n\nclass Solution {\n    public int max_fill(List<List<Integer>> grid, int capacity) {\n        int totalLowerings = 0;\n\n        // Iterate through each well (row in the grid)\n        for (List<Integer> well : grid) {\n            int waterUnits = 0;\n\n            // Count the number of water units (1's) in the current well\n            for (int water : well) {\n                if (water == 1) {\n                    waterUnits++;\n                }\n            }\n\n            // Calculate the number of times we need to lower the bucket for this well\n            if (waterUnits > 0) {\n                totalLowerings += (waterUnits + capacity - 1) / capacity; // This is equivalent to Math.ceil(waterUnits / capacity)\n            }\n        }\n\n        return totalLowerings;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Example 1\n        List<List<Integer>> grid1 = Arrays.asList(\n            Arrays.asList(0, 0, 1, 0),\n            Arrays.asList(0, 1, 0, 0),\n            Arrays.asList(1, 1, 1, 1)\n        );\n        int capacity1 = 1;\n        System.out.println(solution.max_fill(grid1, capacity1)); // Output: 6\n\n        // Example 2\n        List<List<Integer>> grid2 = Arrays.asList(\n            Arrays.asList(0, 0, 1, 1),\n            Arrays.asList(0, 0, 0, 0),\n            Arrays.asList(1, 1, 1, 1),\n            Arrays.asList(0, 1, 1, 1)\n        );\n        int capacity2 = 2;\n        System.out.println(solution.max_fill(grid2, capacity2)); // Output: 5\n\n        // Example 3\n        List<List<Integer>> grid3 = Arrays.asList(\n            Arrays.asList(0, 0, 0),\n            Arrays.asList(0, 0, 0)\n        );\n        int capacity3 = 5;\n        System.out.println(solution.max_fill(grid3, capacity3)); // Output: 0\n    }\n}\n"}
{"task_id": "Java/116", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> sort_array(List<Integer> arr) {\n        // Sort the array using a custom comparator\n        Collections.sort(arr, new Comparator<Integer>() {\n            @Override\n            public int compare(Integer a, Integer b) {\n                // Count the number of 1s in the binary representation\n                int countA = Integer.bitCount(a);\n                int countB = Integer.bitCount(b);\n                \n                // First compare by the number of 1s\n                if (countA != countB) {\n                    return Integer.compare(countA, countB);\n                }\n                // If the number of 1s is the same, compare by the value itself\n                return Integer.compare(a, b);\n            }\n        });\n        \n        return arr;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sort_array(Arrays.asList(1, 5, 2, 3, 4))); // [1, 2, 4, 3, 5]\n        System.out.println(solution.sort_array(Arrays.asList(-2, -3, -4, -5, -6))); // [-4, -2, -6, -5, -3]\n        System.out.println(solution.sort_array(Arrays.asList(1, 0, 2, 3, 4))); // [0, 1, 2, 4, 3]\n    }\n}\n"}
{"task_id": "Java/117", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> select_words(String s, int n) {\n        // Initialize an empty list to store the result\n        List<String> result = new ArrayList<>();\n        \n        // Check if the input string is empty\n        if (s == null || s.isEmpty()) {\n            return result; // Return empty list if the string is empty\n        }\n        \n        // Split the string into words\n        String[] words = s.split(\" \");\n        \n        // Iterate through each word\n        for (String word : words) {\n            // Count the number of consonants in the word\n            int consonantCount = countConsonants(word);\n            \n            // If the count matches n, add the word to the result list\n            if (consonantCount == n) {\n                result.add(word);\n            }\n        }\n        \n        return result; // Return the list of words with exactly n consonants\n    }\n    \n    // Helper method to count consonants in a word\n    private int countConsonants(String word) {\n        int count = 0;\n        // Convert the word to lowercase to handle case insensitivity\n        word = word.toLowerCase();\n        \n        // Define a set of vowels for easy checking\n        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u'));\n        \n        // Iterate through each character in the word\n        for (char c : word.toCharArray()) {\n            // Check if the character is a letter and not a vowel\n            if (Character.isLetter(c) && !vowels.contains(c)) {\n                count++; // Increment the consonant count\n            }\n        }\n        \n        return count; // Return the total count of consonants\n    }\n}\n"}
{"task_id": "Java/118", "generation": "class Solution {\n    public String get_closest_vowel(String word) {\n        // Define vowels\n        String vowels = \"aeiouAEIOU\";\n        \n        // Length of the word\n        int n = word.length();\n        \n        // Iterate from the end of the word\n        for (int i = n - 2; i > 0; i--) { // Start from n-2 to avoid the first and last characters\n            char current = word.charAt(i);\n            \n            // Check if the current character is a vowel\n            if (vowels.indexOf(current) != -1) {\n                // Check if the characters before and after are consonants\n                if (i - 1 >= 0 && i + 1 < n) {\n                    char before = word.charAt(i - 1);\n                    char after = word.charAt(i + 1);\n                    \n                    // Check if both before and after are consonants\n                    if (!isVowel(before) && !isVowel(after)) {\n                        return String.valueOf(current); // Return the vowel found\n                    }\n                }\n            }\n        }\n        \n        // If no valid vowel found, return empty string\n        return \"\";\n    }\n    \n    // Helper method to check if a character is a vowel\n    private boolean isVowel(char c) {\n        return \"aeiouAEIOU\".indexOf(c) != -1;\n    }\n}\n"}
{"task_id": "Java/119", "generation": "import java.util.*;\n\nclass Solution {\n    public String match_parens(List<String> lst) {\n        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n        \n        // Check both concatenation orders\n        if (canFormGoodString(s1, s2) || canFormGoodString(s2, s1)) {\n            return \"Yes\";\n        }\n        return \"No\";\n    }\n    \n    private boolean canFormGoodString(String a, String b) {\n        int balanceA = 0, minBalanceA = 0;\n        \n        // Calculate balance and minimum balance for string a\n        for (char c : a.toCharArray()) {\n            if (c == '(') {\n                balanceA++;\n            } else {\n                balanceA--;\n            }\n            minBalanceA = Math.min(minBalanceA, balanceA);\n        }\n        \n        int balanceB = 0, minBalanceB = 0;\n        \n        // Calculate balance and minimum balance for string b\n        for (char c : b.toCharArray()) {\n            if (c == '(') {\n                balanceB++;\n            } else {\n                balanceB--;\n            }\n            minBalanceB = Math.min(minBalanceB, balanceB);\n        }\n        \n        // Check if concatenating a and b results in a good string\n        // The total balance must be zero and the minimum balance must not go below zero\n        return (balanceA + balanceB == 0) && (minBalanceA >= 0 || balanceA >= 0) && (minBalanceB >= 0 || balanceB >= 0);\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        System.out.println(sol.match_parens(Arrays.asList(\"()(\", \")\"))); // Output: Yes\n        System.out.println(sol.match_parens(Arrays.asList(\")\", \")\")));   // Output: No\n    }\n}\n"}
{"task_id": "Java/120", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Step 1: Sort the array in descending order\n        Collections.sort(arr, Collections.reverseOrder());\n        \n        // Step 2: Select the top k elements\n        List<Integer> topK = arr.subList(0, k);\n        \n        // Step 3: Sort the selected k elements in ascending order\n        Collections.sort(topK);\n        \n        return topK;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Example test cases\n        System.out.println(solution.maximum(Arrays.asList(-3, -4, 5), 3)); // Output: [-4, -3, 5]\n        System.out.println(solution.maximum(Arrays.asList(4, -4, 4), 2)); // Output: [4, 4]\n        System.out.println(solution.maximum(Arrays.asList(-3, 2, 1, 2, -1, -2, 1), 1)); // Output: [2]\n    }\n}\n"}
{"task_id": "Java/121", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution(Arrays.asList(5, 8, 7, 1)) ==> 12\n    solution(Arrays.asList(3, 3, 3, 3, 3)) ==> 9\n    solution(Arrays.asList(30, 13, 24, 321)) ==> 0\n    */\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n\n        for (int i = 0; i < lst.size(); i++) {\n            // Check if the index is even\n            if (i % 2 == 0) {\n                // Check if the element is odd\n                if (lst.get(i) % 2 != 0) {\n                    sum += lst.get(i);\n                }\n            }\n        }\n\n        return sum;\n    }\n}\n"}
{"task_id": "Java/122", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Given a non-empty array of integers arr and an integer k, return\n    the sum of the elements with at most two digits from the first k elements of arr.\n\n    Example:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # sum of 21 + 3\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n     */\n    public int add_elements(List<Integer> arr, int k) {\n        int sum = 0;\n        \n        // Iterate through the first k elements of the array\n        for (int i = 0; i < k; i++) {\n            int num = arr.get(i);\n            // Check if the number has at most two digits\n            if (num >= -99 && num <= 99) {\n                sum += num; // Add to sum if condition is met\n            }\n        }\n        \n        return sum; // Return the final sum\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<Integer> arr = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k = 4;\n        int result = solution.add_elements(arr, k);\n        System.out.println(result); // Output: 24\n    }\n}\n"}
{"task_id": "Java/123", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the\n    previous term as follows: if the previous term is even, the next term is one half of\n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note:\n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n     */\n    public List<Integer> get_odd_collatz(int n) {\n        Set<Integer> oddNumbers = new HashSet<>(); // Use a Set to avoid duplicates\n        while (n != 1) {\n            if (n % 2 != 0) { // Check if n is odd\n                oddNumbers.add(n);\n            }\n            // Generate the next term in the Collatz sequence\n            if (n % 2 == 0) {\n                n = n / 2;\n            } else {\n                n = 3 * n + 1;\n            }\n        }\n        // Add 1 to the set, since the sequence always ends with 1\n        oddNumbers.add(1);\n        \n        // Convert the set to a list and sort it\n        List<Integer> result = new ArrayList<>(oddNumbers);\n        Collections.sort(result);\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.get_odd_collatz(5)); // Output: [1, 5]\n        System.out.println(solution.get_odd_collatz(7)); // Output: [1, 7]\n        System.out.println(solution.get_odd_collatz(10)); // Output: [1, 5]\n    }\n}\n"}
{"task_id": "Java/124", "generation": "import java.util.regex.*;\n\nclass Solution {\n    public boolean valid_date(String date) {\n        // Check if the date string is empty\n        if (date == null || date.isEmpty()) {\n            return false;\n        }\n\n        // Regular expression to match the format mm-dd-yyyy\n        String regex = \"^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-(\\\\d{4})$\";\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(date);\n\n        // Check if the date matches the regex\n        if (!matcher.matches()) {\n            return false;\n        }\n\n        // Split the date into parts\n        String[] parts = date.split(\"-\");\n        int month = Integer.parseInt(parts[0]);\n        int day = Integer.parseInt(parts[1]);\n        int year = Integer.parseInt(parts[2]);\n\n        // Validate the month\n        if (month < 1 || month > 12) {\n            return false;\n        }\n\n        // Validate the day based on the month\n        switch (month) {\n            case 1: case 3: case 5: case 7: case 8: case 10: case 12:\n                return day >= 1 && day <= 31;\n            case 4: case 6: case 9: case 11:\n                return day >= 1 && day <= 30;\n            case 2:\n                // Check for leap year\n                if (isLeapYear(year)) {\n                    return day >= 1 && day <= 29; // Leap year\n                } else {\n                    return day >= 1 && day <= 28; // Non-leap year\n                }\n            default:\n                return false; // This case should never be reached due to month validation\n        }\n    }\n\n    // Helper method to check if a year is a leap year\n    private boolean isLeapYear(int year) {\n        return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n    }\n\n    // Example usage\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.valid_date(\"03-11-2000\")); // true\n        System.out.println(solution.valid_date(\"15-01-2012\")); // false\n        System.out.println(solution.valid_date(\"04-0-2040\")); // false\n        System.out.println(solution.valid_date(\"06-04-2020\")); // true\n        System.out.println(solution.valid_date(\"06/04/2020\")); // false\n    }\n}\n"}
{"task_id": "Java/125", "generation": "import java.util.*;\n\nclass Solution {\n    public Object split_words(String txt) {\n        // Check for whitespace\n        if (txt.contains(\" \")) {\n            return Arrays.asList(txt.split(\"\\\\s+\")); // Split on whitespace\n        }\n        \n        // Check for commas\n        if (txt.contains(\",\")) {\n            return Arrays.asList(txt.split(\",\")); // Split on commas\n        }\n        \n        // Count lowercase letters with odd order in the alphabet\n        int count = 0;\n        for (char c : txt.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                int position = c - 'a'; // Get the position in the alphabet (0-based)\n                if (position % 2 == 1) { // Check if the position is odd\n                    count++;\n                }\n            }\n        }\n        \n        return count; // Return the count of odd-positioned lowercase letters\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.split_words(\"Hello world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(solution.split_words(\"Hello,world!\")); // [\"Hello\", \"world!\"]\n        System.out.println(solution.split_words(\"abcdef\")); // 3\n        System.out.println(solution.split_words(\"abc,def ghi\")); // [\"abc\", \"def\", \"ghi\"]\n        System.out.println(solution.split_words(\"xyz\")); // 1\n    }\n}\n"}
{"task_id": "Java/126", "generation": "import java.util.*;\n\nclass Solution {\n    public boolean is_sorted(List<Integer> lst) {\n        // Edge case: If the list is empty or has one element, it is sorted\n        if (lst.size() <= 1) {\n            return true;\n        }\n\n        // HashMap to count occurrences of each number\n        HashMap<Integer, Integer> countMap = new HashMap<>();\n\n        // Check if the list is sorted and count occurrences\n        for (int i = 0; i < lst.size(); i++) {\n            int current = lst.get(i);\n\n            // Count occurrences\n            countMap.put(current, countMap.getOrDefault(current, 0) + 1);\n            if (countMap.get(current) > 2) {\n                return false; // More than two occurrences\n            }\n\n            // Check if the list is sorted\n            if (i > 0 && current < lst.get(i - 1)) {\n                return false; // Not sorted\n            }\n        }\n\n        // If we pass both checks, return true\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.is_sorted(Arrays.asList(5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7))); // false\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 3, 3, 4))); // true\n        System.out.println(solution.is_sorted(Arrays.asList(1, 2, 2, 2, 3, 4))); // false\n    }\n}\n"}
{"task_id": "Java/127", "generation": "import java.util.*;\n\nclass Solution {\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        // Extract start and end points from the intervals\n        int start1 = interval1.get(0);\n        int end1 = interval1.get(1);\n        int start2 = interval2.get(0);\n        int end2 = interval2.get(1);\n        \n        // Calculate the intersection\n        int startIntersection = Math.max(start1, start2);\n        int endIntersection = Math.min(end1, end2);\n        \n        // Calculate the length of the intersection\n        if (startIntersection > endIntersection) {\n            return \"NO\"; // No intersection\n        }\n        \n        int length = endIntersection - startIntersection;\n        \n        // Check if the length is a prime number\n        if (isPrime(length)) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n    \n    private boolean isPrime(int num) {\n        if (num <= 1) return false; // 0 and 1 are not prime numbers\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false; // Found a divisor, not prime\n            }\n        }\n        return true; // No divisors found, it's prime\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.intersection(Arrays.asList(1, 2), Arrays.asList(2, 3))); // \"NO\"\n        System.out.println(solution.intersection(Arrays.asList(-1, 1), Arrays.asList(0, 4))); // \"NO\"\n        System.out.println(solution.intersection(Arrays.asList(-3, -1), Arrays.asList(-5, 5))); // \"YES\"\n    }\n}\n"}
{"task_id": "Java/128", "generation": "import java.util.*;\n\nclass Solution {\n    public Optional<Integer> prod_signs(List<Integer> arr) {\n        // Check if the array is empty\n        if (arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        int sumOfMagnitudes = 0;\n        int productOfSigns = 1;\n\n        for (int num : arr) {\n            // Calculate the magnitude\n            sumOfMagnitudes += Math.abs(num);\n\n            // Determine the sign\n            if (num > 0) {\n                productOfSigns *= 1; // Positive\n            } else if (num < 0) {\n                productOfSigns *= -1; // Negative\n            } else {\n                productOfSigns = 0; // Zero encountered\n                break; // No need to continue, product will be zero\n            }\n        }\n\n        // Return the final result\n        return Optional.of(sumOfMagnitudes * productOfSigns);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.prod_signs(Arrays.asList(1, 2, 2, -4))); // Output: Optional[-9]\n        System.out.println(solution.prod_signs(Arrays.asList(0, 1))); // Output: Optional[0]\n        System.out.println(solution.prod_signs(Arrays.asList())); // Output: Optional.empty\n    }\n}\n"}
{"task_id": "Java/129", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        int n = grid.size();\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // right, down, left, up\n        List<Integer> minPath = new ArrayList<>();\n        \n        // Priority queue to store paths in lexicographical order\n        PriorityQueue<List<Integer>> pq = new PriorityQueue<>((a, b) -> {\n            for (int i = 0; i < Math.min(a.size(), b.size()); i++) {\n                if (!a.get(i).equals(b.get(i))) {\n                    return a.get(i) - b.get(i);\n                }\n            }\n            return a.size() - b.size(); // If they are equal till the end, compare lengths\n        });\n\n        // Start BFS from each cell\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                // Start a new path from (i, j)\n                List<Integer> path = new ArrayList<>();\n                path.add(grid.get(i).get(j));\n                pq.offer(path);\n                \n                // BFS to find paths of length k\n                while (!pq.isEmpty()) {\n                    List<Integer> currentPath = pq.poll();\n                    \n                    // If we reached the desired length k\n                    if (currentPath.size() == k) {\n                        if (minPath.isEmpty() || isLexicographicallySmaller(currentPath, minPath)) {\n                            minPath = new ArrayList<>(currentPath);\n                        }\n                        continue; // No need to expand this path further\n                    }\n                    \n                    // Get the last position in the current path\n                    int lastRow = (currentPath.size() > 0) ? (i + (currentPath.size() - 1) / n) : 0;\n                    int lastCol = (currentPath.size() > 0) ? (j + (currentPath.size() - 1) % n) : 0;\n                    \n                    // Explore neighbors\n                    for (int[] dir : directions) {\n                        int newRow = lastRow + dir[0];\n                        int newCol = lastCol + dir[1];\n                        \n                        // Check bounds\n                        if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {\n                            List<Integer> newPath = new ArrayList<>(currentPath);\n                            newPath.add(grid.get(newRow).get(newCol));\n                            pq.offer(newPath);\n                        }\n                    }\n                }\n            }\n        }\n        \n        return minPath;\n    }\n\n    private boolean isLexicographicallySmaller(List<Integer> a, List<Integer> b) {\n        for (int i = 0; i < Math.min(a.size(), b.size()); i++) {\n            if (!a.get(i).equals(b.get(i))) {\n                return a.get(i) < b.get(i);\n            }\n        }\n        return a.size() < b.size(); // If they are equal till the end, compare lengths\n    }\n}\n"}
{"task_id": "Java/130", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> tri(int n) {\n        List<Integer> result = new ArrayList<>();\n        \n        // We need to compute values from 0 to n\n        for (int i = 0; i <= n; i++) {\n            result.add(computeTri(i, result));\n        }\n        \n        return result;\n    }\n    \n    private int computeTri(int n, List<Integer> memo) {\n        // Base case\n        if (n == 0) return 1; // Assuming tri(0) = 1 based on the example output\n        if (n == 1) return 3; // tri(1) = 3\n        \n        // If already computed, return the value\n        if (n < memo.size()) {\n            return memo.get(n);\n        }\n        \n        // Compute the value based on the rules\n        int value;\n        if (n % 2 == 0) { // Even case\n            value = 1 + n / 2;\n        } else { // Odd case\n            value = computeTri(n - 1, memo) + computeTri(n - 2, memo) + computeTri(n + 1, memo);\n        }\n        \n        // Store the computed value in the memo list\n        if (n >= memo.size()) {\n            memo.add(value);\n        }\n        \n        return value;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n = 3; // Example input\n        List<Integer> result = solution.tri(n);\n        System.out.println(result); // Output: [1, 3, 2, 8]\n    }\n}\n"}
{"task_id": "Java/131", "generation": "class Solution {\n    public int digits(int n) {\n        int product = 1;\n        boolean hasOddDigit = false;\n\n        while (n > 0) {\n            int digit = n % 10; // Get the last digit\n            if (digit % 2 != 0) { // Check if the digit is odd\n                product *= digit; // Multiply to the product\n                hasOddDigit = true; // Mark that we found an odd digit\n            }\n            n /= 10; // Remove the last digit\n        }\n\n        return hasOddDigit ? product : 0; // Return product or 0 if no odd digits were found\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.digits(1));    // Output: 1\n        System.out.println(solution.digits(4));    // Output: 0\n        System.out.println(solution.digits(235));  // Output: 15\n    }\n}\n"}
{"task_id": "Java/132", "generation": "import java.util.Stack;\n\nclass Solution {\n    public boolean is_nested(String string) {\n        Stack<Character> stack = new Stack<>();\n        boolean hasNested = false; // To track if we have nested brackets\n        int currentDepth = 0; // To track the current depth of nested brackets\n\n        for (char ch : string.toCharArray()) {\n            if (ch == '[') {\n                stack.push(ch);\n                currentDepth++;\n                // If we have more than one opening bracket in the stack, we have a nested structure\n                if (currentDepth > 1) {\n                    hasNested = true;\n                }\n            } else if (ch == ']') {\n                if (stack.isEmpty()) {\n                    // Unmatched closing bracket\n                    return false;\n                }\n                stack.pop();\n                currentDepth--;\n            }\n        }\n\n        // If the stack is not empty, there are unmatched opening brackets\n        return hasNested && stack.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.is_nested(\"[[]]\")); // true\n        System.out.println(solution.is_nested(\"[]]]]]]][[[[[]\")); // false\n        System.out.println(solution.is_nested(\"[][]\")); // false\n        System.out.println(solution.is_nested(\"[]\")); // false\n        System.out.println(solution.is_nested(\"[[][]]\")); // true\n        System.out.println(solution.is_nested(\"[[]][[\")); // true\n    }\n}\n"}
{"task_id": "Java/133", "generation": "import java.util.*;\nimport java.lang.Math;\n\nclass Solution {\n    /**\n    You are given a list of numbers.\n    You need to return the sum of squared numbers in the given list,\n    round each element in the list to the upper int(Ceiling) first.\n    Examples:\n    For lst = [1,2,3] the output should be 14\n    For lst = [1,4,9] the output should be 98\n    For lst = [1,3,5,7] the output should be 84\n    For lst = [1.4,4.2,0] the output should be 29\n    For lst = [-2.4,1,1] the output should be 6\n     */\n    public int sum_squares(List<Double> lst) {\n        int sum = 0;\n        for (Double num : lst) {\n            // Round up to the nearest integer\n            int rounded = (int) Math.ceil(num);\n            // Square the rounded integer and add to the sum\n            sum += rounded * rounded;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sum_squares(Arrays.asList(1.0, 2.0, 3.0))); // Output: 14\n        System.out.println(solution.sum_squares(Arrays.asList(1.0, 4.0, 9.0))); // Output: 98\n        System.out.println(solution.sum_squares(Arrays.asList(1.0, 3.0, 5.0, 7.0))); // Output: 84\n        System.out.println(solution.sum_squares(Arrays.asList(1.4, 4.2, 0.0))); // Output: 29\n        System.out.println(solution.sum_squares(Arrays.asList(-2.4, 1.0, 1.0))); // Output: 6\n    }\n}\n"}
{"task_id": "Java/134", "generation": "class Solution {\n    public boolean check_if_last_char_is_a_letter(String txt) {\n        // Trim the string to remove trailing spaces\n        txt = txt.trim();\n        \n        // If the string is empty after trimming, return false\n        if (txt.isEmpty()) {\n            return false;\n        }\n        \n        // Get the last character\n        char lastChar = txt.charAt(txt.length() - 1);\n        \n        // Check if the last character is a letter\n        if (Character.isLetter(lastChar)) {\n            // Check if the last character is not part of a word\n            // It should be preceded by a space or be the only character in the string\n            if (txt.length() == 1 || txt.charAt(txt.length() - 2) == ' ') {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n}\n"}
{"task_id": "Java/135", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange(Arrays.asList(1,2,4,3,5)) = 3\n    can_arrange(Arrays.asList(1,2,3)) = -1\n    */\n    public int can_arrange(List<Integer> arr) {\n        int n = arr.size();\n        \n        // Start from the second last element and go backwards\n        for (int i = n - 2; i >= 0; i--) {\n            // Check if the current element is less than the next element\n            if (arr.get(i) > arr.get(i + 1)) {\n                return i + 1; // Return the index of the current element\n            }\n        }\n        \n        // If no such element is found, return -1\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.can_arrange(Arrays.asList(1, 2, 4, 3, 5))); // Output: 3\n        System.out.println(solution.can_arrange(Arrays.asList(1, 2, 3))); // Output: -1\n        System.out.println(solution.can_arrange(Arrays.asList(5, 4, 3, 2, 1))); // Output: 1\n        System.out.println(solution.can_arrange(Arrays.asList(1, 3, 2, 4, 5))); // Output: 2\n    }\n}\n"}
{"task_id": "Java/136", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Optional<Integer>> largest_smallest_integers(List<Integer> lst) {\n        Optional<Integer> largestNegative = Optional.empty();\n        Optional<Integer> smallestPositive = Optional.empty();\n\n        for (Integer num : lst) {\n            if (num < 0) {\n                if (!largestNegative.isPresent() || num > largestNegative.get()) {\n                    largestNegative = Optional.of(num);\n                }\n            } else if (num > 0) {\n                if (!smallestPositive.isPresent() || num < smallestPositive.get()) {\n                    smallestPositive = Optional.of(num);\n                }\n            }\n        }\n\n        return Arrays.asList(largestNegative, smallestPositive);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(2, 4, 1, 3, 5, 7))); // (Optional.empty(), Optional.of(1))\n        System.out.println(solution.largest_smallest_integers(Arrays.asList())); // (Optional.empty(), Optional.empty())\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(0))); // (Optional.empty(), Optional.empty())\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(-1, -2, 3, 4, -5))); // (Optional.of(-1), Optional.of(3))\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(-1, -2, -3))); // (Optional.of(-1), Optional.empty())\n        System.out.println(solution.largest_smallest_integers(Arrays.asList(1, 2, 3))); // (Optional.empty(), Optional.of(1))\n    }\n}\n"}
{"task_id": "Java/137", "generation": "import java.util.Optional;\n\nclass Solution {\n    public Optional<Object> compare_one(Object a, Object b) {\n        Double valueA = convertToDouble(a);\n        Double valueB = convertToDouble(b);\n        \n        if (valueA == null || valueB == null) {\n            return Optional.empty(); // If conversion fails, return empty\n        }\n        \n        if (valueA.equals(valueB)) {\n            return Optional.empty(); // Return empty if values are equal\n        }\n        \n        // Return the larger value in its original type\n        if (valueA > valueB) {\n            return Optional.of(a);\n        } else {\n            return Optional.of(b);\n        }\n    }\n\n    private Double convertToDouble(Object obj) {\n        if (obj instanceof Number) {\n            return ((Number) obj).doubleValue();\n        } else if (obj instanceof String) {\n            String str = (String) obj;\n            str = str.replace(\",\", \".\"); // Replace comma with dot for decimal\n            try {\n                return Double.parseDouble(str);\n            } catch (NumberFormatException e) {\n                return null; // Return null if parsing fails\n            }\n        }\n        return null; // Return null for unsupported types\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.compare_one(1, 2.5)); // Optional[2.5]\n        System.out.println(solution.compare_one(1, \"2,3\")); // Optional[\"2,3\"]\n        System.out.println(solution.compare_one(\"5,1\", \"6\")); // Optional[\"6\"]\n        System.out.println(solution.compare_one(\"1\", 1)); // Optional.empty\n    }\n}\n"}
{"task_id": "Java/138", "generation": "class Solution {\n    /**\n    Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n    Example\n    is_equal_to_sum_even(4) == false\n    is_equal_to_sum_even(6) == false\n    is_equal_to_sum_even(8) == true\n    */\n    public boolean is_equal_to_sum_even(int n) {\n        // Check if n is less than 8\n        if (n < 8) {\n            return false;\n        }\n        // Check if n is even\n        return n % 2 == 0;\n    }\n}\n"}
{"task_id": "Java/139", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    */\n    public long special_factorial(int n) {\n        long result = 1; // To store the final result\n\n        // Calculate the Brazilian factorial\n        for (int i = 1; i <= n; i++) {\n            result *= factorial(i); // Multiply by the factorial of i\n        }\n\n        return result;\n    }\n\n    // Helper method to calculate factorial of a number\n    private long factorial(int num) {\n        long fact = 1;\n        for (int i = 2; i <= num; i++) {\n            fact *= i; // Calculate factorial\n        }\n        return fact;\n    }\n\n    // Main method for testing\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.special_factorial(4)); // Output: 288\n        System.out.println(solution.special_factorial(5)); // Output: 34560\n    }\n}\n"}
{"task_id": "Java/140", "generation": "import java.util.regex.*;\n\nclass Solution {\n    /**\n    Given a string text, replace all spaces in it with underscores,\n    and if a string has more than 2 consecutive spaces,\n    then replace all consecutive spaces with -\n\n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    */\n    public String fix_spaces(String text) {\n        // Replace all spaces with underscores\n        String replacedText = text.replace(\" \", \"_\");\n        \n        // Use regex to replace more than 2 consecutive underscores with a single hyphen\n        replacedText = replacedText.replaceAll(\"_{3,}\", \"-\");\n        \n        return replacedText;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.fix_spaces(\"Example\"));          // \"Example\"\n        System.out.println(solution.fix_spaces(\"Example 1\"));        // \"Example_1\"\n        System.out.println(solution.fix_spaces(\" Example 2\"));       // \"_Example_2\"\n        System.out.println(solution.fix_spaces(\" Example   3\"));     // \"_Example-3\"\n    }\n}\n"}
{"task_id": "Java/141", "generation": "import java.util.regex.*;\n\nclass Solution {\n    public String file_name_check(String file_name) {\n        // Check for exactly one dot\n        int dotIndex = file_name.indexOf('.');\n        if (dotIndex == -1 || file_name.indexOf('.', dotIndex + 1) != -1) {\n            return \"No\";\n        }\n\n        // Split the file name into name and extension\n        String namePart = file_name.substring(0, dotIndex);\n        String extensionPart = file_name.substring(dotIndex + 1);\n\n        // Check if the name part is not empty and starts with a letter\n        if (namePart.isEmpty() || !Character.isLetter(namePart.charAt(0))) {\n            return \"No\";\n        }\n\n        // Check if the extension is valid\n        List<String> validExtensions = Arrays.asList(\"txt\", \"exe\", \"dll\");\n        if (!validExtensions.contains(extensionPart)) {\n            return \"No\";\n        }\n\n        // Count the number of digits in the name part\n        int digitCount = 0;\n        for (char c : namePart.toCharArray()) {\n            if (Character.isDigit(c)) {\n                digitCount++;\n            }\n        }\n\n        // Check if there are more than three digits\n        if (digitCount > 3) {\n            return \"No\";\n        }\n\n        // If all conditions are met, return \"Yes\"\n        return \"Yes\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.file_name_check(\"example.txt\")); // Yes\n        System.out.println(solution.file_name_check(\"1example.dll\")); // No\n        System.out.println(solution.file_name_check(\"example123.txt\")); // Yes\n        System.out.println(solution.file_name_check(\"example1234.txt\")); // No\n        System.out.println(solution.file_name_check(\"example.exe\")); // Yes\n        System.out.println(solution.file_name_check(\"example.\")); // No\n        System.out.println(solution.file_name_check(\".example.txt\")); // No\n        System.out.println(solution.file_name_check(\"example.txtx\")); // No\n    }\n}\n"}
{"task_id": "Java/142", "generation": "import java.util.*;\n\nclass Solution {\n    public int sum_squares(List<Integer> lst) {\n        int sum = 0;\n\n        for (int i = 0; i < lst.size(); i++) {\n            int value = lst.get(i);\n            if (i % 3 == 0) {\n                // Square the value if index is a multiple of 3\n                value = value * value;\n            } \n            if (i % 4 == 0 && i % 3 != 0) {\n                // Cube the value if index is a multiple of 4 and not a multiple of 3\n                value = value * value * value;\n            }\n            // Add the transformed value to the sum\n            sum += value;\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        \n        // Test cases\n        System.out.println(sol.sum_squares(Arrays.asList(1, 2, 3))); // Output: 6\n        System.out.println(sol.sum_squares(Arrays.asList())); // Output: 0\n        System.out.println(sol.sum_squares(Arrays.asList(-1, -5, 2, -1, -5))); // Output: -126\n    }\n}\n"}
{"task_id": "Java/143", "generation": "import java.util.*;\n\nclass Solution {\n    // Function to check if a number is prime\n    private boolean isPrime(int num) {\n        if (num <= 1) return false; // 0 and 1 are not prime numbers\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) return false; // Found a divisor, not prime\n        }\n        return true; // No divisors found, it is prime\n    }\n\n    public String words_in_sentence(String sentence) {\n        // Split the sentence into words\n        String[] words = sentence.split(\" \");\n        List<String> primeLengthWords = new ArrayList<>();\n\n        // Check each word's length\n        for (String word : words) {\n            int length = word.length();\n            if (isPrime(length)) {\n                primeLengthWords.add(word); // Add word if its length is prime\n            }\n        }\n\n        // Join the words with a space and return the result\n        return String.join(\" \", primeLengthWords);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.words_in_sentence(\"This is a test\")); // Output: \"is\"\n        System.out.println(solution.words_in_sentence(\"lets go for swimming\")); // Output: \"go for\"\n    }\n}\n"}
{"task_id": "Java/144", "generation": "class Solution {\n    public boolean simplify(String x, String n) {\n        // Split the fractions into numerator and denominator\n        String[] xParts = x.split(\"/\");\n        String[] nParts = n.split(\"/\");\n        \n        // Parse the numerators and denominators\n        int numeratorX = Integer.parseInt(xParts[0]);\n        int denominatorX = Integer.parseInt(xParts[1]);\n        int numeratorN = Integer.parseInt(nParts[0]);\n        int denominatorN = Integer.parseInt(nParts[1]);\n        \n        // Calculate the product of the fractions\n        int productNumerator = numeratorX * numeratorN; // a * c\n        int productDenominator = denominatorX * denominatorN; // b * d\n        \n        // Check if the product is a whole number\n        return productNumerator % productDenominator == 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.simplify(\"1/5\", \"5/1\")); // true\n        System.out.println(solution.simplify(\"1/6\", \"2/1\")); // false\n        System.out.println(solution.simplify(\"7/10\", \"10/2\")); // false\n    }\n}\n"}
{"task_id": "Java/145", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> order_by_points(List<Integer> nums) {\n        // Create a list of pairs (sum of digits, original index, number)\n        List<Pair> pairs = new ArrayList<>();\n        \n        for (int i = 0; i < nums.size(); i++) {\n            int num = nums.get(i);\n            int sumOfDigits = sumOfDigits(num);\n            pairs.add(new Pair(sumOfDigits, i, num));\n        }\n        \n        // Sort the pairs based on sum of digits and original index\n        Collections.sort(pairs, (a, b) -> {\n            if (a.sum != b.sum) {\n                return Integer.compare(a.sum, b.sum);\n            } else {\n                return Integer.compare(a.index, b.index);\n            }\n        });\n        \n        // Extract the sorted numbers\n        List<Integer> sortedNums = new ArrayList<>();\n        for (Pair pair : pairs) {\n            sortedNums.add(pair.num);\n        }\n        \n        return sortedNums;\n    }\n    \n    // Helper method to calculate the sum of digits\n    private int sumOfDigits(int num) {\n        int sum = 0;\n        int absNum = Math.abs(num); // Work with the absolute value\n        \n        while (absNum > 0) {\n            sum += absNum % 10; // Add the last digit\n            absNum /= 10; // Remove the last digit\n        }\n        \n        // If the number is negative, we subtract twice the first digit\n        if (num < 0) {\n            sum -= 2 * (Math.abs(num) / (int) Math.pow(10, String.valueOf(Math.abs(num)).length() - 1));\n        }\n        \n        return sum;\n    }\n    \n    // Helper class to store the sum of digits, original index, and the number\n    private static class Pair {\n        int sum;\n        int index;\n        int num;\n        \n        Pair(int sum, int index, int num) {\n            this.sum = sum;\n            this.index = index;\n            this.num = num;\n        }\n    }\n}\n"}
{"task_id": "Java/146", "generation": "import java.util.*;\n\nclass Solution {\n    public int specialFilter(List<Integer> nums) {\n        int count = 0;\n\n        for (int num : nums) {\n            // Check if the number is greater than 10\n            if (num > 10) {\n                // Get the absolute value of the number to handle negative numbers\n                int absNum = Math.abs(num);\n                \n                // Get the last digit\n                int lastDigit = absNum % 10;\n\n                // Get the first digit\n                while (absNum >= 10) {\n                    absNum /= 10;\n                }\n                int firstDigit = absNum;\n\n                // Check if both first and last digits are odd\n                if (isOdd(firstDigit) && isOdd(lastDigit)) {\n                    count++;\n                }\n            }\n        }\n\n        return count;\n    }\n\n    // Helper method to check if a digit is odd\n    private boolean isOdd(int digit) {\n        return digit % 2 != 0;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.specialFilter(Arrays.asList(15, -73, 14, -15))); // Output: 1\n        System.out.println(solution.specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109))); // Output: 2\n    }\n}\n"}
{"task_id": "Java/147", "generation": "import java.util.*;\n\nclass Solution {\n    public int get_max_triples(int n) {\n        // Step 1: Create the array a\n        int[] a = new int[n];\n        for (int i = 1; i <= n; i++) {\n            a[i - 1] = i * i - i + 1; // a[i] = i * i - i + 1\n        }\n\n        // Step 2: Count occurrences of each modulo 3 category\n        int[] count = new int[3]; // count[0] for mod 0, count[1] for mod 1, count[2] for mod 2\n        for (int value : a) {\n            count[value % 3]++;\n        }\n\n        // Step 3: Calculate the number of valid triples\n        int totalTriples = 0;\n\n        // Combinations of three from count[0]\n        totalTriples += combination(count[0], 3);\n        // Combinations of three from count[1]\n        totalTriples += combination(count[1], 3);\n        // Combinations of three from count[2]\n        totalTriples += combination(count[2], 3);\n        // One from each category\n        totalTriples += count[0] * count[1] * count[2];\n\n        return totalTriples;\n    }\n\n    // Helper method to calculate combinations C(n, k)\n    private int combination(int n, int k) {\n        if (n < k) return 0;\n        if (k == 0) return 1;\n        if (k > n / 2) k = n - k; // Take advantage of symmetry\n        int result = 1;\n        for (int i = 0; i < k; i++) {\n            result = result * (n - i) / (i + 1);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        int n = 5;\n        System.out.println(sol.get_max_triples(n)); // Output: 1\n    }\n}\n"}
{"task_id": "Java/148", "generation": "import java.util.*;\n\nclass Solution {\n    public List<String> bf(String planet1, String planet2) {\n        // List of planets in order of proximity to the Sun\n        List<String> planets = Arrays.asList(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n        \n        // Check if both planets are valid\n        if (!planets.contains(planet1) || !planets.contains(planet2)) {\n            return new ArrayList<>(); // Return empty list if either planet is invalid\n        }\n        \n        // Get the indices of the planets\n        int index1 = planets.indexOf(planet1);\n        int index2 = planets.indexOf(planet2);\n        \n        // Ensure index1 is less than index2 for correct slicing\n        if (index1 > index2) {\n            int temp = index1;\n            index1 = index2;\n            index2 = temp;\n        }\n        \n        // Extract the sublist of planets between the two indices\n        return planets.subList(index1 + 1, index2); // +1 to exclude the planets themselves\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.bf(\"Jupiter\", \"Neptune\")); // [\"Saturn\", \"Uranus\"]\n        System.out.println(solution.bf(\"Earth\", \"Mercury\"));   // []\n        System.out.println(solution.bf(\"Mercury\", \"Uranus\"));  // [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\n        System.out.println(solution.bf(\"Mars\", \"Jupiter\"));     // [\"Saturn\"]\n        System.out.println(solution.bf(\"Neptune\", \"Mercury\"));  // []\n    }\n}\n"}
{"task_id": "Java/149", "generation": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> sorted_list_sum(List<String> lst) {\n        // Step 1: Filter out strings with odd lengths\n        List<String> filteredList = new ArrayList<>();\n        for (String str : lst) {\n            if (str.length() % 2 == 0) { // Check if the length is even\n                filteredList.add(str);\n            }\n        }\n\n        // Step 2: Sort the filtered list\n        Collections.sort(filteredList, new Comparator<String>() {\n            @Override\n            public int compare(String s1, String s2) {\n                // First compare by length\n                int lengthComparison = Integer.compare(s1.length(), s2.length());\n                if (lengthComparison != 0) {\n                    return lengthComparison; // If lengths are different, return that comparison\n                }\n                // If lengths are the same, compare alphabetically\n                return s1.compareTo(s2);\n            }\n        });\n\n        // Step 3: Return the sorted list\n        return filteredList;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.sorted_list_sum(Arrays.asList(\"aa\", \"a\", \"aaa\"))); // Output: [\"aa\"]\n        System.out.println(solution.sorted_list_sum(Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\"))); // Output: [\"ab\", \"cd\"]\n    }\n}\n"}
{"task_id": "Java/150", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    A simple program which should return the value of x if n is\n    a prime number and should return the value of y otherwise.\n\n    Examples:\n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    */\n    public int x_or_y(int n, int x, int y) {\n        if (isPrime(n)) {\n            return x;\n        } else {\n            return y;\n        }\n    }\n\n    // Helper method to check if a number is prime\n    private boolean isPrime(int num) {\n        if (num <= 1) {\n            return false; // 0 and 1 are not prime numbers\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false; // Found a divisor, not prime\n            }\n        }\n        return true; // No divisors found, it's prime\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.x_or_y(7, 34, 12)); // Output: 34\n        System.out.println(solution.x_or_y(15, 8, 5)); // Output: 5\n    }\n}\n"}
{"task_id": "Java/151", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n\n    double_the_difference(Arrays.asList(1, 3, 2, 0)) == 1 + 9 + 0 + 0 = 10\n    double_the_difference(Arrays.asList(-1, -2, 0)) == 0\n    double_the_difference(Arrays.asList(9, -2)) == 81\n    double_the_difference(Arrays.asList(0)) == 0\n\n    If the input list is empty, return 0.\n     */\n    public int double_the_difference(List<Object> lst) {\n        int sum = 0;\n\n        for (Object obj : lst) {\n            // Check if the object is an instance of Integer\n            if (obj instanceof Integer) {\n                int num = (Integer) obj;\n\n                // Check if the number is odd and non-negative\n                if (num > 0 && num % 2 != 0) {\n                    sum += num * num; // Add the square of the number to the sum\n                }\n            }\n        }\n\n        return sum; // Return the total sum of squares of odd numbers\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.double_the_difference(Arrays.asList(1, 3, 2, 0))); // Output: 10\n        System.out.println(solution.double_the_difference(Arrays.asList(-1, -2, 0))); // Output: 0\n        System.out.println(solution.double_the_difference(Arrays.asList(9, -2))); // Output: 81\n        System.out.println(solution.double_the_difference(Arrays.asList(0))); // Output: 0\n    }\n}\n"}
{"task_id": "Java/152", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        List<Integer> result = new ArrayList<>();\n        \n        // Ensure both lists have the same size\n        if (game.size() != guess.size()) {\n            throw new IllegalArgumentException(\"Both lists must have the same length.\");\n        }\n        \n        // Iterate through both lists\n        for (int i = 0; i < game.size(); i++) {\n            // Calculate the absolute difference\n            int difference = Math.abs(game.get(i) - guess.get(i));\n            result.add(difference);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.compare(Arrays.asList(1, 2, 3, 4, 5, 1), Arrays.asList(1, 2, 3, 4, 2, -2))); // Output: [0, 0, 0, 0, 3, 3]\n        System.out.println(solution.compare(Arrays.asList(0, 5, 0, 0, 0, 4), Arrays.asList(4, 1, 1, 0, 0, -2))); // Output: [4, 4, 1, 0, 0, 6]\n    }\n}\n"}
{"task_id": "Java/153", "generation": "import java.util.*;\n\nclass Solution {\n    public String Strongest_Extension(String class_name, List<String> extensions) {\n        String strongestExtension = \"\";\n        int maxStrength = Integer.MIN_VALUE;\n\n        for (String extension : extensions) {\n            int capCount = 0;\n            int smCount = 0;\n\n            // Count uppercase and lowercase letters\n            for (char c : extension.toCharArray()) {\n                if (Character.isUpperCase(c)) {\n                    capCount++;\n                } else if (Character.isLowerCase(c)) {\n                    smCount++;\n                }\n            }\n\n            // Calculate strength\n            int strength = capCount - smCount;\n\n            // Update strongest extension if this one is stronger\n            if (strength > maxStrength) {\n                maxStrength = strength;\n                strongestExtension = extension;\n            }\n        }\n\n        // Return the result in the required format\n        return class_name + \".\" + strongestExtension;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.Strongest_Extension(\"Slices\", Arrays.asList(\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"))); // Output: \"Slices.SErviNGSliCes\"\n        System.out.println(solution.Strongest_Extension(\"my_class\", Arrays.asList(\"AA\", \"Be\", \"CC\"))); // Output: \"my_class.AA\"\n    }\n}\n"}
{"task_id": "Java/154", "generation": "class Solution {\n    public boolean cycpattern_check(String a, String b) {\n        // If b is longer than a, it can't be a substring\n        if (b.length() > a.length()) {\n            return false;\n        }\n        \n        // Concatenate b with itself\n        String bConcat = b + b;\n        \n        // Check if a contains any substring of b's rotations\n        return bConcat.contains(a);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.cycpattern_check(\"abcd\", \"abd\")); // false\n        System.out.println(solution.cycpattern_check(\"hello\", \"ell\")); // true\n        System.out.println(solution.cycpattern_check(\"whassup\", \"psus\")); // false\n        System.out.println(solution.cycpattern_check(\"abab\", \"baa\")); // true\n        System.out.println(solution.cycpattern_check(\"efef\", \"eeff\")); // false\n        System.out.println(solution.cycpattern_check(\"himenss\", \"simen\")); // true\n    }\n}\n"}
{"task_id": "Java/155", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Given an integer, return a list that has the number of even and odd digits respectively.\n    \n     Example:\n        even_odd_count(-12) ==> [1, 1]\n        even_odd_count(123) ==> [1, 2]\n     */\n    public List<Integer> even_odd_count(int num) {\n        // Convert the number to its absolute value to ignore the sign\n        num = Math.abs(num);\n        \n        int evenCount = 0;\n        int oddCount = 0;\n        \n        // Convert the number to a string to iterate through each digit\n        String numStr = Integer.toString(num);\n        \n        for (char digit : numStr.toCharArray()) {\n            int digitValue = Character.getNumericValue(digit);\n            if (digitValue % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n        \n        // Create a list to hold the counts\n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.even_odd_count(-12)); // Output: [1, 1]\n        System.out.println(solution.even_odd_count(123));  // Output: [1, 2]\n        System.out.println(solution.even_odd_count(2468)); // Output: [4, 0]\n        System.out.println(solution.even_odd_count(13579)); // Output: [0, 5]\n    }\n}\n"}
{"task_id": "Java/156", "generation": "import java.util.*;\n\nclass Solution {\n    public String int_to_mini_roman(int number) {\n        // Define the mapping of integers to Roman numerals\n        String[] romanNumerals = {\n            \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n        };\n        int[] values = {\n            1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        };\n\n        StringBuilder result = new StringBuilder();\n\n        // Iterate through the values and build the Roman numeral\n        for (int i = 0; i < values.length; i++) {\n            while (number >= values[i]) {\n                result.append(romanNumerals[i]);\n                number -= values[i];\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.int_to_mini_roman(19));   // Output: \"xix\"\n        System.out.println(solution.int_to_mini_roman(152));  // Output: \"clii\"\n        System.out.println(solution.int_to_mini_roman(426));  // Output: \"cdxxvi\"\n    }\n}\n"}
{"task_id": "Java/157", "generation": "import java.util.*;\n\nclass Solution {\n    /**\n    Given the lengths of the three sides of a triangle. Return true if the three\n    sides form a right-angled triangle, false otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or\n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == true\n    right_angle_triangle(1, 2, 3) == false\n    */\n    public boolean right_angle_triangle(int a, int b, int c) {\n        // Sort the sides to ensure we can identify the longest side\n        int[] sides = {a, b, c};\n        Arrays.sort(sides);\n        \n        // The longest side will be the last element after sorting\n        int x = sides[2]; // Hypotenuse\n        int y = sides[0]; // One side\n        int z = sides[1]; // Another side\n        \n        // Check the Pythagorean theorem\n        return (y * y + z * z) == (x * x);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.right_angle_triangle(3, 4, 5)); // true\n        System.out.println(solution.right_angle_triangle(1, 2, 3)); // false\n        System.out.println(solution.right_angle_triangle(5, 12, 13)); // true\n        System.out.println(solution.right_angle_triangle(8, 15, 17)); // true\n        System.out.println(solution.right_angle_triangle(7, 24, 25)); // true\n    }\n}\n"}
{"task_id": "Java/158", "generation": "import java.util.*;\n\nclass Solution {\n    public String find_max(List<String> words) {\n        String maxWord = \"\";\n        int maxUniqueCount = 0;\n\n        for (String word : words) {\n            // Use a Set to find unique characters\n            Set<Character> uniqueChars = new HashSet<>();\n            for (char c : word.toCharArray()) {\n                uniqueChars.add(c);\n            }\n\n            int uniqueCount = uniqueChars.size();\n\n            // Check if we found a new maximum or if we need to check lexicographical order\n            if (uniqueCount > maxUniqueCount) {\n                maxUniqueCount = uniqueCount;\n                maxWord = word;\n            } else if (uniqueCount == maxUniqueCount) {\n                if (word.compareTo(maxWord) < 0) {\n                    maxWord = word;\n                }\n            }\n        }\n\n        return maxWord;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"of\", \"string\"))); // Output: \"string\"\n        System.out.println(solution.find_max(Arrays.asList(\"name\", \"enam\", \"game\"))); // Output: \"enam\"\n        System.out.println(solution.find_max(Arrays.asList(\"aaaaaaa\", \"bb\", \"cc\"))); // Output: \"aaaaaaa\"\n    }\n}\n"}
{"task_id": "Java/159", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Calculate total carrots needed to eat\n        int totalNeeded = number + need;\n        \n        // Determine how many carrots can be eaten\n        int carrotsEaten = Math.min(need, remaining);\n        \n        // Update total eaten carrots\n        int totalEaten = totalNeeded + carrotsEaten;\n        \n        // Calculate remaining carrots after eating\n        int carrotsLeft = remaining - carrotsEaten;\n        \n        // Create the result list\n        List<Integer> result = new ArrayList<>();\n        result.add(totalEaten);\n        result.add(carrotsLeft);\n        \n        return result;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.eat(5, 6, 10)); // [11, 4]\n        System.out.println(solution.eat(4, 8, 9));  // [12, 1]\n        System.out.println(solution.eat(1, 10, 10)); // [11, 0]\n        System.out.println(solution.eat(2, 11, 5));  // [7, 0]\n    }\n}\n"}
{"task_id": "Java/160", "generation": "import java.util.*;\n\nclass Solution {\n    public int do_algebra(List<String> operator, List<Integer> operand) {\n        // Step 1: Handle multiplication and division first\n        List<Integer> newOperands = new ArrayList<>();\n        List<String> newOperators = new ArrayList<>();\n        \n        newOperands.add(operand.get(0)); // Start with the first operand\n        \n        for (int i = 0; i < operator.size(); i++) {\n            String op = operator.get(i);\n            int currentOperand = operand.get(i + 1);\n            \n            if (op.equals(\"*\") || op.equals(\"/\") || op.equals(\"**\")) {\n                int lastOperand = newOperands.remove(newOperands.size() - 1); // Get the last operand\n                int result = performOperation(lastOperand, currentOperand, op);\n                newOperands.add(result); // Add the result back to the operands\n            } else {\n                newOperands.add(currentOperand); // Just add the current operand\n                newOperators.add(op); // Add the operator for later processing\n            }\n        }\n        \n        // Step 2: Now handle addition and subtraction\n        int result = newOperands.get(0);\n        for (int i = 0; i < newOperators.size(); i++) {\n            String op = newOperators.get(i);\n            int nextOperand = newOperands.get(i + 1);\n            result = performOperation(result, nextOperand, op);\n        }\n        \n        return result;\n    }\n    \n    private int performOperation(int a, int b, String operator) {\n        switch (operator) {\n            case \"+\":\n                return a + b;\n            case \"-\":\n                return a - b;\n            case \"*\":\n                return a * b;\n            case \"/\":\n                return a / b; // Assuming b is not zero as per problem statement\n            case \"**\":\n                return (int) Math.pow(a, b);\n            default:\n                throw new IllegalArgumentException(\"Invalid operator: \" + operator);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        List<String> operators = Arrays.asList(\"+\", \"*\", \"-\");\n        List<Integer> operands = Arrays.asList(2, 3, 4, 5);\n        int result = sol.do_algebra(operators, operands);\n        System.out.println(\"Result: \" + result); // Output: Result: 9\n    }\n}\n"}
{"task_id": "Java/161", "generation": "import java.util.*;\n\nclass Solution {\n    public String solve(String s) {\n        // Check if the string contains any letters\n        boolean hasLetter = false;\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                hasLetter = true;\n                break;\n            }\n        }\n        \n        if (hasLetter) {\n            // If there are letters, reverse their case\n            StringBuilder result = new StringBuilder();\n            for (char c : s.toCharArray()) {\n                if (Character.isLetter(c)) {\n                    // Reverse case\n                    if (Character.isLowerCase(c)) {\n                        result.append(Character.toUpperCase(c));\n                    } else {\n                        result.append(Character.toLowerCase(c));\n                    }\n                } else {\n                    // Keep non-letter characters unchanged\n                    result.append(c);\n                }\n            }\n            return result.toString();\n        } else {\n            // If there are no letters, reverse the entire string\n            return new StringBuilder(s).reverse().toString();\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.solve(\"1234\")); // Output: \"4321\"\n        System.out.println(solution.solve(\"ab\"));   // Output: \"AB\"\n        System.out.println(solution.solve(\"#a@C\")); // Output: \"#A@c\"\n    }\n}\n"}
{"task_id": "Java/162", "generation": "import java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Optional;\n\nclass Solution {\n    /**\n    Given a string \"text\", return its md5 hash equivalent string with length being 32.\n    If \"text\" is an empty string, return Optional.empty().\n    \n    >>> string_to_md5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\"\n    */\n    public Optional<String> string_to_md5(String text) throws NoSuchAlgorithmException {\n        // Check if the input string is empty\n        if (text == null || text.isEmpty()) {\n            return Optional.empty();\n        }\n\n        // Create a MessageDigest instance for MD5\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        \n        // Compute the hash\n        byte[] messageDigest = md.digest(text.getBytes());\n        \n        // Convert the byte array to a hexadecimal string\n        StringBuilder hexString = new StringBuilder();\n        for (byte b : messageDigest) {\n            String hex = Integer.toHexString(0xff & b);\n            if (hex.length() == 1) {\n                hexString.append('0');\n            }\n            hexString.append(hex);\n        }\n        \n        // Return the MD5 hash as an Optional\n        return Optional.of(hexString.toString());\n    }\n}\n"}
{"task_id": "Java/163", "generation": "import java.util.*;\n\nclass Solution {\n    public List<Integer> generate_integers(int a, int b) {\n        List<Integer> evenDigits = new ArrayList<>();\n        \n        // Determine the range\n        int start = Math.min(a, b);\n        int end = Math.max(a, b);\n        \n        // Loop through the range\n        for (int i = start; i <= end; i++) {\n            // Check if the number is even and less than 10\n            if (i % 2 == 0 && i < 10) {\n                evenDigits.add(i);\n            }\n        }\n        \n        return evenDigits;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.generate_integers(2, 8)); // Output: [2, 4, 6, 8]\n        System.out.println(solution.generate_integers(8, 2)); // Output: [2, 4, 6, 8]\n        System.out.println(solution.generate_integers(10, 14)); // Output: []\n    }\n}\n"}
